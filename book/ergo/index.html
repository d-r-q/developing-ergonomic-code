<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Разработка эргономичного кода - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/book/ergo/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/book/ergo/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/book/ergo/><title>Разработка эргономичного кода - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/book/ergo/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/book/ergo>Книга</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Разработка эргономичного кода</h1></header><nav id=toc class=toc role=doc-toc><h2 id=toc-title>Table of Contents</h2><ol class="toc-list level-0"><li><a href=#_техническая_глава>Техническая глава</a><ol class="toc-list level-1"><li><a href=#_работа_не_завершена>Работа не завершена</a></li><li><a href=#_to_do>To do</a></li></ol></li><li><a href=#_введение>Введение</a><ol class="toc-list level-1"><li><a href=#_мотивация>Мотивация</a></li><li><a href=#_что_такое_эргономичный_код>Что такое эргономичный код?</a></li><li><a href=#_это_всё_из_за_эффектов_todo_или_таки_состояния>Это всё из-за эффектов (<mark>todo: или таки состояния</mark>)</a></li><li><a href=#_как_появляются_скрытые_связи>Как появляются скрытые связи?</a></li><li><a href=#_базовые_идеи>Базовые идеи</a><ol class="toc-list level-2"><li><a href=#_layered_architecture>Layered architecture</a></li><li><a href=#_hexagonal_portsadapters_architecture_clean_architecture_onion_architecture>Hexagonal (Ports&Adapters) architecture, Clean architecture, Onion architecture</a></li><li><a href=#_data_context_interaction_architecture>Data, Context, Interaction Architecture</a></li><li><a href=#_domain_driven_desing>Domain Driven Desing</a></li><li><a href=#_simple_made_easy>Simple Made Easy</a></li><li><a href=#_functional_core_imperative_shell_fcis>Functional core, imperative shell (FCIS)</a></li><li><a href=#_railway_oriented_programming>Railway oriented programming</a></li></ol></li></ol></li><li><a href=#_проектирование>Проектирование</a><ol class="toc-list level-1"><li><a href=#_принципы_проектирования>Принципы проектирования</a></li><li><a href=#_парадигмы_программирования_todo_переименовать_и_унести_куда_то>Парадигмы программирования (<mark>todo: переименовать и унести куда-то</mark>)</a><ol class="toc-list level-2"><li><a href=#_процедурное_программирование_todo_коммент>Процедурное программирование (<mark>todo: коммент</mark>)</a></li><li><a href=#_объектно_ориентированное_программирование>Объектно-ориентированное программирование</a></li><li><a href=#_функциональное_программирование>Функциональное программирование</a></li><li><a href=#_мультипарадигменное_программирование>Мультипарадигменное программирование</a></li></ol></li><li><a href=#_модель_системы_stub>Модель системы? (Stub)</a></li><li><a href=#_таблица_эффектов>Таблица эффектов</a><ol class="toc-list level-2"><li><a href=#_принципы_проектирования_системы>Принципы проектирования системы</a></li></ol></li><li><a href=#_модель_юз_кейса>Модель Юз Кейса</a><ol class="toc-list level-2"><li><a href=#_платформа>Платформа</a></li><li><a href=#_порты>Порты</a></li><li><a href=#_адаптеры>Адаптеры</a></li><li><a href=#_логика>Логика</a></li><li><a href=#_юз_кейсы>Юз кейсы</a></li></ol></li><li><a href=#_декомпозиция_приложения>Декомпозиция приложения</a><ol class="toc-list level-2"><li><a href=#_разбиение_по_видам_классов>Разбиение по видам классов</a></li><li><a href=#_другие_идеи_к_разбиению_классов>Другие идеи к разбиению классов</a></li><li><a href=#_мой_подход_к_разбиению_классов>Мой подход к разбиению классов</a></li></ol></li></ol></li><li><a href=#_кодирование>Кодирование</a><ol class="toc-list level-1"><li><a href=#_конструкторы_должно_создавать_валидные_объекты>Конструкторы должно создавать валидные объекты</a></li><li><a href=#_у_класса_может_быть_не_более_5_зависимостей>У класса может быть не более 5 зависимостей</a></li><li><a href=#_наследование_todo>Наследование (<mark>todo</mark>)</a><ol class="toc-list level-2"><li><a href=#_открытые_иерархии>Открытые иерархии</a></li><li><a href=#_закрытые_иерархии>Закрытые иерархии</a></li></ol></li><li><a href=#_избегайте_интерфейсов_с_единственной_реализацией_todo>Избегайте интерфейсов с единственной реализацией (<mark>todo</mark>)</a></li><li><a href=#_иммутабельность_по_дефолту_todo>Иммутабельность по дефолту (<mark>todo:</mark>)</a></li><li><a href=#_domain_specific_languages_todo>Domain Specific Languages (<mark>todo</mark>)</a></li><li><a href=#_типизированные_иды_todo>Типизированные ИДы (<mark>todo:</mark>)</a></li><li><a href=#_cqrs_todo>CQRS (<mark>todo:</mark>)</a></li><li><a href=#_обработка_ошибок_todo>Обработка ошибок (<mark>todo:</mark>)</a></li><li><a href=#_find_usages_колонок_бд_todo>Find Usages колонок БД (#todo: #)</a></li></ol></li><li><a href=#_тестирование_todo>Тестирование (<mark>todo</mark>)</a><ol class="toc-list level-1"><li><a href=#_моки_todo>Моки (<mark>todo</mark>)</a></li><li><a href=#_tdd_todo>TDD? (<mark>todo</mark>)</a></li><li><a href=#_ассерты_todo>Ассерты (<mark>todo:</mark>)</a></li><li><a href=#_контракты_todo>Контракты (<mark>todo:</mark>)</a></li></ol></li><li><a href=#_заключение>Заключение</a><ol class="toc-list level-1"><li><a href=#_примеры_todo>Appendix A: Примеры (<mark>todo</mark>)</a><ol class="toc-list level-2"><li><a href=#_qbit_todo>qbit (<mark>todo</mark>)</a></li><li><a href=#_q5_todo>Q5 (<mark>todo</mark>)</a></li><li><a href=#_удобно_todo>Удобно (<mark>todo</mark>)</a></li><li><a href=#_проект_трустори>Проект ТруСтори</a></li><li><a href=#_todos_todo>Todos (<mark>todo</mark>)</a></li></ol></li></ol></li><li><a href=#_дальнейшее_чтение>Appendix B: Дальнейшее чтение</a><ol class="toc-list level-2"><li><a href=#_люди>Люди</a></li><li><a href=#_книги>Книги</a></li><li><a href=#_научные_статьи>Научные статьи</a></li><li><a href=#_публицистические_статьи>Публицистические статьи</a></li><li><a href=#_блог_посты>Блог посты</a></li><li><a href=#_доклады>Доклады</a></li></ol></li><li><a href=#_spring>Appendix C: Spring</a><ol class="toc-list level-2"><li><a href=#_не_использовать_компонент_скан_todo>Не использовать компонент скан (<mark>todo:</mark>)</a></li></ol></li></ol></nav><section class="doc-section level-0"><h1 id=_техническая_глава>Техническая глава</h1><section class="doc-section level-1"><h2 id=_работа_не_завершена>Работа не завершена</h2><p>Этот материал, который пока что скорее является серией статей и заметок находится в разработке.
Я надеюсь, что со временем, он превратится в книгу о том, как разрабатывать "сатисфактори" проекты - проекты которые и разрабатывать приятно и использовать.
Разделы, которые я планирую включить в книгу, я пишу в "совершённом" времени - как будто они часть уже написанной книги.
Некоторые разделы написаны в стиле "поток сознания" и оставлены отлежаться, но закоммитаны, чтобы не мозолить глаза и не затеряться.</p><p>На момент написания этого материала, я большую часть времени занимаю разработкой бэка на спринге, поэтому есть некоторый перекос в эту сторону.
Но за свою карьеру я участвовал в разработке проектов самых разных типов и изложенные идеи должны быть применимы в целом к разработке софта.
Со временем я обобщу изложенные идеи и приведу примеры их реализации в различных контекстах.</p></section><section class="doc-section level-1"><h2 id=_to_do>To do</h2><div class="olist arabic"><ol class=arabic><li>Вставить диаграмму кубита, в качестве иллюстрации подхода к разбиению на пакеты</li><li>Разобрать пример с отображением списка (списков дел), либо сообщение о пустом списке<ol class=loweralpha type=a><li>Где должен быть этот иф? В юз кейсе или во вью?</li><li>Что вообще делать с этим ифом? Тащить его отдельно в логику кажется перебором.</li></ol></li><li>Выброс исключения - это эффект?</li><li>Разбиение цикла между вью и юз кейсом<ol class=loweralpha type=a><li>Забить</li><li>Обсёрвер</li><li>Возврат экшена в onXXX. Но что делать, если требуется возаимодействие - onDelete → askConfirmation → delete. Отдельные эвенты? Корутины?<ol class=lowerroman type=i><li>Примерно туда же - где должна быть логика запроса подтверждения удаления? В принципе её можно целиком во вью оставить, дёргая юз кейс только при подтверждении. Но Очевидно ли это?</li></ol></li></ol></li><li>threads#bd5d4a4e, MessageServiceImpl#setMessageChannel</li><li>Эвент != юз кейс. Эвент - атомарное действие вызываемое обычным событием (сообщением в традиционном ООП), юз кейс - сценарий достижения определённой цели, продвигаемый одним или более событием <a href=#apx_talk_dci>DCI: Practical Tips and Lessons for Nerds</a></li><li>Habits <a href=#apx_talk_dci>DCI: Practical Tips and Lessons for Nerds</a></li><li>Инклуды юз кейсов вредные, потому что теряют цель <a href=#apx_talk_dci>DCI: Practical Tips and Lessons for Nerds</a></li><li>Дизайн - разделение стабильных и изменяющихся частей <a href=#apx_talk_dci>DCI: Practical Tips and Lessons for Nerds</a>, <a href=#apx_peop_uncle_bob>Анкл Боб</a></li><li>Доменная модель должна быть стабильной <a href=#apx_talk_dci>DCI: Practical Tips and Lessons for Nerds</a>, <a href=#apx_peop_uncle_bob>Анкл Боб</a></li><li>Традиционные сервисы - жирные DCI Roles?</li><li>Peter Coad, object modelling in code (<a class=bare href=https://www.infoq.com/articles/domain-color-modeling/>https://www.infoq.com/articles/domain-color-modeling/</a>)</li><li>Юз кейсы - идеально место для осмысленных комментов. Сейчас стандартный бэк - это в основном набор структур данных и пакетов процедур для манипуляции ими и логику описывать не где. Юз кейсы же кодом описывают связанные куски логики и этот код можно сдобрить хорошим комментом.</li><li>Комменты и коммит мессаджи на русском. Глухой телефон в КБ информ. На английском в опенсорсе, забугорных заказчиках, между народных коммандах.</li><li>Временные таблицы (таблицы с данными не входящими в доменную модель и из которых данные постоянно удаляются) - потенциально скрытые юз кейсы</li><li>Юз кейсы - настоящие объекты, с настоящим состоянием и настоящей логикой и настоящей инкапсуляцией.</li><li>Коплейн <a href=#apx_peop_coplien>Джеймс Коплейн (James Coplien)</a>: юнит тесты снижают качество кода</li><li>Изучение домена: <a href=#apx_peop_coplien>Джеймс Коплейн (James Coplien)</a>, <a href=#apx_book_ddd>DDD</a>, <a href=#apx_book_object_thinking>Object Thinking</a></li><li>Большинство ошибок находятся во взаимо действии <a href=#apx_artc_seg>Segue</a></li><li>"Чем раньше обнаружена ошибка, тем дешевле её исправить" - миф? <a href=#apx_artc_seg>Segue</a></li><li>"A proper book isn’t just a collection of facts, it reflects cause and mission" <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a></li><li>"If we reflect the end user mental model in the code, we are more likely to have working software" <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a></li><li>Высокое качество достигается в первую очередь Очевидностью эффектов кода и во вторую покрытием тестами</li><li>Динамическая вс статическая типизация<ol class=loweralpha type=a><li>Типы Очевидны</li><li>Код проще исследовать</li><li>Типы исключат целый пласт ошибок</li><li>Юнит тесты не могут исключить те ошибки, которые исключают типы</li></ol></li><li>Архитекутра ОО-сиситема - протоптанные пути сообщений между объектами, <a href=#apx_talk_dci_glimpse_of_rygve>A Glimpse of Trygve: From Class-oriented Programming to Real OO</a>, 12:00</li><li>Архитектура - результат дизайна. Дизайн - акт решения проблемы Проблема - разници между имеющимся положением дел и желаемым <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a></li><li>Сервисы в ДДД - это роли в ДэЦэИ. "Some of these are intrinsically activities or actions, not things, but since our modeling paradigm is objects, we try to fit them into objects anyway…​" <a href=#apx_book_ddd>DDD</a></li><li>Инфраструктурные, доменные и прикладные сервисы из ддд - это адаптеры, бизнес-логика и юзкейсы из эрго.</li><li><a class=bare href=https://www.ozon.ru/context/detail/id/5430638/>https://www.ozon.ru/context/detail/id/5430638/</a></li><li><a class=bare href=http://se.ethz.ch/~meyer/publications/functional/meyer_functional_oo.pdf>http://se.ethz.ch/~meyer/publications/functional/meyer_functional_oo.pdf</a></li><li><a class=bare href=https://github.com/jcoplien/trygve>https://github.com/jcoplien/trygve</a></li><li><a class=bare href=http://fulloo.info/Documents/trygve/trygve1.html>http://fulloo.info/Documents/trygve/trygve1.html</a></li><li>Определение хорошейго описания проблемы <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, p. 70</li><li>Добавить вставки с техниками как в <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>?</li><li>"Localizing change lowers cost and makes programming more fun", <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, p. 102</li><li>"while modules have a necessary relationship to business semantics", <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, p. xxx</li><li>"Architecture is more art than sience", <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, p. 117</li><li><a class=bare href=https://www.amazon.com/Pattern-Oriented-Software-Architecture-System-Patterns/dp/0471958697>https://www.amazon.com/Pattern-Oriented-Software-Architecture-System-Patterns/dp/0471958697</a></li><li><a class=bare href="https://www.youtube.com/watch?v=Nsjsiz2A9mg">https://www.youtube.com/watch?v=Nsjsiz2A9mg</a><ol class=loweralpha type=a><li>Arch is about intent, 10:30</li></ol></li><li>Софт общего назначения не должен зависить от софта спец назначения <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, p. 176</li><li>Habits из <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a> - юз кейсы подсистем?<ol class=loweralpha type=a><li>"Habits tend to be partial orderings of steps, and can represent business rules, algorithms, or steps in a use case" <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, p. 184</li><li>"Habits should not have variations" <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, p. 184</li></ol></li><li>"It’s common to separate out business rules and other supporting details from use case descriptions", <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, p. 183</li><li>Эффекты можно описывать пост-условиями</li><li>if considered harmful</li><li>В случае гуя юз кесйы должны быть в гуе? Что делать с многопользовательскими юзкейсами (Запрос/апрув блокировки)?</li><li>Переходы между разделами/главами</li><li>Баги видны только через эффекты</li><li>алиасы + персональные менеджеры</li><li>Patterns of Software - habitability</li><li>A complex software system becomes manageable when responsibilities are partitioned and organized and when collaboration follow predictable patterns. Object Design Roles Responsibilities and Collaborations, Chapter 5. Collaborations</li><li>Conceptual integrity is an attribute of a quality design. It implies that a limited number of design "forms" are used and that they are used uniformly. Object Design Roles Responsibilities and Collaborations, Control Style Options минус одна страница</li></ol></div></section></section><section class="doc-section level-0"><h1 id=_введение>Введение</h1><section class="doc-section level-1"><h2 id=_мотивация>Мотивация</h2><p>Начинается новый рабочий день.
Вы приходите на работу или натягиваете рабочие штаны, если повезло работать из дома.
В багтрекере на вас назначена новая задача.
Или эта задача висит уже несколько дней или даже недель.
Её надо делать, вы понимаете, что ещё важнее налить кофе.
Идёте наливать кофе, если вам "повезло" курить, то заодно можно и покурить.
Если вам "повезло" работать в офисе, то в курилке цепляетесь языками с коллегой.
Так прошёл час и вы возвращаетесь к компьютеру.
Но вспоминаете, что не проверили почту!
Идём проверять почту.
Так почта, проверена, но чего-то ещё не хватает.
А, точно, новости!
Обязательно индустриальные, не шоубиз или политика какая.
Ну и кофе кончился, да и час прошёл, покурить ещё раз можно.
Прошёл ещё час.
В принципе уже и пообедать можно.
А после обеда покурить - святое дело.
Да и кофе остыл, надо новый налить.
Ещё час.
Скоро стендап, там надо будет что-то говорить, так что надо уже таки наконец пытаться начинать пытаться что-то как-то делать…​</p><p>Знакомая ситуация?
Мне - да.
У меня так бывает когда я боюсь делать задачу, потому что практика показывает, что любая правка вносит два бага в самых разных и неожиданных местах.
Или второй вариант - не понятно не то что как работает тот код куда надо вносить правки, непонятно даже где этот самый код и как его искать.
А единственный человек который это знал уволился пару месяцев назад.</p><p>Я профессионально занимаюсь разработкой софта с 2004 года.
За это время я поработал в пятнадцати командах и более двадцати проектах.
Это были очень разные проекты - от встроенных систем до биг даты, с командой от одного до двадцати пяти человек, гринфилд проекты и проекты корнями уходящие в 80-ые годы.
Одно объединяло все эти проекты - в каждом из них хотя бы раз был день из первого абзаца.</p><p>Для меня разработка софта это не способ поменять N единиц времени на K единиц денег.
Для меня разработка софта явлется основной областью интересов.
Поэтому я много часов (возможно те самые десять тысяч) провёл в поисках ответов на вопросы "Почему весь нетривиальный софт так сложно понимать и так страшно менять?" и "Как делать софт, котрый легко понимать и безопасно менять?".</p><p>И в результате этих размышлений я пришёл к выводу, что все эти проекты объединяли скрытые связи в коде.
Именно скрытые связи делают код и хрупким и сложным для понимания.
Скрытые связи делают тестирование кода сложным и/или бессмысленным (проходящие тесты ничего не говорят о работоспособности кода).
Скрытые связи невозможно исключить полностью, поэтому "эти дни" - я это часть нашей профессии, а умение работать в такие дни - часть профессионализма.
Но скрытые связи можно максимально проявить и свести количество "этих дней" к минимуму.</p><p>В этой книге я привожу концептуальную модель софта и набор практик разработки, которые:
. Делают Очевидным то, какие функции выполняет софт
. Делает Очевидным то, что является входом и выходом каждой функции, выполняемой софтом
. Делает Тестируемым то, что невозможно сделать Очевидным в силу его естественной сложности</p><p>Благодаря этому, становится намного проще понять, куда именно необходимо вносить те или иные правки и каковы будут их последствия.
А для сложных частей кода можно быть уверенным в тестах.</p><p>Главной мотивацией к написанию этой книги было структурирование собственных мыслей о том, как писать эргономичный код.
Кроме того, мне требовалось руководство разработчика в командах, которыми управляю я сам, и как референсный (<mark>todo: корректное слово</mark>) материал в предложениях по улучшению кода и архитектуры в командах, в которых политику разработки определяют другие люди.</p><p>Кроме того я уже много лет преподаю различные курсы по программированию и просто довольно много взаимодействую с молодыми программистами.
И в последнее время я начал уставать от пересказа одних и тех же идей по нескольку раз в год и с этой книгой у меня есть единое и "консистентное" (<mark>todo: перевести на русский</mark>) место, куда можно отсылать учеников.</p><p>Я пишу эту книгу с очень амбициозной целью - создать новый стандарт де факто разработки коммерческих приложений.
Стандарт, который сделает софт эргономичным не только для конченого пользователя, но я для разработчика.</p></section><section class="doc-section level-1"><h2 id=_что_такое_эргономичный_код>Что такое эргономичный код?</h2><p>(<mark>todo: попровить шрифт цитат</mark>)</p><p>Что же такое эргономичный код?
Для начала рассмотрим несколько определений термина "эргономичность" в общем смысле, а потом адаптируем их к коду:</p><div class=quote-block><blockquote><p>Эргономичность - наличие условий, возможностей для лёгкого, приятного, необременительного пользования чем-либо или удовлетворения каких-либо нужд, потребностей</p><footer>— <cite>Большой толковый словарь русского языка</cite></footer></blockquote></div><div class=quote-block><blockquote><p>Эргономичность - способность продукта быть понимаемым, изучаемым, используемым и привлекательным для пользователя в заданных условиях</p><footer>— <cite>ISO/IEC 25010</cite></footer></blockquote></div><div class=quote-block><blockquote><p>Эргономичность - дизайн оборудования, учитывающий взаимодействие человек/машина, позволяющий снизить вероятность ошибки оператора, повысить комфортность условий его работы.</p><footer>— <cite>Краткий толковый словарь по полиграфии</cite></footer></blockquote></div><div class=quote-block><blockquote><p>Эргономичность - в изначальном смысле это эффективность инструмента производства или системы в эргономике. Под эффективностью при этом понимается наибольшая производительность при наименьшей вероятности ошибки (пользователя но не устройства). Ныне термин употребляется в более широком смысле, обозначая общую степень удобства предмета (не обязательно средства производства), экономию времени и энергии при использовании предмета. Например: «эргономичный токарный станок», «эргономичный электромобиль» или даже «эргономичный стул».</p><footer>— <cite>dic.academic.ru</cite></footer></blockquote></div><p>В нашем случае, понятно, пользователем/оператором/человеком будет программист, чем-либо/продуктом/оборудованием/инструментом производства будет код, а пользованием/использованием будет внесение модификаций (включая добавление нового кода) в существующий код.
В первой цитате, мне (как "пользователю" кода) нравятся характеристики "лёгкий и приятный в использовании";
В второй цитате, мне нравятся характеристики "понимаемый и изучаемый";
В третьей цитате, мне нравится характеристика "снижающий вероятность ошибки";
Наконец, в четвёртой цитате (помимо уже упомянутой вероятности ошибки) мне нравится характеристика "наибольшая производительность".</p><p>Объединив все эти характеристики, получаем следующее определение:</p><div class=quote-block><blockquote><p>Эргономичный код - это код, обеспечивающий наибольшую производительность программиста, за счёт простоты понимания и изучения, снижения вероятности внесения ошибки при модификации. Понятный и защищённый от внесения ошибок код, в свою очередь становится лёгким и приятным для внесения изменений.</p><footer>— <cite>Алексей Жидков, Разработка эргономичного кода</cite></footer></blockquote></div><p>Важно понимать, что создание эргономичной вещи требует намного больше усилий, чем создание просто вещи.
Поэтому эта книга не о том, как сделать вашу жизнь лёгкой сегодня, эта книга о том, какие усилия надо приложить сегодня, чтобы сделать вашу жизнь лёгкой завтра.</p><p>Что же делает код эргономичным?
Явность (<mark>todo: перевести на русский</mark>) связей и надёжный набор автоматизированных тестов.
Тому что это значит и как этого достичь посвящена вся оставшаяся часть книги.</p></section><section class="doc-section level-1"><h2 id=_это_всё_из_за_эффектов_todo_или_таки_состояния>Это всё из-за эффектов (<mark>todo: или таки состояния</mark>)</h2><p>Для начала определимся с терминологией и для этого обратимся к основам ИТ - устройству компьютера.
Напомню, что упрощённо, компьютер состоит из трёх частей:</p><div class="olist arabic"><ol class=arabic><li>Процессор</li><li>Память</li><li>Устройства ввода вывода</li><li>Материнская плата</li></ol></div><p>А работа компьютера это следующий REPL:</p><div class="olist arabic"><ol class=arabic><li>Дождаться прерывания от устройства ввода</li><li>Скопировать данные из памяти выделенной для устройства ввода в память программы</li><li>Обработать данные в памяти</li><li>Результаты обработки скопировать из памяти программы в память выделенную для устройства вывода</li><li>Отправить прерывание</li></ol></div><p>И любая программа, от таймкиллера на смартфоне, до компилятора, до АСУТП в конечном итоге сводится к тому, что устройство ввода превращает нажатие кнопки в прерывание, а устройство вывода изменяет физический мир благоприятным для пользователя образом.</p><p>Так вот в данной книге используются следующие термины:</p><div class=dlist><dl><dt>Состояние</dt><dd>значение памяти всех устройств из которых состоит система</dd><dt>Эффект</dt><dd>операция записи данных в память</dd><dt>Событие</dt><dd>вызов прерывания устройством ввода</dd></dl></div><p>Так на самом абстрактом уровне результат работы программы можно наблюдать только по средствам изменения характеристик каких-то физических объектов - пикселей экранов, транзисторов SSD-дисков и т.д.
И как следует из приведённых устройств компьютера и его работы, наблюдаемые результаты являются отражением нового <strong>состояния</strong> системы, изменённого под воздействием <strong>эффектов</strong> выполненных в ходе реакции на <strong>событие</strong>.</p><p>То есть все программы пишутся ради эффектов, которые они выполняют.
А баги в программах - это не те эффекты или те эффекты, но выполненные не так, как ожидает пользователь.
Наконец, регрессии в программах - это когда в результате модификации программы изменился набор, порядок и/или значения эффектов, выполняемых программой по определённому событию.
(<mark>todo: подводку в эргономичном коде про регресии и сложность рефакторинга</mark>)</p><p>Так вот эргономичная программа, это такая программа, в которой связка "событие → начальное состояние + набор эффектов" описаны настолько просто и явно, что по этому описанию можно было одним взглядом понять, что "в программе очевидно нет дефектов" (<mark>todo: сноска на Хоара</mark>)</p><p>Проблема в том, что сейчас ни где не учат и практически никто не акцентирует внимание на том, насколько важно понимание начального состояние и эффектов программы для корректной модификации программы.
В результате обращение к глобальному состоянию и ввод-вывод в произвольных частах программы являются общепринятой практикой в современных программах.
А это в свою очередь влечёт то, что понимание эффектов программы требует огромных концентрации и времени.</p><p>(<mark>todo: систему надо нарезать на пакеты соответствующие объектам из OOSE</mark>)
(<mark>todo: а объекты дизайнить как аггрегаты ДДД</mark>)
(<mark>todo: и минимизировать их кол-во как в ФП #)
(#todo: и модули соответствующие чистой архитектуре</mark>)
(<mark>todo: потому что один фиг надо чем-то жертвовать. чем в каждом из вариантов?</mark>)</p></section><section class="doc-section level-1"><h2 id=_как_появляются_скрытые_связи>Как появляются скрытые связи?</h2><p>Скрытые связи появляются в коде всякий раз, когда вы обращаетесь к куче (глобальной памяти).
(<mark>todo: исключения записать в эффекты?</mark>)
(<mark>todo: менеджед языки уменьшают кол-во скрытых связей?</mark>)</p><p>(<mark>todo: втф в секунду</mark>)</p></section><section class="doc-section level-1"><h2 id=_базовые_идеи>Базовые идеи</h2><p>(<mark>todo: сделать факт-чекинг</mark>)</p><p>Принципиально новых идей в эргономичном подходе нет и его главной контрибуией (<mark>todo: перевод</mark>) является сбор в одном месте и подгонка друг к другу идей из различных сообществ - в первую очередь объектно-ориентированного и функционального.</p><div class="olist arabic"><ol class=arabic><li>Layered architecture</li><li>Hexagonal/Onion/Clean architecture</li><li>Data, Context, interaction architecture</li><li>Domain Driven Design</li><li>Simple Made Easy</li><li>Functional core, imperative shell</li><li>Railway oriented programming</li></ol></div><p>Давайте бегло рассмотрим эти идеи подчеркнув что роднит эргономичный подход с ними, а что отличает (<mark>todo: поправить стиль</mark>).
Начнём с идей из ОО-лагеря, потому что эргономичный подход это скорее ОО-подход с элементами ФП, нежели наоборот.</p><section class="doc-section level-2"><h3 id=_layered_architecture>Layered architecture</h3><p><a href=https://dzone.com/articles/layered-architecture-is-good>Layered architecture</a>, <a href=https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0>слоистая архитектура</a>. (<mark>todo: найти хоршие ссылки</mark>)</p><p>(<mark>todo: привести 100500ое описание слоёной архитектуры?</mark>)</p><p>Эргономичный код нарезан в том числе и на слои.
Но в отличие от традиционной слоёной архитектуры, слои являются предпоследней гранулярностью (<mark>todo: перевод</mark>) нарезки, зачастую вырождающейся в нарезку на классы/объекты.
Плюс в отличие от многих версий слоёной архитектуры, слой доступа к данным (ввод-вывод) поднят на один уровень с бизнес-логикой.
Это сделано во имя "Очевидности и тестируемости":
- Благодаря обращению к инфраструктурному слою напрямую из слоя приложения, становится Очевидно какие эффекты имеет функция
- Благодаря удалению зависимости слоя бизнес-логики (где обычно находится вся сложность приложения) от слоя ввода-вывода, бизнес-логика становится Тестируемой.</p></section><section class="doc-section level-2"><h3 id=_hexagonal_portsadapters_architecture_clean_architecture_onion_architecture>Hexagonal (Ports&Adapters) architecture, Clean architecture, Onion architecture</h3><div class=ulist><ul><li><a href=http://web.archive.org/web/20051208100950/http://alistair.cockburn.us/crystal/articles/hpaaa/hexagonalportsandadaptersarchitecture.htm>Оригинальная статья 2005 года о Hexagonal Architecture</a></li><li><a href=https://habr.com/ru/post/267125/>описание на русском Hexagonal Architecture</a>.</li><li><a href=https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/>Оригинальная серия статей об Onion Architecture</a></li><li><a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>Оригинальная статья о Clean Architecture</a></li><li><a href=https://habr.com/ru/company/mobileup/blog/335382/>Хорошее пояснение Clean Architecture на русском</a></li><li><a href=https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164>Оригинальная книга о Clean Architecture</a></li><li><a href=https://www.ozon.ru/context/detail/id/144499396/>Книга на русском о Clean Architecture</a></li></ul></div><p>Все эти три архитектуры (HOCA), на мой взгляд, являются вариациями разных авторов на одну и ту же тему.
По сути все эти архитектуры призывают к одному - отделить логику от ввода-вывода, для того чтобы её было легко тестировать.
И это основное что роднит эргономичный подход с HOCA.
Но способы достижения целей у нас разные.
HOCA предлагает вводить интерфейсы между логикой и вводом-выводом, что подразумевает активное использование моков в тестах.
А тестирование с моками - это тестирование реализации, а не контракта и оно ничего не говорит о поведении кода в бою.
Эргономичный же стиль предлагает реализовывать логику ввиде чистых функций, что, во-первых, делает невозможным сокрытие эффектов в дебрях логики и, во-вторых, позволяет тестировать контракт, а не реализацию и именно тот код, который будет работать в бою.</p><p>Так же HOCA утверждает, что способы взаимодействия с пользователем и хранения данных являются незначительными деталями.
Для того чтобы обеспечить лёгкость замены этих деталек, они предлагают по дефолту вводить интерфейсы между всеми слоями.
Я не разделяю мнение, что эти части являются незначительными деталями, поэтому в эргономичном подходе предлагаю не вводить лишних интерфейсов без реальной необходимости, потому что эти интерфейсы не бесплатны.</p><p>В целом, я разделяю идею HOCA о том, что фреймворки должны быть задвинуты на задворки приложения (на самый внешний слой).
Но если использование той или иной фичи фреймворка делает жизнь проще и не наносит ущерб Очевидности и Тестируемости, то я не вижу большого криминала в зависиомсти от фреймворка.
Например, я считаю необоснованной технику, по абстрагированию логики транзакций в шлюзе вместо использования спрингового @Transactional (<mark>todo: ссылка на статю Маритна с примером</mark>).</p><p>Наконец дядюшке Бобу над отдать должное за <a href=https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html>Screaming architecture</a>.
На мой взгляд архитектура это слишком громкое слово, но я включаю этот принцип в тактические приёмы.</p><p>(<mark>todo: ревью: наверно стоит уделить внимание поподробнее чем они друг от друга отличаются</mark>)</p></section><section class="doc-section level-2"><h3 id=_data_context_interaction_architecture>Data, Context, Interaction Architecture</h3><p><a href=https://www.artima.com/articles/dci_vision.html>Оригинальная статья</a>.</p><p>Эргономичный подход включает в себя DCI целиком в качестве устройства юз кейса по дефолту.
Но так же как и в случае HOCA, эргономичный подход делает акцент на вынесении эффектов в юз кейс (контекст в терминах DCI) и как следствие на чистоте бизнес-логики (ролей в терминах DCI).</p><p>В чём эргономичный подход слегка расходится с DCI, так это в вопросе логики в объектах доменной модели.
По DCI объекты должны быть "dumb, dumb, dumb", т.е. просто структурами данных.
В эргономичном же подходе, доменные объекты во-первых, должны быть иммутабельными, и, во-вторых, должны защищать свои инварианты.</p></section><section class="doc-section level-2"><h3 id=_domain_driven_desing>Domain Driven Desing</h3><p>У эргономичного подхода много общего с DDD.
Например сервисы приложений, домена и инфраструктуры из DDD ответствуют юз кейсам, бизнес логике и адаптерам из эргономичного подхода.</p><p>Но в отличие от DDD, в эргономичном подходе большая часть поведения уносится в роли DCI.
Это сделано потому что подход DDD (помещения максимальной части бизнес-логики в сущности) плохо масшатабируется - у одной сущности может быть много ролей, и если все их засунуть в один класс, то он станет слишком большим.
Кроме того анемичная модель является стандартом де факто в индустрии.</p><p>И так же как и в случае со всеми предыдущими идеями из ОО-сообщества, эргономичный подход в отличие от DDD делает акцент на чистых функциях.</p><p>На этом идеи ОО-лагеря закончены и переходим к ФП лагерю.</p></section><section class="doc-section level-2"><h3 id=_simple_made_easy>Simple Made Easy</h3><p><a href=https://www.infoq.com/presentations/Simple-Made-Easy/>Simple Made Easy</a>, (<a href=https://tonsky.livejournal.com/243192.html>краткий пересказ на русском</a>).</p><p>На мой взгляд, Рич Хики - один из самых крутых чуваков в индустрии в наши дни.
А этот доклад - один из самых крутых докладов Рича Хики.</p><p>Именно этот доклад первым навёл меня на ключевую мысль эргономичного подхода - разделение эффектов и логики.
Кроме того в нём есть синхрония <mark>todo: нормальное слово</mark> в с DCI касательно, разделения структур данных и поведения.</p><p>Но я не разделяю мнение Хики о том, что типы бесполезны.
На мой взгляд, типы снимают целый класс проблем при модификации кода, и, что ещё важнее, делают существенный вклад в Очевидность кода.
Дополнительным плюсом является возможность создания эргономичных ИДЕ, что прекрасно ложиться на идею эргономичного кода.</p><p>Так же я не сторонник ядрёной функциональщины с абстракциями ультра высокого уровня.
Во-первых их сложно интернализировать <mark>todo: перевод</mark> до того уровня, чтобы код написанный с их помощью был Очевидным.
Во-вторых, они плохо поддерживаются большинством языков на которых пишется большинство программ.
В-третьих, они редко точно ложатся на предметную область.
В-четвёртых, многие из них созданы для обхода ограничений чистых функциональных языков, и этих ограничений нет в целевых языках эргономичного подхода.</p></section><section class="doc-section level-2"><h3 id=_functional_core_imperative_shell_fcis>Functional core, imperative shell (FCIS)</h3><p><a href="https://www.youtube.com/watch?v=yTkzNHF6rMs">Boundaries</a>, версии на русском я не нашёл.</p><p>Идеи изложенные в этом докладе являются вторым краеугольным камнем эргономичного подхода.
Пересмотр этого доклада привёл меня к концептуальной модели эргономичного юз кейса, которая в итоге вылилась в данную книгу.
В эргономичный подход включены обе ключевые идеи этого доклада - разделение логики и эффектов и использование структур данных, передаваемых юз кейсами, в качестве интерфейса между логикой и адаптерами.</p><p>Эргономичный подход является надмножеством FCIS и дополняет его как более высокоуровневыми политиками, так и более низкоуровневыми механизмами.</p></section><section class="doc-section level-2"><h3 id=_railway_oriented_programming>Railway oriented programming</h3><p><a href=https://fsharpforfunandprofit.com/rop/>Оригинальная статья</a></p><p>Серия статей о функциональном подходе к обработке ошибок.
Суть идеи в том, что юз кейс начинается на основном пути, в случае успеха идёт по нему и там же и заканчивается, но с основного пути есть съезды на "ошибочный экспресс", который ведёт сразу к завершению юз кейса.</p><p>Это наиболее низкоуровневая из базовых идей, которая применяется на уровне конкретных методов.
Но её вклад в Очевидность настолько важен, что я включил её и в список базовых идей и концептуальную модель юз кейса.</p><p>Так же эргономичный подход включает идею того, что ошибки которые предполагают обработку лучше передавать в качестве возможного результата выполнения функции.
Исключения же лучше оставить для ошибок программирования и фатальных ошибок в адаптерах и платформе.</p><p>Но в отличие от чисто функционального подхода на монадах, предлагаемого в этой серии статей, я за использование банальных ифов раннего возврата там, где они работают хорошо.
А они работают хорошо в большинстве случаев.
Я выбираю ифы, потому что условие и действие явно прописанные в коде более Очевидные, тем map, который может отработать или нет в зависимости от типа ресивера (<mark>todo: переписать по русски</mark>).</p><p>На этом рассмотрение базовых идей завершено и можно переходить к сути книги.
Как я уже говорил, в основе эргономичного подхода лежит концептуальная модель и набор практик.
Концептуальная модель описана в главе "Проектирование".
Набор практик разделён на практики кодирования и тестирования, и каждый вид практик выделен в отдельную главу.
Так же, в приложении приведено множество примеров различных типов приложений в различных предметных областях, которые призваны помочь читателю связать изложенные идеи с каждодневными проблемами, возникающими при написании кода.</p></section></section></section><section class="doc-section level-0"><h1 id=_проектирование>Проектирование</h1><div class="open-block partintro"><div class=content><p>(<mark>todo: алгоритмы + структуры данных = программы. В том числе на уровне модулей, контейнеров и систем</mark>)</p><div class=quote-block><blockquote><p>... The fundamental organiztion of a system embodien in its components, their relationships to each oterh, and to the environment and the principles guiding its design and evolution</p><footer>— <cite>IEEE1471 2007</cite></footer></blockquote></div><div class=quote-block><blockquote><p>Architecture represents the significant design decisioins that shape a system, where significiant is measured by cost of change</p><footer>— <cite>Booch 2006</cite></footer></blockquote></div><div class=quote-block><blockquote><p>the form of a system, where the word form has a special meainign that we’ll explore a bit later. (p. 2)</p><footer>— <cite>Coplien, Lean Architecture</cite></footer></blockquote></div><div class=quote-block><blockquote><p>(<mark>todo:</mark>)</p><footer>— <cite>Uncle Bob</cite></footer></blockquote></div><p>(<mark>todo: <a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, p. 80</mark>)</p><p>(<mark>todo: In software, an architectural style describes a set of constraints that — if followed — lead to certain traits of a system, <a class=bare href=http://olivergierke.de/2016/10/evolving-distributed-systems/>http://olivergierke.de/2016/10/evolving-distributed-systems/</a></mark>)</p></div></div><section class="doc-section level-1"><h2 id=_принципы_проектирования>Принципы проектирования</h2><p>Программы живут только пока они изменяются, поэтому при проектировании программы надо стремиться к тому, чтобы внесение этих изменений было простым.
Простота изменений достигается, если при проектировании программ следовать принципами:</p><div class="olist arabic"><ol class=arabic><li>Очевидности</li><li>Локальности</li><li>Расширяемости</li></ol></div><p>Если дизайн и код вашей программы Очевидны, то легко понять, какой код надо модифицировать для реализации изменения и к каким последствиям приведут эти модификации.
Очевидность достигается за счёт разделения Логики и Эффектов.
Приятным побочным эффектом этого разделения является повышение переиспользуемости Логики. Если Логика просто выдаёт какое-то значение, не порождая никаких эффектов, то к ней могу обращаться разные клиенты, которым нужны разные эффекты.
Этого же можно добиться, по средствам инжектирования интерфейса для Эффектов, но это намного более неуклюже (<mark>todo: стиль</mark>), чем чистая функция + "эффектор" + связующий их код.</p><p>Локальность достигается за счёт проектирования модулей с высокой связностью внутри модуля и низкой связностью между модулями.
Что в свою очередь достигается за счёт следования принципу SRP из SOLID.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Вообще у Мартина в <a href=#apx_book_clean_code>Clean Code</a> английским по белому написано:</p><div class=quote-block><blockquote><p>The Single Responsibility Principle (SRP) states that a class or module should have one, and only one, reason to change.</p><footer>— <cite>Martin, Clean Code</cite></footer></blockquote></div><p>Затем в <a href=#apx_book_clean_arch>Clean Architecture</a> он этот же принцип перефразирует:</p><div class=quote-block><blockquote><p>Indeed, we can rephrase the principle to say this:
A module should be responsible to one, and only one, user or stakeholder.</p><footer>— <cite>Martin, Clean Architecture</cite></footer></blockquote></div><p>И далее:</p><div class=quote-block><blockquote><p>Thus the final version of the SRP is:
A module should be responsible to one, and only one, actor.</p><footer>— <cite>Martin, Clean Architecture</cite></footer></blockquote></div><p>Но почему-то есть очень расхожее мнение о том, что "ответственность" - это одна "вешь" или "дело".
При том "вешь" и "дело" - очень расплывчатые определения и страшно представить, сколько часов высокооплачиваемые разработчики потратили на споры о том, сколько "вещей" делает этот код.
Откуда оно взялось я наверняка не знаю, но могу предположить, что оно было порождено путницей с одним из принципов философии Unix: "Make each program do one thing well".</p></aside><p>Наконец, расширяемость учитывается в последнюю очередь.
Потому что люди плохо предсказывают будущее, а расширяемость стоит ресурсов и в момент разработки и при сопровождении.
Но делать заготовки для точек расширения - можно и нужно.
Во многом, разделение логики и эффектов уже будет заготовкой для расширения - реализации Логики и Эффектов можно свободно добавлять и комбинировать между собой, а использование данных инкапсулированных в объекте в качестве интерфейса между Логикой и Эффектами, позволит локализовать изменения этого интефейса.
Где-то можно выделить алгоритм в отдельный метод или класс - что-то имеющее интерфейс, который в будущем можно будет сделать и легко заинжектить.
Где-то вместо простой строки можно использовать класс-обёртку, который в будущем опять же можно будет выделить и заменить на (закрытую) иерархию классов.</p></section><section class="doc-section level-1"><h2 id=_парадигмы_программирования_todo_переименовать_и_унести_куда_то>Парадигмы программирования (<mark>todo: переименовать и унести куда-то</mark>)</h2><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Слово "парадигма" ввёл обиход Томас Кун в 1962 (как раз на заре бурного развития ИТ) в книге «Структура научных революций».
Он был физик и рассматривая историю развития физики заметил, что в ней представление о мире менялось не эволюционно, а революционно.
Эволюционные периоды он называл парадигмой, а революционные - сменой парадигмы.
Основываясь на работе Куна, можно дать следующее определение парадигмы - это теория, признанная определенным научным сообществом и в нем существующая, правила и стандарты научной практики, а также модель постановки проблем и их решения.
Для нашей области это определение можно перефразировать так: это теория, признанная определённым сообществом разработчиков и в нём существующая, правила и стандарты разработки, а так же модель постановки проблем и их решения.</p></aside><p>Какие парадигмы существуют?
На данный момент это сложный вопрос - нет единого авторитетного источника, а в разных источниках эти списки разнятся.
Но во всех источниках присуствуют следующие парадигмы:</p><div class="olist arabic"><ol class=arabic><li>Процедурная.
Вообще считается устаревшей и повсеместно критикуемая.
Но на моей практике большинство програм написано в процедурном стиле на объектно-ориентированном языке.</li><li>Объектно-ориентированная.
Я думаю большинство промышленных программистов считают её наилучшей парадигмой и считают, что используют именно её.</li><li>Функциональная.
Старше объектно-ориентированной, но долгое время использовалась практически исключительно в академических кругах.
Однако в последние 10-15 лет стала набирать популярность и в промышленных кругах, во многом в связи с обострением потребности в много-поточном программировании.</li><li>Логическая.
Пока что так и осталась исключительно в академических кругах.
По крайней мере мне в промышленном коде не встречалась ни разу ни в каком виде за все 15 лет карьеры.</li></ol></div><p>От себя ещё свангую, что ИИ и МЛ со временем приведут к появлению какой-то новой парадигмы, очевидно уже применяемой в промышленном программировании.
Но пока не очень понимаю, как она впишется в эргономичный подход.
Видимо в качестве одной из функций логики, просто реализованной иначе.</p><p>Какая же из этих парадигм позволяет писать эргономичный код?</p><section class="doc-section level-2"><h3 id=_процедурное_программирование_todo_коммент>Процедурное программирование (<mark>todo: коммент</mark>)</h3><p>(<mark>todo: качественно разботанить тему и обосновать почему ПП хорошо только для эффектов. Ну или убедиться в обратном и написать книгу о ПП:)</mark>)</p></section><section class="doc-section level-2"><h3 id=_объектно_ориентированное_программирование>Объектно-ориентированное программирование</h3><p>Если вы ни разу не слышали про ООП, то у меня для вась есть новости:)
Если вы слышали про ООП, то, весьма вероятно, у меня для вас есть большие новости:)</p><p>Основываясь на определении парадигмы из введения, становится ясно что объектно-ориентированной парадигмы не существует.
Сейчас объясню.</p><p>Если вы что-то слышали про ООП, то наверняка слышали, что ООП это это программирование с классами и объектами.
А принципы ООП это:</p><div class="olist arabic"><ol class=arabic><li>Инкапсуляция</li><li>Полиморфизм</li><li>Наследование</li></ol></div><p>Некоторые особо продвинутые товарищи включают ещё и абстракцию.</p><p>Программа в целом в объектно-ориентированном подходе рассматривается как:</p><div class="olist arabic"><ol class=arabic><li>Либо набор объектов, отражающий сущности реального мира (Буч <a href=#apx_book_ood_booch>Object-Oriented Design with Applications</a> и Коад <a href=#apx_book_ooa_coad>Object-Oriented Analysis</a>).</li><li>Либо набор объектов, предстающий команду людей, которая сообща решает общую задачу обмениваясь сообщениями (Вест <a href=#apx_book_object_thinking>Object Thinking</a>).</li></ol></div><p>Звучит хорошо, но если вы пробовали применить эти подходы, то столкнулись с тем, что в реальном мире они не выживают.</p><p>Сначала рассмотрим классы и объекты.
Класс - это матрица для создания объектов.
А объект - это сущность, обладающая состоянием, поведением и идентичностью.</p><p>Но загляните в реальные проекты.
В типовом проекте 90% классов это либо структуры данных без поведения, либо пакеты процедур без состояния и идентичности.</p><p>В то же время, классы являются прекрасным инструментом для реализации функциональных концепций замыканий и каррирования, например.</p><p>Далее инкапсуляция и полиморфизм.
Эти техники активно используются и в процедурной и в функциональной парадигмах - это естественная потребность при написании больших программ.</p><p>С наследованием ещё хуже - это инструмент, от которого больше вреда чем пользы (см. <a href=#apx_book_eff_java>Effective Java</a>, "Item 18: Favor composition over inheritance").</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Наследование - это чисто технический инструмент, у которого есть три применения:</p><div class="olist arabic"><ol class=arabic><li>Сокращение дублирования кода в иерархиях структур данных</li><li>Защита публичного интерфейса публичного АПИ (абстрактные классы с закрытыми конструкторами, вместо интерфейсов) <a href=#apx_book_api>Practical API Design</a></li><li>Закрытие иерархии (#todo: обобщённое описания применения)</li></ol></div></aside><p>Вообще все эти концепции, хоть и чуть более многословно, но вполне моделируются и часто используются в языках и с функциональной и с процедурной парадигмой.</p><p>То есть применения рассмотренных техник программирования недостаточно, для того чтобы подход к разработке был объектно-ориентированным.
Возможно дело в дизайне?</p><p>Дисклаймер - вообще да:).
Но к озвученным выше подходам к дизайну возникает много вопросов и вот ключевые:</p><div class="olist arabic"><ol class=arabic><li>Как замоделировать письмо текста ручкой на бумаге? (<mark>todo: ответить на вопрос в терминаъ Труъ-ООП</mark>)</li><li>Почему в мире в один момент времени живёт только один человек/объект реального мира?
Ответ - потому что объекты имеют состояние, а состояние и параллельная работа - это боль и баги.
Есть конечно Экторная модель, но это уже из царства функционального программирования.</li><li>Если у меня у объекта двадцать пять операций - мне все их в один класс засовывать? А он не треснет?</li></ol></div><p>В результате предлагаемая модель программы не распространена в промышленном программировании - просто не понятно как реальные программы представить в этой модели.
Таким образом получается, что популярная версия ООП, принятая сообществом промышленных программистов, является эволюционным развитием процедурной парадигмы и отдельной парадигмой не является.</p><p>Так что же ООП это фикция?
В моей карьере был период когда я так считал и благодаря этому периоду я плотно изучил функциональный подход.
Но сейчас, после 15 лет изучения, практики и преподавания ООП/ООД, я начал понимать и снова верить в ООП.</p><p>Причиной тому послужили книги и статьи трёх других не менее авторитетных авторов:</p><div class="olist arabic"><ol class=arabic><li><a href=#apx_book_lean_arch>Lean Architecture for Agile Software Development</a>, в которой среди прочего описана DCI архитектура, сейчас продвигаемая Коплейном (соавтором шаблонов проектирования).</li><li>Но оригинальная идея DCI архитектуры была описана в статье <a href=#apx_paper_comm_sense>The Common Sense of Object Orientated Programming</a>, Тригви Риинскауга (автор шаблона MVC). Эта работа, в свою очередь уходит корнями к <a href=#apx_book_ooram>Working with objects: The OOram Software Engineering Method</a> его же авторства.</li><li><a href=#apx_book_oose>Object-Oriented Software Engineering: Use Case Drive Approach</a>, Ивара Якобсона (соавтор UML).</li></ol></div><p>Оба этих подхода утверждают, что программирование с объектами != программированию на классах и один объект дизайна в коде может превратиться в набор классов и их экземпляров.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Тут начинает играть новыми красками типовой спринговый подход с набором XXXController, XXXSerivce, XXXRepository и XXX на каждую таблицу xxx.
Если контроллер, сервис и репозиторий рассматривать в качестве ролей объекта XXX, а весь набор, как единое целое, то всё могло бы встать на свои места.
Но кто сейчас так делает?
В итоге эта группа классов превращается в структуру данных и набор процедур над ней из старого доброго процедурного программирования.</p></aside><p>OOSE такие наборы классов называет блоками, а DCI - контекстами.</p><p>Так же оба этих подхода включают понятие роли (интерфейса) - набора функций, выполняемых объектом (блоком).
И один и тот же блок может играть много ролей.
И все эти роли не должны быть реализованы в одном классе.</p><p>OOSE выделяет три разных вида объектов - интерфейсы (уже в смысле интерфейса системы во внешний мир), сущности и контроллеры.
DCI в свою очередь выделяет три других, но очень похожих видов объектов - Data, Context и Interactor.
И если OOSE допускает реализацию объекта несколькими классами, то DCI прямо требует разделение объекта на 3 (и более, на самом деле, зависит от количества ролей) этих класса в коде.</p><p>Возможно в этот момент вы подумаете "Но группа связанных классов - это же модуль".
В том-то и дело, что "классов".
Статических структур времени компиляции.
Во время выполнения же, модули инстанциируются в объекты (далее будем называть их блоками, чтобы не было путаницы).
А то, что принято называть объектами, во время выполнения - может быть как объектом, так и структурой данных в хорошем смысле этого слова.
Либо непосредственно с данными, либо со ссылками на методы.
Объект превращается в блок, состоящий из структур данных в тот момент, когда становится слишком (<mark>todo: это сколько в граммах?</mark>) большим или приобретает поведение с разных уровней абстракции и/или консёрнов (<mark>todo: перевести на русский</mark>).</p><p>Именно блоки позволяют из недообъектов-структур собирать те самые каноничные объекты, с идентичностью, поведением и инкапсулированным состоянием.
Инкапсуляция на уровне блоков достигается за счёт публикации только ограниченного интерфейса-фасада блока (либо реализации интерфейсов из других блоков) и сокрытия состояния и реализации блока.
Один блок может предоставлять несколько интерфейсов нужных ему коллабораторов и реализовывать несколько интерфейсов, определённых другими коллабораторами.
За счёт этого достигается полиморфизм на уровне блоков.</p><p>Так же как и множество объектов с собственным состоянием может быть порождено статическим конструктором класса, так и множество блоков может быть порождено статическим конструктором модуля.
И так же как и класс, может переиспользовать объекты, подменяя им состояние (см Flyweight <a href=#apx_book_gof>Design Patterns: Elements of Reusable Object-Oriented Software</a>), так и модуль может переиспользовать часть объектов (поведения) создавая композиции, на основе синглтонов поведения и датахолдеров, загужаемых из БД по ИДу.</p><p>(<mark>todo: авторская вставка - не к месту. Или сноской сделать или утащить куда-нить</mark>) Наконец, блоки надо использовать только тогда, когда решаемая проблема не ложится на объекты.
Если проблема хорошо ложится на объекты, то можно и нужно использовать их.</p><p>Вот этот подход бы стать тем самым сдвигом парадигмы, который бы породил новую парадигму, если бы какое-либо из значительных сообществ приняло эти правила и стандарты разработки.
А не наследование, полиморфизм, инкапсуляция и попытка моделировать реальный мир или антроморфизировать программы..</p><p>(<mark>todo: "мягкая" подводочка</mark>) Но как мы видим, ООП хорошо работает для проектирования крупных частей программы, а в деталях оно скатывается к процедурному программированию.
И тут на сцену выходит функциональный подход.</p></section><section class="doc-section level-2"><h3 id=_функциональное_программирование>Функциональное программирование</h3><p>Примерно в 2013-14 кодах (после пары лет работы в типовых проектах на спринге) я решил, что ООП это фикция, которая не работает и пошёл искать счастья в функциональный мир.
Три-четыре года я активно изучал и старался применять в персональных проектах чистый функциональный подход.
В котором я так же разочаровался.</p><p>Основной проблемой функционального подхода на мой взгляд является его отрицание очевидного - Эффектов.
А т.к. мы программы пишем ради Эффектов, ему приходится в своём идеальном чистом мире заводить грязный уголок для Эффектов.
Тех самых эффектов, ради которых пишется программа.
И для того чтобы уберечь свой идеальный мир от грязи эффектов, функциональному программированию приходится выстраивать забор из зубодробительных абстракций.
В итоге программы в функциональном стиле понятны только людям с очень мощным бэкграундом в дискретной математике, для которых эти зубодробительные абстракции уже на подкорке.
А таких людей очень мало.
А у нас в индустрии острая нехватка кадров.</p><p>Второе чего мне не хватало в функцональном подходе - это тех самых крупных блоков-объектов из ООП из которых состоит программа во время выполнения.
А составить программу из чистых функциональных пайплайнов не всегда получается.</p><p>Наконец, иногда "в поле", локальная изменяемая переменная позволяет выразить намерение разработчика Очевиднее, чем попытка завернуть это состояние в какую-нибудь монаду.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Возможно я просто ещё не прочитал <a href=#apx_book_func_arch>Functional Design and Architecture</a>:)
Отдельно хочу попиарить эту книгу, потому что Сашу я знаю лично и он тоже Новосибирец.
Книгу я ещё не читал, но на беглый взгляд она выглядит не хуже книг всемирно известных корифеев программирования.
Этот факт вселяет в меня надежду, что простой сибирский парень может написать книгу мирового уровня и я стану вторым таким парнем:)</p></aside><p>Но для реализации Логики нет ничего более эргономичного, чем функциональный подход.
Освобождение Логики от Эффектов делает её простой, понятной, локальной, тестируемой, более переиспользуемой и пригодной для параллельного исполнения.
А что с Эффектами - главной ценностью, которую создают программы?
Для реализации Эффектов нет ничего более эргономичного, чем процедурный подход.</p><p>(<mark>todo: расписать функциональное представление объектов - последовательность иммутабельных структур с общим идом и менеджер мутабельной ссылки на актуальное состояние</mark>)</p><p>Так мы приходим к мультипарадигменному подходу.</p></section><section class="doc-section level-2"><h3 id=_мультипарадигменное_программирование>Мультипарадигменное программирование</h3><p>Этот раздел начался с вопроса: "Какая же из этих парадигм позволяет писать эргономичный код?".
Ответ - эргономичный код позволяет писать только комбинация всех мейнстримовых парадигм.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>(<mark>todo: нужна эта автобиография?</mark>)</p><p>К идеи мультипарадигменного программирования я пришёл в 2017 году, после того как разочаровался в чисто функциональном программировании.
Тогда я этот подход называл прагматичным подходом и интуитивно решал, когда использовать каждую из парадигм.
В 2017 же году я ушёл во фриланс и за 2.5 года сделал 8 относительно небольших и очень разных коммерческих и персональных проектов с чистого листа и соотвественно в своём подходе.
Интуитивно я уже тогда писал код примерно в стиле описываемом в этой книге, но всё окончательно встало на свои места, когда я в 2020 году случайно наткнулся на DCI (и в последствии OOSE) с концепцией контекста/блока.
До этого мне не куда было приткнуть Юз Кейс - он не ложился ни в популярную трактовку ООП (не имел аналога в реальном мире), ни в ФП (имел эффекты в реальном мире).</p></aside><p>Объектно-ориентированная парадигма используется для описания структуры объектов, из которых состоят система и подсистемы, а так же потоков данных между ними.
Так же в терминах ООП прекрасно реализуются абстрактные типы данных, но они обычно берутся из библиотек, а не разрабатываются.</p><p>Функциональная парадигма используется для описания функций системы.
То есть Логики, которая интересует заказчика.</p><p>Наконец, процедурная парадигма используется для описания процедур воплащения в жизнь решений, принятых Логикой.</p><p>(<mark>todo: чёт разделение Логики и Эффектов очень напоминает CQRS - надо обдумать</mark>)</p><p>(<mark>todo: прочитать Multi-Paradigm Design for C++ - мош я тут велосипед изобретаю</mark>)</p></section></section><section class="doc-section level-1"><h2 id=_модель_системы_stub>Модель системы? (Stub)</h2><p>(<mark>todo: he hardest part of splitting a program into modules is just deciding on what the module boundaries should be. There’s no easy guidelines to follow for this, indeed a major theme of my life’s work is to try and understand what good module boundaries will look like, <a class=bare href=https://martinfowler.com/articles/refactoring-dependencies.html>https://martinfowler.com/articles/refactoring-dependencies.html</a></mark>)
Perhaps the most important part of drawing good module boundaries is paying attention to the changes you make and refactoring your code so that code that changes together is in the same or nearby modules.0
As a result I favor using this approach in smaller scopes, but larger applications need high level modules to be developed along different lines.
(#todo: This illustrates the advantage of keeping a program factored into small pieces - it allows substitution of those pieces, even if the original writer didn’t have any substitutions in mind. It enables unforeseen customization. #)</p></section><section class="doc-section level-1"><h2 id=_таблица_эффектов>Таблица эффектов</h2><p>(<mark>todo: эффекты операции - это публичное АПИ</mark>)</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Уже после того, как я написал этот раздел, мне попалось две научных статьи от немецко-израильской исследовательской группы на эту же тему:</p><div class="olist arabic"><ol class=arabic><li><a href=https://www.researchgate.net/publication/283566310_Improving_Design_Decomposition>Improving Design Decomposition</a>.</li><li><a href=https://www.researchgate.net/publication/326260296_Functional_Decomposition_for_Software_Architecture_Evolution>Functional Decomposition for Software Architecture Evolution</a>;</li></ol></div><p>По сути, они предлагают то же самое, но у них есть ряд отличительных черт:</p><div class="olist arabic"><ol class=arabic><li>Самое интересное, что я перенесу в таблицу эффектов - делить и размечать разными весами операции чтения и записи;</li><li>У них более простая таблица - строки это операции, а столбцы - это отдельные переменные состояния;</li></ol></div></aside><p>В функциональном подходе иногда рассматривают программу как функцию (<mark>todo: prooflink</mark>):</p><div class=listing-block><pre class="rouge highlight"><code>f(e) = e&#39;</code></pre></div><p>, где <code>e</code> - это окружение программы (память, диск, экран, сеть), а <code>e'</code> - изменённое окружение после исполнения программы.
Давайте выполним два небольших преобразования этой функции.
Во-первых, обозначим то, что программа может реагировать на множество различных сигналов:</p><div class=listing-block><pre class="rouge highlight"><code>f(e) = f&#39;(s(e), e)

s(e) = s

f&#39;(s, e) = e&#39;</code></pre></div><p>, где <code>s(e)</code> - функция извлекающая сигнал <code>s</code> из окружения <code>e</code>, а <code>f'</code> - функция изменяющая окружение <code>e</code> в ответ на сигнал <code>s</code>.</p><p>Во-вторых, Логику и Эффекты и выделим их в отдельные функции:</p><div class=listing-block><pre class="rouge highlight"><code>f&#39;(s, e) = f&#39;&#39; x g

f&#39;&#39;(s, e) = (e, [de]) // Формула 1

g(e, [de]) = e&#39; // Формула 2</code></pre></div><p>, где <code>f''</code> - функция преобразующая входные сигнал и окружение в вектор Эффектов (и неизменное входное окружение для передачи в <code>g</code>), а <code>g</code> - функция применяющая Эффекты к окружению.</p><p>Есть три способа определения функции (<mark>todo: пруфлинк</mark>):</p><div class=ulist><ul><li>Аналитический</li><li>Графический</li><li>Табличный</li></ul></div><p>Как описать программу графическим способом я вообще представить не могу, а аналитический способ (исходный код по сути) слишком конкретный для модели.
Поэтому давайте в качестве модели программы возьмём таблицу эффектов:</p><figure class="table-block ergo-table"><figcaption>Table 1. Таблица эффектов приложения</figcaption><table class="frame-all grid-all stretch"><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="halign-left valign-top">Сигнал</th><th class="halign-left valign-top">Окружение</th><th class="halign-left valign-top">Предусловие</th><th class="halign-left valign-top">Решение</th><th class="halign-left valign-top">Эффект</th></tr></thead><tbody><tr><td class="halign-left valign-top" rowspan=4><p>Сигнал 1</p><div class=ulist><ul><li>Параметр 1</li><li>Параметр 2</li></ul></div></td><td class="halign-left valign-top" rowspan=2>Окружение 1.1</td><td class="halign-left valign-top" rowspan=2>Предусловие 1.1</td><td class="halign-left valign-top" rowspan=2>Решение 1.1</td><td class="halign-left valign-top">Эффект 1.1.1</td></tr><tr><td class="halign-left valign-top">Эффект 1.1.2</td></tr><tr><td class="halign-left valign-top" rowspan=2>Окружение 1.2</td><td class="halign-left valign-top" rowspan=2>Предусловие 1.2</td><td class="halign-left valign-top" rowspan=2>Решение 1.2</td><td class="halign-left valign-top">Эффект 1.2.1</td></tr><tr><td class="halign-left valign-top">Эффект 1.2.2</td></tr><tr><td class="halign-left valign-top" rowspan=4>Сигнал 2</td><td class="halign-left valign-top" rowspan=2>Окружение 2.1</td><td class="halign-left valign-top" rowspan=2>Предусловие 2.1</td><td class="halign-left valign-top" rowspan=2>Решение 2.1</td><td class="halign-left valign-top">Эффект 2.1.1</td></tr><tr><td class="halign-left valign-top">Эффект 2.1.2</td></tr><tr><td class="halign-left valign-top" rowspan=2>Окружение 2.2</td><td class="halign-left valign-top" rowspan=2>Предусловие 2.2</td><td class="halign-left valign-top" rowspan=2>Решение 2.2</td><td class="halign-left valign-top">Эффект 2.2.1</td></tr><tr><td class="halign-left valign-top">Эффект 2.2.2</td></tr></tbody></table></figure><p>В этой таблице:</p><div class=dlist><dl><dt>Сигнал</dt><dd>Какое-то событие в окружении.
В самом общем случае это событие оборудования - получения пакета по сети, нажатие на кнопку, истечение таймаута.
Но на уровне приложения это превращается уже в событие платформы - поступление хттп-запроса по такому-то урлу, генерация такого-то события у такого-то компонента пользовательского интерфейса.
У сигнала могут быть связанные с ним параметры.
Сигнал соотвествует переменной s в Формуле 1</dd><dt>Окружение</dt><dd>Собственно окружение программы.
В самом общем случае - состояние памяти и дисков всех компьютеров, на которых запущена система.
На уровне приложения это уже может быть значение глобальной переменной или содержание таблицы в БД.
Окружение соотвествует переменной e в Формуле 1</dd><dt>Предусловие</dt><dd>Описание значений параметров сигнала и окружения, необходимых для того чтобы решение было принято.
Например - в таблице Х есть запись удовлетворяющая условиям Y, текущее время находится в интервале с 08:00 до 20:00.
Предусловие соотвествует функции <code>f''</code> в Формуле 1</dd><dt>Решение</dt><dd>Высокоуровневое описание решения.
Например - удалить объект X, перевести объект Y в состояние Z, отправить сообщение K.
Решение соответствует переменной <code>[de]</code> в Формуле 1</dd><dt>Эффект</dt><dd>Низкоуровневое описание изменений в окружении в следствии реализации решения.
Например - объекту X поле Y установить в значение Z, отправить http-запрос по такому-то урлу.
Эффект соотвествует функции <code>g</code> в Формуле 2</dd></dl></div><p>Этапы обработки сигнала образуют первую ось модели приложения в эргономичном подходе. (<mark>todo: оси в каком пространстве? надо или другую метафору или эту до ума довести</mark>)</p><p>Для краткого анализа или же для анализа через чур запутанного приложения, колонки "Окружение", "Предусловие" и "Решение" можно опустить.</p><aside class=sidebar><h6 class=block-title>Иллюстрационные приложения</h6><p>Иллюстрации в книге приводятся на основе нескольких реальных и вымышленных програм, подробно расписанных в приложении Примеры.
Непосредственно в тексте же приводится лишь краткое представление програм по мере необходимости.
И сейчас подошло время представить первую из иллюстрационных программ - Q5.</p><p>Q5 это небольшое Android-приложение предназначенное для учёта расходов. Основные функции - внесение расходов вручуню, парсинг смс и системных нотификаций для внесения расходов в автоматизированном режиме, отображение расходов за период и экспорт расходов за период в csv формате.</p></aside><p>Построим таблицу эффектов для группы сигналов Q5 связанной с автоматическим сохранением расходов.</p><figure class="table-block ergo-table"><figcaption>Table 2. Таблица эффектов автоматизированного сохранения расходов Q5</figcaption><table class="frame-all grid-all stretch"><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="halign-left valign-top">Сигнал</th><th class="halign-left valign-top">Окружение</th><th class="halign-left valign-top">Предусловие</th><th class="halign-left valign-top">Решение</th><th class="halign-left valign-top">Эффект</th></tr></thead><tbody><tr><td class="halign-left valign-top"><p>Опубликована новая нотификация</p><div class=ulist><ul><li>text - Текст нотификации</li></ul></div></td><td class="halign-left valign-top" rowspan=2><div class=ulist><ul><li>pattern list - Список шаблонов "чеков"</li><li>place2category - Словарь соответствия "место" → "категория"</li></ul></div></td><td class="halign-left valign-top" rowspan=2>text совпал с одним из шаблонов</td><td class="halign-left valign-top" rowspan=2>Предложить пользователю сохранить транзакцию с определёнными суммой и категорией</td><td class="halign-left valign-top" rowspan=2><p>По средствам NotificationManager отобразить нотификацию пользователю.</p><p>К нотификации привязано два действия - сохранить расход как есть и открыть форму редактирования этого расхода</p><p>Также нотификация содержит два параметра - check - распознаный чек (текст, сумма, место совершения) и trx - Информация о расходе</p></td></tr><tr><td class="halign-left valign-top">Пришло новое СМС сообщение</td></tr><tr><td class="halign-left valign-top"><p>Пользователь подтвердил сохранение определённого (<mark>todo: неоднозначность</mark>) расхода</p><div class=ulist><ul><li>trx</li></ul></div></td><td class="halign-left valign-top">transactions - Таблица расходов</td><td class="halign-left valign-top"></td><td class="halign-left valign-top">Сохранить расход</td><td class="halign-left valign-top">Добавить в таблицу расходов запись для trx</td></tr><tr><td class="halign-left valign-top"><p>Пользователь решил внести правки в определённый расход</p><div class=ulist><ul><li>trx</li></ul></div></td><td class="halign-left valign-top"></td><td class="halign-left valign-top"></td><td class="halign-left valign-top">Отобразить форму редактирования расхода</td><td class="halign-left valign-top">Сгенерировать интент открытия EnterSumActivity предзаполненную данными из trx.</td></tr><tr><td class="halign-left valign-top" rowspan=2><p>Пользователь нажал кнопку "Сохранить расход"</p><div class=ulist><ul><li>trx</li></ul></div></td><td class="halign-left valign-top" rowspan=2><div class=ulist><ul><li>transactions</li><li>place2category</li></ul></div></td><td class="halign-left valign-top"></td><td class="halign-left valign-top">Сохранить расход</td><td class="halign-left valign-top">Добавить в таблицу расходов запись для trx</td></tr><tr><td class="halign-left valign-top">Место совершения расхода определено</td><td class="halign-left valign-top">Обновить/дополнить статистику по связи мест с категориями</td><td class="halign-left valign-top">place2category[check.place] = trx.category</td></tr></tbody></table></figure><p>(<mark>todo: При том эффектом в этой таблицы может быть "Сгенерировать сигнал Х".</mark>)
(<mark>todo: как сюда вписать "cross-cutting concerns?"</mark>)
(<mark>todo: циклы</mark>)
(<mark>todo: отложенные эффекты - эффективные лямбды переданные в платформу, аля PendingIntent</mark>)</p><aside class=sidebar><h6 class=block-title>Оценка на базе таблицы эффектов.</h6><p>На данный момент это только предположение, но кажется, что на базе таблицы эффектов приложения можно делать оценки трудозатрат на выполнение задачи.</p><p>Во-первых, построение таблицы для текущей версии кода даст хорошее представление об устройстве кода.</p><p>Во-вторых, станет более-менее понятен список микромодификаций кода, необходимых для выполнения задачи.</p></aside><p>Важно заметить, что приведённые сигналы связаны друг с другом - за сигналом "Опубликована новая нотификация" и "Пришло новое СМС сообщение" часто следует сигнал "Подтверждение сохранения определённого расхода" или "Открыть форму редактирования расхода".
Перед сигналом "Открыть форму редактирования расхода" всегда имеет место либо один из выше перечисленных сигналов, либо не приведённый здесь сигнал "Открыть форму вывода расходов за период".
За сигналом "Открыть форму редактирования расхода" обычно следует сигнал "Сохранение расхода".</p><p>Если задуматься все эти Сигналы и Эффекты предназначены для решения одной задачи пользователя - внести информацию о расходе.
Одна задача пользователя определяет один Юз Кейс приложения.
При том у одного Юз Кейса может быть несколько вариантов, в данном случае - автоматизированный и ручной ввод информации о расходе.</p><p>Юз Кейсы образуют вторую ось в пространстве модели приложения эргономичного подхода. (<mark>todo: стиль</mark>)
В эргономичном подходе, программа рассматривается как набор Юз Кейсов, каждый из которых явлется функцией отображающей набор Сигналов в набор Эффектов предназначенных для решения одной задачи пользователя.</p><section class="doc-section level-2"><h3 id=_принципы_проектирования_системы>Принципы проектирования системы</h3><p>(<mark>todo: <a class=bare href=https://www.ics.uci.edu/~cs223/papers/cidr07p15.pdf>https://www.ics.uci.edu/~cs223/papers/cidr07p15.pdf</a> - entity=component?</mark>)</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>ТЛ, ДР</p><p>Я на самом деле нифига не открываю америку - я, кажись, начал догонять то о чём безуспешно с 90ых годов толдычат Фаулер, Мартин, Еванс, Вест, Якобснон, Коплейн, MVC-чувак-с-непроизносмимым-именем, Кэй и прочая ОО-компания.
Кажись кроме прокляться монады (<a class=bare href=https://www.infoq.com/presentations/functional-pros-cons/>https://www.infoq.com/presentations/functional-pros-cons/</a>, 26:21) есть ещё и проклятье ООП/ООД:)</p><p>Глобально система строится из компонентов-объектов (которые состоят из классов и их экземпляров) инкапсулирующих состояние (таблицы в БД, чаще всего) по принципам традиционного ООД.
Состояние нарезается на кусочки по принципам агрегатов из ДДД.
Внутри каждый из компонент делится на три части - сложная логика (энтити, доменные сервисы) и общий пайплайн (юз кейс/аппсервис) в функциональном стиле и предельно простой ввод-вывод (репозы, гейтвеи, контроллеры) в процедурном (стандартном в наши дни) стиле.
Каждая из частей оформлется в отдельный грэдл/мавен-модуль с внешними зависимостями, а все классы одного компонента помещаются в один пакет этих модулей.</p><p>Это концепция очень переклиается с функциональной архитектурй.
Хаскель я пока не изучил, и чего-то подобного в МЛях не помню, но вот экторная модель Эрланга и Кложуры - как раз про это - у них экторы выступают компонентами/объектами из этой главы.</p></aside><section class="doc-section level-3"><h4 id=_цели>Цели</h4><p>Здесь я буду использовать следующие определения:</p><div class="olist arabic"><ol class=arabic><li>архитектура - логическое устройство системы, оторванное от средства реализации.</li><li>дизайн - реализация архитектуры с использованием конкретных средств (котлин, классы, грэдл и т.п.)</li></ol></div><p>Для любой проблемы (набора бизнес-требований) можно спроектировать множество архитектур, обладающих разными характеристиками.
И любую из этих архитектур можно также реализовать множеством дизайнов, также обладающих разными характеристиками.</p><p>Так вот, достижение следующих характеристик дизайна <strong>не</strong> является целью описываемых принципов:</p><div class="olist arabic"><ol class=arabic><li>Возможность 100% покрытия юнит тестами</li><li>Производительность.
Но на практике следование описываемым принципам даёт на несколько порядков более быстрый дизайн, чем дизайн полученный по средствам безпринципного программирования, за счёт подсвечивания и последующей оптимизации ввода-вывода, который занимает львиную долю времени обработки события/запроса.</li><li>Масштабируемость.
Тут уже теоретически следование описываемым принципам (маленькие агрегаты и интерфейсы компонент, см. ниже) даёт существенно более масштабируемую систему, чем безпринципнре программирование за счёт минимизации конкурентных модификаций глобального состояния и возможности быстрого выделения и деплоя компонент в отдельные сервисы, при необходимости.</li><li>Привычность для глаза среднестатистического ява-разработчика - чтобы можно было нанять кого угодно с рынка, и он сразу бы начал писать код, проходящий ревью с первой-второй попытки.</li><li>Максимальная скорость реализации одной отдельно взятой фичи.</li></ol></div><p>А вот какие цели преследуются:
. Минимизация зависимостей в коде
. Предельно простое описание контракта событие (рест-запрос) → эффекты (запись в бд, отправка сообщений)
. Подсвечивание связей через глобальное состояние между разными частями кода
. Простота покрытия надёжными (без моков) юнит-тестами бизнес-логики</p><p>Благодаря этому минимизируется количество регрессий при рефакторинге и реализации новых фич.
Благодаря чему у команды исчезает страх перед рефакторингом из-за боязни что-то сломать.
Благодаря чему общий дизайн постоянно улучшается и адаптируется к изменениям в требованиях.</p><p>Так же благодаря п. 4 (+ фокус на интеграционных тестах) минимизируется количество изменений, требуемых при рефакторинге (в идеальном случае они инкапсулируются в одном компоненте), что убирает другой перед рефакторингом из-за боязни застрять на изменении всей системы.
Благодаря чему, опять же, общий дизайн постоянно улучшается и адаптируется к изменениям в требованиях.</p><p>Благодаря качественному дизайну, в долгосрочной перспективе, средняя скорость становится превышает среднюю скорость разработки с "экономией" на дизайне.</p><p>Путь в этот чудесный мир, хорошего дизайна, надёжных тестов и быстрой и приятной разработки лежит через настоящие объекты/компоненты.</p></section><section class="doc-section level-3"><h4 id=_ооп_оод_и_компоненты>ООП, ООД и компоненты</h4><p>Я утверждаю, что ООП - не смогло выполнить общения миру о более поддерживаемом коде.
В результате ООП захватило мир чисто номинально и повсеместно выродилось в процедурное программирование с элементами полиморфизма со всеми его проблемами.
С этим тезисом согласен и один из корифеев ОО Дэвид Вест: <a href=#apx_talk_oop_is_dead>OOP is Dead! Long Live OODD!</a>.
Сейчас 90% классов в индустрии это либо ваще примитивные структуры данных (энтити, дто), либо синтаксический сахар над старыми добрыми структурами с функциональными указателями из С (контроллеры, сервисы).
При том, что именно реализацию лучше писать в функциональном стиле, т.к. в результате получается код, по которому проще понять его контракт и который проще протестировать и, следовательно, проще поддерживать.</p><p>А вот объектно-ориентированные дизайн и анализ же - это совсем другая история.
Напомню, что изначально объект - это состояние, поведение и идентичность.
И если объектно-ориентированный подход применять к более крупным чем классы блокам - компонентам - то он внезапно из теоретических лозунгов превращается в практический инструмент.
В моей концепции компонент физически представлен набором классов, находящихся в одном пакете, но, при необходимости, разбитых на несколько грэдл-модулей (в зависимости от нужных им зависимостей, прошу прощения за каламбур:)).
А логически, компонент - объект, т.е. обладает состоянием и поведением.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Чтобы не вносить путаницу, пусть объектом будет набор байт в памяти в рантайме, а компонентом - настоящий объект (с состоянием и поведением), являющийся единицей проектирования.
Плюс у слова "объект", у меня по крайней мере, есть нежелательные коннотации - антропоромфный взгляд на объекты Веста и Бугаенко и объекты как средство моделирования реального мира Буча.
Я думаю это ошибочные взгляды, влекущие аналитический паралич или наоборот создание переусложнённого дизайна.
Объект - средство инкапсуляции состояния.
Инкапсуляция состояния - средство управления сложностью графа зависимостей программы.
Ограниченность и явность зависимостей в конечном итоге упрощает понимание к каким изменениям в контракте приведут те или иные изменения в коде, что в свою очередь уменьшает количество регрессий.</p></aside><p>Но возникает вопрос - что такое состояние и поведение у компонента (пакета с множеством классов в разных модулях)?
Для ответа нам понадобятся агрегаты из Domain Driven Design (DDD) и Application Service/Workflows/Pipelines/Use Cases из DDD/Domain Modeling Made Functional/ЭП.</p></section><section class="doc-section level-3"><h4 id=_агрегаты>Агрегаты</h4><p>Агрегат из DDD - это граф объектов (JPA Entity) с корневым объектом (корень агрегата), который является единицей персистанса, т.е. этот граф загружается целиком (без ленивой загрузки) и сохраняется целиком.
DDD накладывает ряд ограничений на агрегаты:</p><div class="olist arabic"><ol class=arabic><li>Как я уже писал - агрегаты загружаются и сохраняются целиком;</li><li>это влечёт рекомендацию держать агрегаты маленькими;</li><li>репозитории пишутся только для агрегатов;</li><li>на агрегат можно ссылаться только через корень;</li><li>ссылки между агрегатами делаются только через идентификаторы корней;</li><li>в одной транзакции можно менять только один агрегат (создавать можно сколько угодно);</li><li>отсюда рекомендация проектировать агрегаты исходя из юз кейсов, а не модели данных;</li></ol></div><p>И уже моё ограничение - в БД изменения вносятся только через репозитории.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>При этом JPA (самая распространная технология для работы с БД на платформе Java) это ограничение технически обеспечить невозможно из-за стремления JPA создать видимость работы с изменяемыми объектами в памяти.
Возможно package private сеттеры помогут, но надо на практике проверять.
А вот Ebeans, например, позволяет сделать как надо.</p></aside></section><section class="doc-section level-3"><h4 id=_другие_виды_состояний_компонента>Другие виды состояний компонента</h4><p>Агрегат - это наиболее распространённый вид состояния в информационных системах, но вообще состояние - это любая внешняя система</p><div class="olist arabic"><ol class=arabic><li>все виды баз данных;</li><li>файловая система;</li><li>пуш-сервисы;</li><li>любые внешние информационные системы - Jira, Jenkins, Google Docs;</li><li>Email;</li></ol></div></section><section class="doc-section level-3"><h4 id=_workflows>Workflows</h4><p>См. <a href=#_модель_юз_кейса>Модель Юз Кейса</a></p><p>Workflow верхнеуровнево описывает одну операцию системы и отвечает за две функции:</p><div class="olist arabic"><ol class=arabic><li>Управление потоком данных;</li><li>предельное простое описание в одном месте глобального состояния необходимого для выполнения операции и эффектов выполнения операции.</li></ol></div><p>Реализуются они в функциональном стиле, при желании без монад - в workflow описывается сэндвич из максимально простого (без условной логики) ввода-вывода и сложной логики.</p></section><section class="doc-section level-3"><h4 id=_и_снова_компоненты>И снова компоненты</h4><p>Так вот состоянием компонента является изолированный кусочек состояния внешней системы (таблиц агрегатов, например), который должен меняться атомарно и изменение которого компонент инкапсулирует за поведением - workflow-ами.
В оригинале у объекта есть ещё идентичность, но она в этой концепции не особо нужна, т.к. большинство компонент в рантайме будет в единственном экземпляре.
Но если надо несколько экземпляров, то идентичность компонента привязывается к идентичности объекта фасада.
Публичным интерфейсом компонента выступает класс-фасад, который либо сразу содержит workflows, либо просто делегирует их выделенным для них классам.
Аргументы и результат метода фасада должны быть экземплярами DTO-классов.
Сущности, агрегаты и репозитории являются приватными членами - не уверен что это удастся реализовать на практике только средствами Java/Gralde/Maven.
Но ArchUnit, надеюсь, сможет помочь.</p><p>Продолжая аналогию с классами/объектами:
. Класс в ООП = пакет в ООД
. Объект в ранатайме в ООП = граф объектов в рантайме с корнем в виде фасада в ООД
. Конструктор объекта = специальный класс (Spring-конфигурация), который на вход получает конфиг и набор других компонент (в виде фасадов), строит граф объектов компонента и возвращает объект-фасад
. Метод = метод фасада
. Поле = некоторое глобальное изменяемое состояние - просто изменяемое поле класса/объекта, таблица в БД, таблица в БД за РЕСТ АПИ внешней системы и т.д.</p><p>Тут ещё детально не продумывал, но такое ощущение, что все принципы ООП - ацикличный граф зависимостей, high cohesion/low coupling, SOLID, CQS и контракты Мейера и т.д. - прекрасно и, главное понятно, работают на уровне компонент.
За исключением всего, что касается наследования, понятное дело.
Но оно в любом случае должно уйти на покой:)
И тут Вест снова со мной согласен, см. <a href=#apx_talk_oop_is_dead>OOP is Dead! Long Live OODD!</a></p><p>Из системы компоненты выставляются по средствам адаптеров - рест контроллеры, либо какие-то другие штуки, которые знают как делать ввод-вывод пригодный для использования конечным пользователем или внешней системой.</p><p>Если интерфейс компонента сразу сделать асинхронным, то его можно тривиальной манипуляцией вынести в отдельный сервис при деплое.
Это уже будет экторная модель дефакто:)</p><p>Надо подумать, но вроде вариант инкапсуляции нескольких агрегатов в одном компоненте допустим.</p></section><section class="doc-section level-3"><h4 id=_gradlemaven_модули>Gradle/Maven-модули</h4><p>Вообще я сторонник <a href=https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html>кричащей архитектуры</a>.
Поэтому надо стремиться к тому, чтобы компоненты соответствовали модулям 1 в 1.
Но из-за особенностей систем сборки на Java (нельзя прописать Gradle-зависимость конкретному классу), компонент разбивается как минимум на два модуля - домен и инфраструктура.</p><p>В домене живут энтити, агрегаты, интерфейсы репозиториев и других гейтвеев, workflows и всё что надо для их работы.
Сюда же можно поместить доменные сервисы, но они должны быть чистыми - без ввод-вывода.
И эти модули не зависят ни от чего, кроме модулей других доменов и небольших, неинвазивных локальных библиотек.</p><p>В инфраструктуре живут реализации репозиториев и гейтвеев, контроллеры и конструктор компонента (Spring-конфигурация, например).
И они зависят от всех фреймворков вроде Spring.
Конфигурация модуля публикует (в Spring-контекст, например) только контроллеры и юз кейсы, репозитори репозы и гейтвеи создаются и инжектируются в юз кейсы приватно и снаружи недоступны.</p><p>В принципе можно вообще обойтись двумя модулями - app и domain, и их внутри уже на пакеты нарезать на компоненты.
Но т.к. я сторонник кричащей архитектуры и модули это намного более прочные границы, чем пакеты, я всё-таки за то чтобы доменные части компонент выделять в отдельные модули.</p></section><section class="doc-section level-3"><h4 id=_подсистемы>Подсистемы</h4><p>В целом систему можно бить на подсистемы, состоящие из логически и физически сильно связанных компонент.</p></section></section></section><section class="doc-section level-1"><h2 id=_модель_юз_кейса>Модель Юз Кейса</h2><p>(<mark>todo: сделать подводку, что все беды от смешения логики и эффетов. Её видимо надо делать во введении и привести пример тиндера</mark>)</p><p>Самое важное, что необходимо сделать для Очевидизации (<mark>todo: перевести на русский</mark>) связей в приложении - это разделить нетривиальную логику и эффекты.
Для достижения этой цели, эргономичный подход рассматривает программу как набор юз кейсов, каждый из которых состоит из следующих частей:</p><div class=ulist><ul><li>Платформа - базовый код обеспечивающий общение с внешним миром и универсальные сервисы;</li><li>Порты - обработчики событий во внешнем, вызываемые платформой;</li><li>Адаптеры - точки "выхода" из приложения, в которых сконцентирированы эффекты;</li><li>Логика - "мозг" приложения, в котором содержится вся сложная логика;</li><li>Юз кейс - "обединятор" (<mark>todo: перевести на русский</mark>) приложения, который отвечает за организацию потока данных между адаптерами и логикой.</li></ul></div><p><img src=/book/images/aa-use-case.JPG alt="Устройство юз кейса"></p><section class="doc-section level-2"><h3 id=_платформа>Платформа</h3><p>В платформу я включаю всё, что не является непосредственной функцией приложения - начиная от железа, продолжая осью, библиотеками ввода-вывода, мидлварем, фреймворками и заканчивая вашим инфраструктурным кодом. Платформа отвечает за взаимодействие со внешним миром и у этого взаимодействия, по сути есть только два варианта - понять что наступило какое-то событие (пришёл пакет по сети, пользователь кликнул мышью, истёк таймаут) и обменяться массивами байт с каким-то железом.</p><p>Если в вашем инфраструктуром коде есть какая-то логика, то ещё раз подумайте, там ли ей место.
Если место всё-таки там, то инфраструктур можно рассматривать как отдельную программу так же состоящую из юз кейсов и при менять к ней те же принципы, что и к верхне-уровневой программе, которая решает проблемы конечных пользователей.</p></section><section class="doc-section level-2"><h3 id=_порты>Порты</h3><p>Порт является точкой входа в функцию системы.
Его задача - принять вызов, сконвертировать входные данные и создать объекта юз кейса, передать в него управление и вернуть результат, снова сконвертировав его.
Конвертация входов/выходов и создание объектов юз кейсов опциональны - конвертацией может заниматься платформа, а юз кейс может быть инжектирован в порт, если у него нет состояния.
В коде портов не должно быть никакой логики - ифов, форов, вызовов приватных методов.
Порты инкапсулируют в себе логику регистрации методов в платформе и могут иметь аннотации специфичные для платформы и принимать на вход объекты классов, определённых в платформе.
Но обращение к методам платформы настоятельно не рекомендуется, а обращение к методам платформы, которые ведут к изменению состояния внешней среды запрещено.</p><div class=example-block><div class=example><p>Далее для простоты я буду называть событиями все вызовы из платформы методов портов.
Так, в случае веб приложения вызов метода, назначенного на обработку запроса определённого URL будет событием "Поступление HTTP-запроса XXX", а вызов метода назначенного на исполнение с определённой периодичностью или в определённый момент времени будет событием "Срабатывание расписания (таймера) ХХХ".
События асинхронного ввода-вывода и события тулкита пользовательского интерфейса укладываются в этот термин естественным образом.</p></div></div><p>В вырожденных случаях (например CRUD операция), я не вижу особого криминала, в том, чтобы смёржить порт и юзкейс и из порта обратиться непосредственно в адаптер и вернуть результат.
При условии, что соблюдается запрет на логику в порте (включая логику выраженную декларативно - читай транзакции).
Так же не стоит в одном классе смешивать выделенные порты и порты-юзкейсы.</p><p>Порт может вызвать только один юз кейс.
Если вам надо вызвать два юз кейса, значит у вас есть составной юз кейс.</p><p>Зачастую у одного нетривиального юз кейса может быть несколько портов, которые переводят управление на разные этапы юз кейса.
Может быть и наоборот, несколько портов вызывают один и тот же юз кейс.
В этом случае, желательно, объединять их в одном классе.</p><p>(<mark>todo: обобщить на случай юз кейсов подсистем, вызываемых из юз кейсов первичной системы</mark>)</p></section><section class="doc-section level-2"><h3 id=_адаптеры>Адаптеры</h3><p>Адаптеры делают программу живой для внешнего наблюдателя.
Сделать программу без адаптеров можно, но это будет чёрная дыра, которая просто всасывает ресурсы и ничего не выдаёт взамен.</p><p>Главной задачей адаптеров является исполнение Эффектов.
Поэтому это единственные компоненты, которым разрешено обращаться к Платформе.
Но как я писал ранее, разрешение на исполнение эффектов исключает сложную логику (<mark>todo: стиль</mark>)(<mark>todo: привести критерии определения сложности логики</mark>).</p><p>Именно в адаптерах берёт своё начало запрет на сложную логику, который транзитивно распространяется на юз кейсы и порты.
Дело в том, что уверенность при внесении изменений в сложную логику требует набора надёжных тестов.
А все эти компоненты транзитивно зависят от платформы и ввода-вывода, которые сложно привести к пред определённому состоянию и которые работают на порядки медленнее чистых функций.
Создать набор исчерпывающих тестов в таких условиях наверное возможно, теоретически, но на практике я ни разу такого не видел.</p><p>Что я часто видел на практике, так это замокивание ввода-вывода, но я считаю моки плохой практикой.
В этом случае ваши тесты завязываются на реализацию тестируемого кода - они начинают зависеть от того, что и в каком порядке он вызывает, и требуют обработки напильником после каждого рефакторинга.
Плюс тесты с использованием моков совершенно ничего не говорят о работоспособности вашего кода в бою.
Это приводит к тому, что либо эта логика не покрыта тестами которым можно доверять и её страшно менять, либо любое изменение этой логики требует существенно больших усилий на исправление тестов, которые сложно, скучно и не приятно делать.</p><p>Если же порты, юз кейсы и адаптеры простые, то их достаточно покрыть минимальным набором интеграционных и приёмочных тестов, для того чтобы быть уверенным в том, что система работает.</p><p>Но бывает так, что атомарная с точки зрения юз кейса операция требует логики. В этом случае эта операция является юз кейсом более низкоуровневой подсистемы, которая должна быть выявлена, названа, ограничена и оформлена в соответствии с правилами эргономичного подхода.</p></section><section class="doc-section level-2"><h3 id=_логика>Логика</h3><p>Логика. Она же предметная область, она же домен, она же Бизнес-Логика, она же бизнес-правила, она же домен.
Вот здесь уже нет никаких ограничений на конструкции управления - можно оторваться за все лишения в остальных компонентах.
Но тут есть другое ограничение - логика должна быть чистой в функциональном смысле, то есть не иметь наблюдаемых сайд эффектов.</p><p>Логика не должна быть реализована в идиоматичном функциональном стиле - весь код в функциях, без переменных, только с неизменяемыми структурами данных, с монадами и их интерпретаторами, трнасдьсерами, зипперами и т.д.
Более того, я против того, чтобы все эти абстрактные термины фигурировали в коде.
Это детали реализации и они снижают отношение сигнал/шум и путают неинициированных, коих пока что большинство.
Поэтому если любите классы и объекты - пожалуйста, императивные форы и ифы - я не против, изменяемые локальные переменные и массивы ради эффективности - я только за.
Даже исключения и try-catch можно, но я бы хорошенько подумал, как обойтись без них.
Ну и да логгирование тоже можно, при условии, что оно не является функцией вашей системы, значимой для конечного пользователя.
Вобщем, при реализации логики надо следовать двум правилам:</p><div class="olist arabic"><ol class=arabic><li>каждая функция или метод для одних и тех же параметров должна всегда возвращать одно и то же значение.</li><li>функции и методы не должны менять глобальное состояние в ходе своей работы.
Тут не много сложнее, поэтому поясню.
Результат работы Логики должен быть целиком заключён в значении возвращаемом вызванной функции.
Никаких записей на диск (по крайней мере значимых для пользователя и/или влияющих на дальнейшее функционирование системы), ни каких отправок пакетов по сети, никаких отображений чего либо на экране, никаких воспроизведений звуков, ни каких присваиваний в глобальные переменные, никакого вывода в консоль.
Ничего что можно заметить, помимо результата вызова функции.</li></ol></div><p>Это ограничение основано на той же мотивации - сложная логика должна быть исчерпывающе покрыта тестами.
Ввод-вывод исчерпывающе покрыть тестами сложно, замокать его и сложно и бессмысленно, поэтому единственный вариант - исключить его из кода требующего исчерпывающего покрытия тестами.</p><p>Так же хочу отметить, что фигура изображающая логику на иллюстрации эргономичного юз кейса, не просто так больше по размеру всех прочих компонент и имеет самые толстые границы.
В идеальной реализации эргономичного подхода именно в логике содержится большая часть кода, и защите логике от внешней среды уделяется особое внимание.</p><p>Технически, логику следует помещать либо в сущности предметной области, либо в DCI роли, в зависимости от контекста.</p></section><section class="doc-section level-2"><h3 id=_юз_кейсы>Юз кейсы</h3><p>Главной задачей кода реализации юз кейса явлется предельно ясное, декларативное описание юз кейса с точки зрения пользователя, а так же входных данных юз кейса и видимых эффектов, к которым приводит его выполнение.
В идеале должно быть как в старых добрых книгах по XP и DDD - вы показываете код юзкейса заказчику и он его понимает в общих чертах.
Для того чтобы код юз кейса был максимально приближен к языку пользователя, он не должен содержать низкоуровневых деталей и сложной логики.</p><p>С технической же точки зрения, юз кейс является центральным связующим звеном между Портами, Адаптерами и Логикой.
Юз кейс определяет верхнеуровневую структуру потоков управления и данных.</p><p>Юз кейс может быть простым и много шаговым.
Юз кейс является простым, если его цель может быть достигнута в результате обработки одного события.
Для этого необходимо чтобы все требуемые данные были доступны в момент обработки этого события и чтобы все эффекты могли быть выполнены в процессе обработки.
Юз кейс является много шаговым, если для достижения цели юз кейса требуется факт возникновения нескольких событий или части входных данных становятся доступны в разные моменты времени или эффекты могут быть выполнены в разные моменты времени</p><p>Технически, юз кейс может быть представлен объектом без состояния, объектом с состоянием только в памяти, и объектом с состоянием во внешнем хранилище.</p><p>Первый тип наиболее простой и распространенный и подходит в случаях, когда всё состояние юз кейса хранится в объектах предметной области.
В этом случае, единственный объект юз кейса создаётся платформой или приложением и инжектируется в порт.
Затем порт может либо самостоятельно получить объекты предметной области и передать их в юз кейс, либо передать в юз кейс идентификаторы этих объектов (которые содержатся в событиях).
Какой вариант лучше выбрать, зависит от конкретного случая.</p><p>Если же юз кейсу требуется какое-то состояние, которое не укладывается естественным образом в модель предметной области (<mark>todo: например?</mark>), то необходимо создать репозиторий юз кейсов, к которому будет обращаться порт, для получения объекта юз кейса.
Репозиторий может быть как ин-мемори, так и персистентный.
Ин-мемори вариант проще и быстрее, но персистентый позволяет юз кейсам переживать шатдауны и работать в много-нодовой среде.
В случае персистентного юз кейса, можно состояние юз кейса выделить в отдельный объект и сохранять только его.
Наконец, объекты юз кейсов с состоянием должны быть синхронизированы должным образом.</p><p>Несколько тривиальных одно шаговых юз кейсов можно группировать в один класс (без приватных методов).
Составной же юз кейс, должен целиком содержаться в одном отдельном классе и быть единственным содержимым этого класса.
Допустимо, чтобы несколько разных портов вызывали один и тот же юз кейс.</p><p>Я настоятельно рекомендую не использовать в юз кейсах какие-либо управляющие конструкции (<mark>todo: уточнить термин</mark>) за исключеним ROP-конструкций (конструкции вида <code>if (error) return ErrorData</code>) и условий отражающих описание юз кейса на естественном языке.
В юз кейсах недопустимо использование блоков с уровнем вложенности более двух и вызов приватных методов (<mark>todo: стиль</mark>).
Если в вашем описании юз кейса на естественном языке есть уровень вложенности больше двух - пересмотрите его.</p><p>(<mark>todo: изучить возможность использования корутин для описания много шаговых юз кейсов одним методом</mark>)</p><p>(<mark>todo: ROP вместо исключений отделяет ошибки предметной области от ошибок программирования</mark>)</p><section class="doc-section level-3"><h4 id=_взаимодействующие_с_гуём_диалог_подтверждения_операции>Взаимодействующие с гуём (диалог подтверждения операции)</h4><p>To do</p></section><section class="doc-section level-3"><h4 id=_дополнительные_эффекты_применения_модели_юз_кейса>Дополнительные эффекты применения модели юз кейса</h4><section class="doc-section level-4"><h5 id=_производительность>Производительность</h5><p>Одним из приятных эффектов отделения логики от Эффектов (прощу прощения за каламбур:) ) является натурально более производительный код.
Это обусловено двумя причинами.
Во-первых, выделяя Эффекты вам у вас будет естественное желание минимизировать эту работу и получать все необходимые данные одной пачкой.
А то что пакетный ввод-вывод всегда быстрее (и часто на порядки) единичного ввода вывода - это одна из аксиом (<mark>todo: вообще это обоснованное правило</mark>) разработки софта.
Во-вторых, все Эффекты вытянутые в юз кейс становятся Очевидными и вы быстро поймёте, что юз кейс становится тяжёлым и в его реализации необходимо держать производительность в уме.</p><p>На этом мы завершаем рассмотрение концептуальной модели софта и начинаем потихоньку двигаться в сторону практики.</p></section></section></section></section><section class="doc-section level-1"><h2 id=_декомпозиция_приложения>Декомпозиция приложения</h2><section class="doc-section level-2"><h3 id=_разбиение_по_видам_классов>Разбиение по видам классов</h3><p>У меня нет однозначного и универсального рецепта разбиения классов по пакетам заранее.
Но я точно могу сказать, что не надо разбивать проект по видам классов - entities, services, controllers.
В особо одиозных случаях заводят пакеты exceptions, enums и annotations.
Пакетов classes и interfaces почему-то ни разу не видел:) В плюсы такого подхода можно попытаться записать только то, что при его использовании не надо думать.
Но, во-первых, в нашей работе это минус, а во-вторых, думать всё-таки надо - либо как привести класс к одному из существующих видов, либо придумать новый вид.
К дизайну ни та ни другая деятельность отношения не имеет и я считаю, что время лучше посвящать продумыванию дизайна системы.</p><p>Проблемы пакетирования по видам классов:</p><div class="olist arabic"><ol class=arabic><li>Не все классы однозначно относятся к одному виду</li><li>Плохо масштабируется</li><li>Скрывает описание архитектуры за деталями реализации</li><li>Изменения одной фичи, как правило затрагивают несколько модулей</li><li><mark>todo: сложнее рулить логами через стандартные тулы</mark></li><li><mark>todo: проблемы с вайлдкард импортами apx_talk_clean_coders_hate, apx_books_clean_code:Chapter 17, J1</mark></li><li>Все выше перечисленное - это мелкие не приятности.
Действительным же аргументом против такого стиля пакетирования, является то, что он исключает использование ограниченных модификаторов доступа (package private в Java, internal в Kotlin) и вынуждает весь код делать публичным.
В итоге границы отсутсвуют в принципе - есть только соглашение о том что из более низких слоёв нельзя обращаться к более высоким.
А внутри слоёв и от более высоких к более низким слоям даже никаких соглашений о границах нет.
В итоге получается мегамесиво, слегка напоминающие очертаниями снеговик.
Это ещё больше усугубляется при использовании спригового компонент скана и иньекции зависимостей на полях.</li></ol></div></section><section class="doc-section level-2"><h3 id=_другие_идеи_к_разбиению_классов>Другие идеи к разбиению классов</h3><p>Что касается правильного разбиения с самого начала проекта, то за вдохновением советую обратиться к:</p><div class=ulist><ul><li><a href=https://medium.com/@msandin/strategies-for-organizing-code-2c9d690b6f33>статье "Four Strategies for Organizing Code"</a></li><li><a href=https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html>статье "Screaming architecture"</a></li><li>и к главе "34 THE MISSING CHAPTER" из книги "Clean Architecture".</li><li>пакетирование по объектам-блокам из <a href=#apx_book_oose>Object-Oriented Software Engineering: Use Case Drive Approach</a></li><li><a class=bare href=https://phauer.com/2020/package-by-feature/>https://phauer.com/2020/package-by-feature/</a></li><li>глава 10 "Modules", <a href=#apx_book_impl_ddd>Object-Oriented Software Engineering: Use Case Drive Approach</a></li></ul></div></section><section class="doc-section level-2"><h3 id=_мой_подход_к_разбиению_классов>Мой подход к разбиению классов</h3><div class="olist arabic"><ol class=arabic start=0><li>По началу я складываю все классы в один модуль пакет, потому как моя методика требует некоторой критической массы классов, для того чтобы сработать.</li><li>Мою методику можно применять, когда:<ul><li>Набралось хотя бы 10, а лучше 20 классов. Но я обычно на интуитивном уровне, чувствую, что пора навести порядок в этом бардаке.</li><li>Когда целиком реализовано 3-5 юз кейсов, среди которых есть и однотипные и ортогональные</li></ul></li><li>После того как набирается достаточное количество классов, я строю для них <a href=https://www.ndepend.com/docs/dependency-structure-matrix-dsm>матрицу зависимостей</a>. И разбиваю все циклы в зависимостях. Это бывает очень сложно, но многие из лучших своих решений я нашёл именно разбивая циклы.</li><li>После того, как все циклы разбиты, классы должны разбиться на три вида кластеров:<ul><li>кластеры классов, от которых ничего не зависит, но которые зависят от почти всех остальных классов (это будут порты и код сборки и инициализации графа объектов вашего приложения, при запуске)</li><li>кластеры классов, которые сами ни от чего не зависят, но от которых зависит почти всё (это будет домен/логика)</li><li>кластеры классов, от которых и зависят и другие классы и которые сами зависят от других классов (это будут порты, юз кейсы и адаптеры).</li></ul></li><li>Кластеры должны быть высоко связные (highly cohesive, много связей между классами внутри кластера) и слабо связанные (loosely coupled, мало связей с классами из других кластеров). Вот эти кластеры я и делаю пакетами/модулями.</li><li>Если после разбиения циклов кластеры не выявились, то тут уже надо смотреть каждый конкретный случай и универсального рецепта у меня нет.</li></ol></div></section></section></section><section class="doc-section level-0"><h1 id=_кодирование>Кодирование</h1><section class="doc-section level-1"><h2 id=_конструкторы_должно_создавать_валидные_объекты>Конструкторы должно создавать валидные объекты</h2></section><section class="doc-section level-1"><h2 id=_у_класса_может_быть_не_более_5_зависимостей>У класса может быть не более 5 зависимостей</h2><p>Под зависимостями я понимаю параметры конструктора, включая примитивные (конфигурацию).
Обращение к синглтонам откуда-либо помимо платформы запрещено категорически.
У этого правила несколько оснований:</p><p>Если вашему классу требуется более 5 зависимостей, то он либо делает слишком много, либо делает это использую слишком низкоуровневые примитивы (зависимости), на базе которых надо создать новую абстракцию.</p></section><section class="doc-section level-1"><h2 id=_наследование_todo>Наследование (<mark>todo</mark>)</h2><section class="doc-section level-2"><h3 id=_открытые_иерархии>Открытые иерархии</h3></section><section class="doc-section level-2"><h3 id=_закрытые_иерархии>Закрытые иерархии</h3></section></section><section class="doc-section level-1"><h2 id=_избегайте_интерфейсов_с_единственной_реализацией_todo>Избегайте интерфейсов с единственной реализацией (<mark>todo</mark>)</h2><p>Потому что они создают только видимость барьера и усложняют код. Невозможно сделать настоящий интерфейс по единственной реализации. Интерфейсы в АПИ лучше делать абстракными классами с закрытой реализацией, чтобы клиенты не могли их реализовывать. Интерфейсы в SPI - норм.</p></section><section class="doc-section level-1"><h2 id=_иммутабельность_по_дефолту_todo>Иммутабельность по дефолту (<mark>todo:</mark>)</h2><p>Защита от случайного внесения эффекта</p></section><section class="doc-section level-1"><h2 id=_domain_specific_languages_todo>Domain Specific Languages (<mark>todo</mark>)</h2></section><section class="doc-section level-1"><h2 id=_типизированные_иды_todo>Типизированные ИДы (<mark>todo:</mark>)</h2><p>Типобезопасность и проще грепать логи</p></section><section class="doc-section level-1"><h2 id=_cqrs_todo>CQRS (<mark>todo:</mark>)</h2></section><section class="doc-section level-1"><h2 id=_обработка_ошибок_todo>Обработка ошибок (<mark>todo:</mark>)</h2></section><section class="doc-section level-1"><h2 id=_find_usages_колонок_бд_todo>Find Usages колонок БД (#todo: #)</h2><p>Для того чтобы код был очевиден, необходимо чтобы была возможность быстро найти все использования определённой колонки БД хотя бы внутри приложения.</p></section></section><section class="doc-section level-0"><h1 id=_тестирование_todo>Тестирование (<mark>todo</mark>)</h1><div class="open-block partintro"><div class=content><p>(#todo: #)</p><p>поэтому я всё-таки за компромисс и по самому свежаку, начал выделять тесты 4ёх типов:</p><div class="olist arabic"><ol class=arabic><li>Тесты эффектов (репозов, гейтвеев) - для всего, что возможно используются реальные зависимости (постгрес в докере на рам диске), где нельзя (облако для пушей) - пишется стаб, который слушает настоящий tcp-порт</li><li>Тесты бизнес логики домена - пишутся без моков.</li><li>Тесты юзкейсов - должны быть, пишутся без моков, но можно застабить эвент паблишер. стаб вместо мока позволит, если вдруг потребуется, не переписывать все тесты при изменении интерфейса паблишера. работают изнутри всё ещё - приложение не запускается через мейн, но тест сам себе собирает нужный граф объектов и тычет его как надо</li><li>Сценарные тесты - живут в отдельном модуле независящим от основного приложения, ДТОшки тупо копи-пастятся, работают снаружи, прогоняют реальные хэппи пасы из прода и особо важные фейлы</li></ol></div><p>(#todo: #)</p></div></div><section class="doc-section level-1"><h2 id=_моки_todo>Моки (<mark>todo</mark>)</h2><p>Использование моков для подсовывание входных данных - зло.
Моки можно использовать для верификации эффектов юз кейсов, но по возможности лучше всё-таки отдавать предпочтение аксептанс/интеграционным тестам.</p></section><section class="doc-section level-1"><h2 id=_tdd_todo>TDD? (<mark>todo</mark>)</h2></section><section class="doc-section level-1"><h2 id=_ассерты_todo>Ассерты (<mark>todo:</mark>)</h2></section><section class="doc-section level-1"><h2 id=_контракты_todo>Контракты (<mark>todo:</mark>)</h2></section></section><section class="doc-section level-0"><h1 id=_заключение>Заключение</h1><div class="open-block partintro"><div class=content><p>Эргономичный подход рассматривает систему как набор юз кейсов.
Каждый юз кейс реализуются набором компонент различных типов: платформа, порты, юз кейсы, адаптеры и логика.
Каждый из типов может содержать либо Эффекты, либо Логику.</p><p>Эргономичный подход делает два акцента:</p><div class="olist arabic"><ol class=arabic><li>Описание всех Эффектов юз кейса должно содержаться в одном месте</li><li>Необходимо разделять Логику и Эффекты</li></ol></div><p>Первый акцент упрощает понимание системы и то, как та или иная доработка повлияет на видимые Эффекты, что способствует уменьшению количества ошибок, допускаемых в ходе модификации системы.
Второй акцент позволяет покрыть систему надёжным набором тестов, что так же способствует и простоте понимания системы (за счёт документирования системы по средствам тестов) и уменьшению количества ошибок.</p><p>В итоге стоимость разработки системы уменьшается, а её качество увеличивается.</p></div></div><section class="doc-section level-1"><h2 id=_примеры_todo>Appendix A: Примеры (<mark>todo</mark>)</h2><div class=ulist><ul><li>ГУЙ</li><li>Низкоуровневое программирование</li><li>микросервисы</li><li>консольный уй</li><li>рекативность</li><li>Плагины билд систем</li><li>Распределённые кластеры</li></ul></div><section class="doc-section level-2"><h3 id=_qbit_todo>qbit (<mark>todo</mark>)</h3><div class=ulist><ul><li>Факторизация кубита</li><li>Б+Дерево с кэшем нод в памяти и ленивой загрузкой нод с диска</li><li>WebDavStorage</li><li>Типизация: разделить создание графа энтитий и его "отипование"</li></ul></div></section><section class="doc-section level-2"><h3 id=_q5_todo>Q5 (<mark>todo</mark>)</h3></section><section class="doc-section level-2"><h3 id=_удобно_todo>Удобно (<mark>todo</mark>)</h3></section><section class="doc-section level-2"><h3 id=_проект_трустори>Проект ТруСтори</h3><p>Это вымышленный проект с примерами по мотивам проблем, с которыми я столкнулся у различных заказчиков.</p><section class="doc-section level-3"><h4 id=_юз_кейс_кпи_сотрудников>Юз кейс: КПИ сотрудников</h4><p>(<mark>todo: добавить пролонгацию, при быстром логине, чтобы когда в рассчёте кпи начал бы учитываться финиш тайм, то оно бы не сломалось</mark>)</p><p>В этом примере ТруСтори является стандартным бэком на Java/Spring/JPA с веб-фронтом с полнодуплексным соединением (<mark>todo: проверить термин</mark>).</p><p>Одной из фич ТруСтори является подсчёт КПИ сотрудников, среди которых есть длительность текущей смены.
Это значение сохраняется при перерыве в работе менее часа.</p><p>В реальной системе фича реализована так:</p><div class="olist arabic"><ol class=arabic><li>Доменному классу юзера было добавлено поле со временем начала работы.</li><li>Была переиспользована существующая таблица таймаутов, для того чтобы хранить момент сброса времени начала работы сотрудника.</li><li>При логине, проверяется наличие таймаута сброса,<ol class=loweralpha type=a><li>если он есть (что подразумевает, что время логаута не превысило час, т.е. продолжается текущая смена), то подсчитывается обновлённый КПИ и отправляется в браузер</li><li>в противном случае, обновляется значение времени начала работы</li></ol></li><li>При логауте, заводится таймер сброса времени начала работы.</li><li>Отдельный тред в фоне удаляет протухшие таймауты из базы.</li></ol></div><p>В этой функциональности зарылся неожиданный баг.
Некоторые новые (ниразу не логинвшиеся) сотрудники не могли подключиться, потому что каким-то образом у них был заведён таймаут на сброс времени начала работы (что происходит только при логауте), но при этом не было времени начала работы (т.е. не было логина).
В процессе расследования выяснилось, что одно из вспомогательных приложений, вело себя не совсем корректно и через АПИ звало логаут этим сотрудникам, что заводило им таймаут, но из-за того что они ни разу не логинились, им ни разу не проставлялось время начала работы и логика подсчёта КПИ крэшилась, из-за чего ломался логин (п. 3а).</p><p>Теперь давайте реализуем этот юз кейс в эргономичном стиле и увидим, как он помог бы избежать подобной проблемы и какие дополнительные преимущества принёс бы.</p><p>Начнём с того, что сформулируем сам юз кейс (<mark>todo: разботанить как составлять толковые юз кейсы</mark>).</p><p><strong>Цель:</strong> Я как сотрудник хочу видеть длительность своей рабочей смены.</p><p><strong>Рабочая смена</strong>: Один или более подряд идущих периодов времени нахождения сотрудника онлайн, с перерывами не более 60 минут.</p><p><strong>События</strong>:</p><div class="olist arabic"><ol class=arabic><li>Логин сотрудника</li><li>Запрос КПИ</li><li>Штатный логаут сотрудника</li><li>Нештатный логаут сотрудника (закрытие вкладки)</li></ol></div><p><strong>Эффекты</strong>:</p><div class="olist arabic"><ol class=arabic><li>Отображение текущих показателей сотрудника в браузере по запросу и при начале нового периода в рамках одной смены.</li></ol></div><p><strong>Технические эффекты</strong>: <mark>todo: оно надо?</mark></p><div class="olist arabic"><ol class=arabic><li>Пачка всякий загрузок из БД</li><li>Отправление сообщения в браузер</li><li>Сохранение чего-то в БД?</li></ol></div><p><strong>Алгоритм</strong>:</p><div class="olist arabic"><ol class=arabic><li>При логине сотрудника<ol class=loweralpha type=a><li>Если нет существующей смены (первый логин сотрудника в системе), то начать рабочую смену, и зафиксировать время её начала</li><li>Если существующая смена есть и время логаута менее часа назад (возврат сотрудника с обеда), то отправить сотрудника его текущие показатели КПИ.</li><li>Если существующая смена есть, и время логаута более часа назад (начало новой смены), то зафиксировать начало новой смены</li></ol></li><li>При логауте и закрытии вкладки, зафиксировать время события, в качестве потенциального времени окончания смены</li><li>При запросе КПИ сотрудника, вычислить текущие показатели КПИ и отправить в браузер.</li></ol></div><p>Глядя на этот юз кейс, лично у меня появляется одно желание - завести класс рабочей смены. Давайте так и поступим:</p><figure class=listing-block><figcaption>WorkShift.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>WorkShift</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nd>@Nonnull</span> <span class=nc>WebSocket</span> <span class=n>webSocket</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nd>@Nonnull</span> <span class=nc>User</span> <span class=n>user</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nd>@Nonnull</span> <span class=nc>Duration</span> <span class=n>maxInterruptionLen</span><span class=o>;</span>

    <span class=kd>private</span> <span class=nc>Instant</span> <span class=nd>@Nonnull</span> <span class=n>startTime</span><span class=o>;</span>

    <span class=kd>private</span> <span class=nc>Instant</span> <span class=nd>@Nullable</span> <span class=n>finishTime</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>WorkShift</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>WebSocket</span> <span class=n>webSocket</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>User</span> <span class=n>user</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>Instant</span> <span class=n>startTime</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>Duration</span> <span class=n>maxInterruptionLen</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>webSocket</span> <span class=o>=</span> <span class=n>webSocket</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>user</span> <span class=o>=</span> <span class=n>user</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>startTime</span> <span class=o>=</span> <span class=n>startTime</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>maxInterruptionLen</span> <span class=o>=</span> <span class=n>maxInterruptionLen</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogin</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>finishTime</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Первый логин, ничего не делаем</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=kd>final</span> <span class=nc>Duration</span> <span class=n>interruptionLen</span> <span class=o>=</span> <span class=nc>Duration</span><span class=o>.</span><span class=na>between</span><span class=o>(</span><span class=n>finishTime</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>interruptionLen</span><span class=o>.</span><span class=na>toMillis</span><span class=o>()</span> <span class=o>&lt;</span> <span class=n>maxInterruptionLen</span><span class=o>.</span><span class=na>toMillis</span><span class=o>())</span> <span class=o>{</span>
            <span class=c1>// Продолжение смены</span>
            <span class=n>webSocket</span><span class=o>.</span><span class=na>sendKpi</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=c1>// Начало новой смены</span>
            <span class=n>startTime</span> <span class=o>=</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>();</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendKpi</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>webSocket</span><span class=o>.</span><span class=na>sendKpi</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogout</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>finishTime</span> <span class=o>=</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>();</span>
    <span class=o>}</span>

<span class=o>}</span></code></pre></figure><p>Этот класс является не плохим объектом в классическом ООП - у него есть настоящее состояние и настоящее поведение.
К тому же теперь есть место где можно заэнфорсить инвариант, что время начала смены не налл.
Но у него есть и ряд проблем:</p><div class="olist arabic"><ol class=arabic><li>Этот объект мутабельный и может быть использован в разных тредах, поэтому его надо синхронизировать.</li><li>У него нет однозначной идентичности - это объект текущей рабочей смены и в разные моменты времени он соотвествует разным объектам реального мира.</li><li>В него зашита логика определённого юз кейса.
Если появятся новые требования, связанные с рабочей сменой, например ограничение длительности рабочей смены, то эту логику также придётся добавить в этот объект, что снизит его связность (cohesion).</li><li>Он нарушает принцип трёх зависимостей.</li></ol></div><p>Для решения этих проблем воспользуемся принципами DCI и неизменяемости:</p><div class="olist arabic"><ol class=arabic><li>Оставим WorkShift простым доменным объектом и сделаем его неизменяемым</li><li>Логику вынесем в роль KpiTracker</li></ol></div><div class=example-block><div class=example><p>Удивительно, как DCI всё ставит на свои места. Я долгое время руководствовался эвристикой, что класс с именем заканчивающимся на *er (все возможные Controllers, Managers, Drivers, Updaters и т.д.) указывает на проблемы в дизайне, потому что как правило это были пакеты процедур управляющие структурами данных.</p><p>Роль же с именем *er является вполне логичной и является одним из аспектов поведения объекта, который манипулирует состоянием того же объекта.</p></div></div><p>(<mark>todo: чёт с KpiTracker-ом в итоге концептуальное месиво какое-то вышло - он и роль, и юз кейс и контекст, надо выяснить норм ли это</mark>)</p><figure class=listing-block><figcaption>WorkShift.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>WorkShift</span> <span class=o>{</span>

    <span class=nd>@Nonnull</span> <span class=nc>Instant</span> <span class=n>startTime</span><span class=o>;</span>

    <span class=nd>@Nullable</span> <span class=nc>Instant</span> <span class=n>finishTime</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>WorkShift</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>Instant</span> <span class=n>startTime</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>startTime</span> <span class=o>=</span> <span class=n>startTime</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=nf>WorkShift</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>Instant</span> <span class=n>startTime</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>Instant</span> <span class=n>finishTime</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>startTime</span> <span class=o>=</span> <span class=n>startTime</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>finishTime</span> <span class=o>=</span> <span class=n>finishTime</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=nc>WorkShift</span> <span class=nf>finish</span><span class=o>(</span><span class=nc>Instant</span> <span class=n>finishTime</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=k>new</span> <span class=nf>WorkShift</span><span class=o>(</span><span class=n>startTime</span><span class=o>,</span> <span class=n>finishTime</span><span class=o>);</span>
    <span class=o>}</span>

<span class=o>}</span></code></pre></figure><figure class=listing-block><figcaption>KpiTracker.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KpiTracker</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nc>User</span> <span class=n>user</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nc>WebSocket</span> <span class=n>webSocket</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nc>Duration</span> <span class=n>maxInterruptionLen</span><span class=o>;</span>

    <span class=kd>private</span> <span class=nc>WorkShift</span> <span class=n>workShift</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>KpiTracker</span><span class=o>(</span><span class=nc>User</span> <span class=n>user</span><span class=o>,</span> <span class=nc>WorkShift</span> <span class=n>prev</span><span class=o>,</span> <span class=nc>WebSocket</span> <span class=n>webSocket</span><span class=o>,</span> <span class=nc>Duration</span> <span class=n>maxInterruptionLen</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>user</span> <span class=o>=</span> <span class=n>user</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>workShift</span> <span class=o>=</span> <span class=n>prev</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>webSocket</span> <span class=o>=</span> <span class=n>webSocket</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>maxInterruptionLen</span> <span class=o>=</span> <span class=n>maxInterruptionLen</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogin</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>workShift</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Первый логин сотрудника, ничего не делаем</span>
            <span class=n>workShift</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>WorkShift</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=k>if</span> <span class=o>(</span><span class=n>workShift</span><span class=o>.</span><span class=na>finishTime</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Ошибка - повторынй логин после начала смены, без предварительного логаута</span>
            <span class=n>workShift</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>WorkShift</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=kd>final</span> <span class=nc>Duration</span> <span class=n>interruptionLen</span> <span class=o>=</span> <span class=nc>Duration</span><span class=o>.</span><span class=na>between</span><span class=o>(</span><span class=n>workShift</span><span class=o>.</span><span class=na>finishTime</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>interruptionLen</span><span class=o>.</span><span class=na>toMillis</span><span class=o>()</span> <span class=o>&lt;</span> <span class=n>maxInterruptionLen</span><span class=o>.</span><span class=na>toMillis</span><span class=o>())</span> <span class=o>{</span>
            <span class=c1>// Продолжение смены</span>
            <span class=n>webSocket</span><span class=o>.</span><span class=na>sendKpi</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=c1>// Начало новой смены</span>
            <span class=n>workShift</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>WorkShift</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendKpi</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>webSocket</span><span class=o>.</span><span class=na>sendKpi</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogout</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>workShift</span> <span class=o>=</span> <span class=n>workShift</span><span class=o>.</span><span class=na>finish</span><span class=o>(</span><span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
    <span class=o>}</span>

<span class=o>}</span></code></pre></figure><p>Рассмотрим, как новая версия решает обозначенные выше проблемы:</p><div class="olist arabic"><ol class=arabic><li>Синхронизация: теперь <code>WorkShift</code> иммутабельный, а <code>KpiTracker</code> создаётся для каждого треда по отдельности - ни тот ни другой класс синхронизации больше не требуют.</li><li>Идентичность: рабочая смена стала вэлью объектом и больше не имеет идентичности.
Эта версия кода подсветила новый объект - рабочая смена сотрудника.
У него уже вполне понятная идентичность, которая определяется ключём <code>(user, startTime)</code>.
Следующим шагом выделим класс <code>UserWorkShift</code>.</li><li>Теперь логика юз кейса находится в отдельном классе.
Если потребуется добавить логику ограничения смены, то она так же пойдёт в отдельный класс <code>TimeShiftLimiter</code>.
Каждый из этих классов будет описывать отдельный юз кейс и будет иметь высокую связность (cohesion).</li><li>Принцип трёх зависимостей остался нарушен, но мы это исправим, создав класс <code>UserWorkShift</code>.</li></ol></div><p>Кроме того, в новой версии стала Очевидна вероятность возникновения ошибочной ситуации повторного логина без предварительного логаута - в первой версии он была скрыта обработкой первого логина сотрудника в системе.</p><p>Теперь давайте выделим <code>UserWorkShift</code>.
При попытке выделить <code>UserWorkShift</code> обнаружится проблема: при создании <code>KpiTracker</code> ещё не понятно, есть ли у сотрудинка активная текущая смена.
Можно попробовать сделать этот параметр нуллабельным, но мы тогда потеряем инфу о сотруднике, и не сможем начать рабочую смену при логине.
Поэтому в конструктор надо передавать сотрудника, для которого будем отслеживать рабочую смену и репозиторий рабочих смен, из-за чего мы снова нарушим правило трёх зависимостей.
Для того чтобы окончательно решить проблему с зависимостями, мы пойдём другим путём - вместо передачи репозитория рабочих смен, воспользуемся техникой шлюза из чистой архитектуры и все нужные зависимости скроем за одним интерфейсом.</p><figure class=listing-block><figcaption>UserWorkShiftRepository.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=c1>// Т.к. реализация репозитория не имеет особого значения, привожу только интерфейс</span>
<span class=k>new</span> <span class=nf>UserWorkShift</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>UserWorkShiftRepository</span> <span class=o>{</span>

    <span class=nd>@Nullable</span>
    <span class=kd>public</span> <span class=nc>UserWorkShift</span> <span class=nf>getByUserId</span><span class=o>(</span><span class=nc>Long</span> <span class=n>userId</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=o>}</span>

<span class=o>}</span></code></pre></figure><figure class=listing-block><figcaption>KpiGateway.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KpiGateway</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nc>UserWorkShiftRepository</span> <span class=n>userWorkShiftRepository</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nc>Duration</span> <span class=n>maxInterruptionLen</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>KpiGateway</span><span class=o>(</span><span class=nc>UserWorkShiftRepository</span> <span class=n>userWorkShiftRepository</span><span class=o>,</span> <span class=nc>Duration</span> <span class=n>maxInterruptionLen</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>userWorkShiftRepository</span> <span class=o>=</span> <span class=n>userWorkShiftRepository</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>maxInterruptionLen</span> <span class=o>=</span> <span class=n>maxInterruptionLen</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=nd>@Nullable</span>
    <span class=kd>public</span> <span class=nc>UserWorkShift</span> <span class=nf>getByUser</span><span class=o>(</span><span class=nc>User</span> <span class=n>user</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>userWorkShiftRepository</span><span class=o>.</span><span class=na>getByUserId</span><span class=o>(</span><span class=n>user</span><span class=o>.</span><span class=na>getId</span><span class=o>());</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendKpi</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>UserWorkShift</span> <span class=n>userWorkShift</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// sendKpi</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=nc>Duration</span> <span class=nf>getMaxInterruptionLen</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>maxInterruptionLen</span><span class=o>;</span>
    <span class=o>}</span>

<span class=o>}</span></code></pre></figure><figure class=listing-block><figcaption>UserWorkShift.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>UserWorkShift</span> <span class=o>{</span>

    <span class=nd>@Nonnull</span> <span class=kd>public</span> <span class=kd>final</span> <span class=nc>User</span> <span class=n>user</span><span class=o>;</span>

    <span class=nd>@Nonnull</span> <span class=kd>public</span> <span class=kd>final</span> <span class=nc>Instant</span> <span class=n>startTime</span><span class=o>;</span>

    <span class=nd>@Nullable</span> <span class=kd>public</span> <span class=kd>final</span> <span class=nc>Instant</span> <span class=n>finishTime</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>UserWorkShift</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>User</span> <span class=n>user</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>Instant</span> <span class=n>startTime</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=n>startTime</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=nf>UserWorkShift</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>User</span> <span class=n>user</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>Instant</span> <span class=n>startTime</span><span class=o>,</span> <span class=nd>@Nullable</span> <span class=nc>Instant</span> <span class=n>finishTime</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>user</span> <span class=o>=</span> <span class=n>user</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>startTime</span> <span class=o>=</span> <span class=n>startTime</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>finishTime</span> <span class=o>=</span> <span class=n>finishTime</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=nc>UserWorkShift</span> <span class=nf>finish</span><span class=o>(</span><span class=nc>Instant</span> <span class=n>finishTime</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=k>new</span> <span class=nf>UserWorkShift</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=n>startTime</span><span class=o>,</span> <span class=n>finishTime</span><span class=o>);</span>
    <span class=o>}</span>

<span class=o>}</span></code></pre></figure><figure class=listing-block><figcaption>KpiTracker.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KpiTracker</span> <span class=o>{</span>

    <span class=nd>@Nonnull</span> <span class=kd>private</span> <span class=kd>final</span> <span class=nc>User</span> <span class=n>user</span><span class=o>;</span>

    <span class=nd>@Nonnull</span> <span class=kd>private</span> <span class=kd>final</span> <span class=nc>KpiGateway</span> <span class=n>kpiGateway</span><span class=o>;</span>

    <span class=nd>@Nullable</span> <span class=kd>private</span> <span class=nc>UserWorkShift</span> <span class=n>userWorkShift</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>KpiTracker</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>User</span> <span class=n>user</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>KpiGateway</span> <span class=n>kpiGateway</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>user</span> <span class=o>=</span> <span class=n>user</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>kpiGateway</span> <span class=o>=</span> <span class=n>kpiGateway</span><span class=o>;</span>
        <span class=n>userWorkShift</span> <span class=o>=</span> <span class=n>kpiGateway</span><span class=o>.</span><span class=na>getByUser</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogin</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>userWorkShift</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Первый логин сотрудника, ничего не делаем</span>
            <span class=n>userWorkShift</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>UserWorkShift</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=k>if</span> <span class=o>(</span><span class=n>userWorkShift</span><span class=o>.</span><span class=na>finishTime</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Ошибка - повторынй логин после начала смены, без предварительного логаута</span>
            <span class=n>userWorkShift</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>UserWorkShift</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=kd>final</span> <span class=nc>Duration</span> <span class=n>interruptionLen</span> <span class=o>=</span> <span class=nc>Duration</span><span class=o>.</span><span class=na>between</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>.</span><span class=na>finishTime</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>interruptionLen</span><span class=o>.</span><span class=na>toMillis</span><span class=o>()</span> <span class=o>&lt;</span> <span class=n>kpiGateway</span><span class=o>.</span><span class=na>getMaxInterruptionLen</span><span class=o>().</span><span class=na>toMillis</span><span class=o>())</span> <span class=o>{</span>
            <span class=c1>// Продолжение смены</span>
            <span class=n>kpiGateway</span><span class=o>.</span><span class=na>sendKpi</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>);</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=c1>// Начало новой смены</span>
            <span class=n>userWorkShift</span> <span class=o>=</span>  <span class=k>new</span> <span class=nc>UserWorkShift</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendKpi</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>userWorkShift</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Ошибка - запрос на отравку КПИ для ни разу не логиневшегося сотрудника</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=n>kpiGateway</span><span class=o>.</span><span class=na>sendKpi</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogout</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>userWorkShift</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Ошибка - логаут ни разу не логиневшегося сотрудника</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=n>userWorkShift</span> <span class=o>=</span> <span class=n>userWorkShift</span><span class=o>.</span><span class=na>finish</span><span class=o>(</span><span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
    <span class=o>}</span>

<span class=o>}</span></code></pre></figure><p>Так же этот рефакторинг, по мимо решения проблем с идентичностью и зависимостями, сделал Очевидным то, что в нашей системе есть потенциальная возможность позвать логаут сотруднику, который ни разу не логинился.</p><p>Внимательный читатель, наверное заметил, что мы сейчас только загружаем смены из репозитория, но никогда их не сохраняем.
Давайте добавим в репозиторий возможность сохранения смен и сделаем эффекты по загрузке и сохранению рабочих расписаний симметричными и Очевидными:</p><figure class=listing-block><figcaption>UserWorkShiftRepository.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=c1>// Т.к. реализация репозитория не имеет особого значения, привожу только интерфейс</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>UserWorkShiftRepository</span> <span class=o>{</span>

    <span class=c1>// ...</span>

    <span class=kd>public</span> <span class=nc>UserWorkShift</span> <span class=nf>save</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>UserWorkShift</span> <span class=n>userWorkShift</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// ...</span>
    <span class=o>}</span>

    <span class=c1>// ...</span>

<span class=o>}</span></code></pre></figure><figure class=listing-block><figcaption>KpiGateway.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KpiGateway</span> <span class=o>{</span>

    <span class=c1>// ...</span>

    <span class=kd>public</span> <span class=nc>UserWorkShift</span> <span class=nf>save</span><span class=o>(</span><span class=nc>UserWorkShift</span> <span class=n>userWorkShift</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>userWorkShiftRepository</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=c1>// ...</span>
<span class=o>}</span></code></pre></figure><figure class=listing-block><figcaption>KpiTracker.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KpiTracker</span> <span class=o>{</span>

    <span class=nd>@Nonnull</span> <span class=kd>private</span> <span class=kd>final</span> <span class=nc>User</span> <span class=n>user</span><span class=o>;</span>

    <span class=nd>@Nonnull</span> <span class=kd>private</span> <span class=kd>final</span> <span class=nc>KpiGateway</span> <span class=n>kpiGateway</span><span class=o>;</span>

    <span class=nd>@Nullable</span> <span class=kd>private</span> <span class=nc>UserWorkShift</span> <span class=n>userWorkShift</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>KpiTracker</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>User</span> <span class=n>user</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>KpiGateway</span> <span class=n>kpiGateway</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>user</span> <span class=o>=</span> <span class=n>user</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>kpiGateway</span> <span class=o>=</span> <span class=n>kpiGateway</span><span class=o>;</span>
        <span class=n>userWorkShift</span> <span class=o>=</span> <span class=n>kpiGateway</span><span class=o>.</span><span class=na>getByUser</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogin</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>userWorkShift</span><span class=o>.</span><span class=na>workShift</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Первый логин сотрудника, ничего не делаем</span>
            <span class=n>userWorkShift</span> <span class=o>=</span> <span class=n>userWorkShift</span><span class=o>.</span><span class=na>startNewWorkShift</span><span class=o>();</span>
            <span class=n>kpiGateway</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>);</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=k>if</span> <span class=o>(</span><span class=n>userWorkShift</span><span class=o>.</span><span class=na>workShift</span><span class=o>.</span><span class=na>finishTime</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Ошибка - повторынй логин после начала смены, без предварительного логаута</span>
            <span class=n>userWorkShift</span> <span class=o>=</span> <span class=n>userWorkShift</span><span class=o>.</span><span class=na>startNewWorkShift</span><span class=o>();</span>
            <span class=n>kpiGateway</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>);</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=kd>final</span> <span class=nc>Duration</span> <span class=n>interruptionLen</span> <span class=o>=</span> <span class=nc>Duration</span><span class=o>.</span><span class=na>between</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>.</span><span class=na>workShift</span><span class=o>.</span><span class=na>finishTime</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>interruptionLen</span><span class=o>.</span><span class=na>toMillis</span><span class=o>()</span> <span class=o>&lt;</span> <span class=n>maxInterruptionLen</span><span class=o>.</span><span class=na>toMillis</span><span class=o>())</span> <span class=o>{</span>
            <span class=c1>// Продолжение смены</span>
            <span class=n>kpiGateway</span><span class=o>.</span><span class=na>sendKpi</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>.</span><span class=na>user</span><span class=o>);</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=c1>// Начало новой смены</span>
            <span class=n>userWorkShift</span> <span class=o>=</span> <span class=n>userWorkShift</span><span class=o>.</span><span class=na>startNewWorkShift</span><span class=o>();</span>
            <span class=n>kpiGateway</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=c1>// ...</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogout</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>userWorkShift</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Ошибка - логаут ни разу не логиневшегося сотрудника</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=n>userWorkShift</span> <span class=o>=</span> <span class=n>userWorkShift</span><span class=o>.</span><span class=na>finish</span><span class=o>(</span><span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
        <span class=n>kpiGateway</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>userWorkShift</span><span class=o>);</span>
    <span class=o>}</span>

<span class=o>}</span></code></pre></figure><p>В этой реализации есть две новые проблемы:</p><div class="olist arabic"><ol class=arabic><li>При логине сохранение рабочей смены дублируется 3 раза</li><li>Метод логина начал нарушать правило логики или эффектов - логика определения начала смены не совсем тривиальная и её хочется покрыть тестами, но это невозможно не замокав <code>kpiGateway</code>.</li></ol></div><p>Для решения этих проблем вынесем бизнес правило определения начала рабочей смены в чистую функцию предметной области в классе <code>KpiRules</code>.</p><figure class=listing-block><figcaption>KpiRules.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KpiRules</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>shouldStartNewWorkShift</span><span class=o>(</span><span class=nc>UserWorkShift</span> <span class=n>currentWorkShift</span><span class=o>,</span> <span class=nc>Duration</span> <span class=n>maxInterruptionLen</span><span class=o>,</span> <span class=nc>Instant</span> <span class=n>now</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>currentWorkShift</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Первый логин сотрудника, ничего не делаем</span>
            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=k>if</span> <span class=o>(</span><span class=n>currentWorkShift</span><span class=o>.</span><span class=na>finishTime</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// Ошибка - повторынй логин после начала смены, без предварительного логаута</span>
            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=kd>final</span> <span class=nc>Duration</span> <span class=n>interruptionLen</span> <span class=o>=</span> <span class=nc>Duration</span><span class=o>.</span><span class=na>between</span><span class=o>(</span><span class=n>currentWorkShift</span><span class=o>.</span><span class=na>finishTime</span><span class=o>,</span> <span class=n>now</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>interruptionLen</span><span class=o>.</span><span class=na>toMillis</span><span class=o>()</span> <span class=o>&gt;=</span> <span class=n>maxInterruptionLen</span><span class=o>.</span><span class=na>toMillis</span><span class=o>();</span>
    <span class=o>}</span>

<span class=o>}</span></code></pre></figure><figure class=listing-block><figcaption>KpiTracker.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>KpiTracker</span> <span class=o>{</span>

    <span class=nd>@Nonnull</span> <span class=kd>private</span> <span class=kd>final</span> <span class=nc>KpiGateway</span> <span class=n>kpiGateway</span><span class=o>;</span>

    <span class=nd>@Nonnull</span> <span class=kd>private</span> <span class=kd>final</span> <span class=nc>KpiRules</span> <span class=n>kpiRules</span><span class=o>;</span>

    <span class=nd>@Nonnull</span> <span class=kd>private</span> <span class=nc>UserWorkShift</span> <span class=n>userWorkShift</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>KpiTracker</span><span class=o>(</span><span class=nd>@Nonnull</span> <span class=nc>Long</span> <span class=n>userId</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>KpiGateway</span> <span class=n>kpiGateway</span><span class=o>,</span> <span class=nd>@Nonnull</span> <span class=nc>KpiRules</span> <span class=n>kpiRules</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>kpiGateway</span> <span class=o>=</span> <span class=n>kpiGateway</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>kpiRules</span> <span class=o>=</span> <span class=n>kpiRules</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>userWorkShift</span> <span class=o>=</span> <span class=n>kpiGateway</span><span class=o>.</span><span class=na>getByUserId</span><span class=o>(</span><span class=n>userId</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogin</span><span class=o>()</span> <span class=o>{</span>
        <span class=nc>UserWorkShift</span> <span class=n>currentWorkShift</span> <span class=o>=</span> <span class=n>userWorkShift</span><span class=o>();</span>

        <span class=kt>boolean</span> <span class=n>shouldStartNewWorkShift</span> <span class=o>=</span> <span class=n>kpiRules</span><span class=o>.</span><span class=na>shouldStartNewWorkShift</span><span class=o>(</span><span class=n>currentWorkShift</span><span class=o>,</span> <span class=n>kpiGateway</span><span class=o>.</span><span class=na>getMaxInterruptionLen</span><span class=o>(),</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
        <span class=nc>Assert</span><span class=o>.</span><span class=na>isTrue</span><span class=o>(</span><span class=n>currentWorkShift</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>shouldStartNewWorkShift</span><span class=o>,</span> <span class=s>&#34;KPI rules has decided to not start new work shift on login of user without active work shift&#34;</span><span class=o>);</span>

        <span class=k>if</span> <span class=o>(</span><span class=n>shouldStartNewWorkShift</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>currentWorkShift</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>UserWorkShift</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=nc>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
            <span class=n>kpiGateway</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>currentWorkShift</span><span class=o>);</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>kpiGateway</span><span class=o>.</span><span class=na>sendKpi</span><span class=o>(</span><span class=n>currentWorkShift</span><span class=o>);</span>

    <span class=o>}</span>

    <span class=c1>// ...</span>

<span class=o>}</span></code></pre></figure><p>Отлично, теперь нам не хватает только лишь Порта, для того чтобы получить канонический эргономичный юз кейс, давайте добавим его:</p><figure class=listing-block><figcaption>KpiTracker.java</figcaption><pre class="rouge highlight"><code data-lang=java><span class=nd>@RestController</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>KpiPort</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nc>AuthService</span> <span class=n>authService</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nc>UserService</span> <span class=n>userService</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=nc>KpiGateway</span> <span class=n>kpiGateway</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>KpiPort</span><span class=o>(</span><span class=nc>AuthService</span> <span class=n>authService</span><span class=o>,</span> <span class=nc>UserService</span> <span class=n>userService</span><span class=o>,</span> <span class=nc>KpiGateway</span> <span class=n>kpiGateway</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>authService</span> <span class=o>=</span> <span class=n>authService</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>userService</span> <span class=o>=</span> <span class=n>userService</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>kpiGateway</span> <span class=o>=</span> <span class=n>kpiGateway</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=nd>@EventListener</span>
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogin</span><span class=o>(</span><span class=nc>UserLoginEvent</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
        <span class=kd>final</span> <span class=nc>KpiTracker</span> <span class=n>kpiTracker</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>KpiTracker</span><span class=o>(</span><span class=n>userService</span><span class=o>.</span><span class=na>getUser</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>userId</span><span class=o>),</span> <span class=n>kpiGateway</span><span class=o>,</span> <span class=k>new</span> <span class=nc>KpiRules</span><span class=o>());</span>
        <span class=n>kpiTracker</span><span class=o>.</span><span class=na>onLogin</span><span class=o>();</span>
    <span class=o>}</span>

    <span class=nd>@PutMapping</span><span class=o>(</span><span class=n>value</span> <span class=o>=</span> <span class=s>&#34;/kpi&#34;</span><span class=o>)</span>
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendKpi</span><span class=o>()</span> <span class=o>{</span>
        <span class=kd>final</span> <span class=nc>KpiTracker</span> <span class=n>kpiTracker</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>KpiTracker</span><span class=o>(</span><span class=n>authService</span><span class=o>.</span><span class=na>getCurrentUser</span><span class=o>(),</span> <span class=n>kpiGateway</span><span class=o>,</span> <span class=k>new</span> <span class=nc>KpiRules</span><span class=o>());</span>
        <span class=n>kpiTracker</span><span class=o>.</span><span class=na>sendKpi</span><span class=o>();</span>
    <span class=o>}</span>

    <span class=nd>@EventListener</span>
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onDisconnect</span><span class=o>(</span><span class=nc>UserDisconnectEvent</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
        <span class=kd>final</span> <span class=nc>KpiTracker</span> <span class=n>kpiTracker</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>KpiTracker</span><span class=o>(</span><span class=n>userService</span><span class=o>.</span><span class=na>getUser</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>userId</span><span class=o>),</span> <span class=n>kpiGateway</span><span class=o>,</span> <span class=k>new</span> <span class=nc>KpiRules</span><span class=o>());</span>
        <span class=n>kpiTracker</span><span class=o>.</span><span class=na>onLogout</span><span class=o>();</span>
    <span class=o>}</span>

    <span class=nd>@EventListener</span>
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onLogout</span><span class=o>(</span><span class=nc>UserLogoutEvent</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
        <span class=kd>final</span> <span class=nc>KpiTracker</span> <span class=n>kpiTracker</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>KpiTracker</span><span class=o>(</span><span class=n>userService</span><span class=o>.</span><span class=na>getUser</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>userId</span><span class=o>),</span> <span class=n>kpiGateway</span><span class=o>,</span> <span class=k>new</span> <span class=nc>KpiRules</span><span class=o>());</span>
        <span class=n>kpiTracker</span><span class=o>.</span><span class=na>onLogout</span><span class=o>();</span>
    <span class=o>}</span>


<span class=o>}</span></code></pre></figure><p>Порт вышел тривиальным - таким каким и должен быть.</p><p>(<mark>todo: диаграмма</mark>)</p><p>Вот чего мы добились применив эргономичный подход:</p><div class="olist arabic"><ol class=arabic><li>Обнаружили и сделали Очевидной ранее скрытую сущность предметной области - рабочая смена сотрудника</li><li>Замкнули на один класс все входы и выходы юз кейса - теперь очевидно куда добавлять новую функциональность (этого юз кейса конечно же, другие юз кейсы пойдут в другие классы), когда она появится, и при каких событиях она должна и будет вызываться и какие эффекты будет иметь</li><li>Описали юз кейс в одном месте и сделали его Очевидным (в оригинальной версии, юз кейс раскидан по четырём разным классам в трёх разных модулях)</li><li>Описали правило начала новой рабочей смены (в оригинальном коде, начало смены определялось по наличию записи в таблице таймаутов, которая записывалась в двух разных классах, а удалялась в третьем)</li></ol></div><p>Оригинальная ошибка в эргономичной версии практически исключена - из-за того что языком реализации является Java, приходится рассчитывать на аннотации и подскзки Идеи, в Kotlin’е эта ошибка была бы исключена на уровне типов.</p><p>Единственное что меня не много смущает в итоговой версии - объединение отслеживания рабочих смен и отправку КПИ в одном классе.
Но пока что рабочая смена является нужна только в юз кейсе КПИ, поэтому я думаю эту связность пока можно оставить.
Когда рабочая смена потребуется в другом юз кейсе, её надо будет выделить в отдельный модуль.
Наконец, это объясняет все наши мучения с принципом трёх зависимостей - <code>KpiTracker</code> действительно делает слишком много.
И он и рабочие расписания отслеживает, и определяет правило продления смены (вообще надо было изначально длительность перерыва перенести в <code>KpiRules</code>, но оставим так) и КПИ отправляет.</p></section><section class="doc-section level-3"><h4 id=_модель_состояний_сотрудника_todo>Модель состояний сотрудника (<mark>todo</mark>)</h4></section><section class="doc-section level-3"><h4 id=_отчёты>Отчёты</h4></section><section class="doc-section level-3"><h4 id=_тиндер_для_породистых_собак>Тиндер для породистых собак</h4><p>Требования:</p><div class="olist arabic"><ol class=arabic><li>Необходимо разработать систему для "знакомства" породистых собак.</li><li>Для кобелей может быть запланировано одновременная случка с несколькими сучками.</li><li>Сучки так же могут учавствовать в случках несколько раз, но только в одной случке в один момент времени.</li><li>Перед случкой ветеринары проверяют совместимость собак, и могут назначить сучке другого кабеля в обход алгоритма - на один запрос на случку, может быть по очереди назначено несколько кабелей.</li><li>Если была смена кобеля, то при последующем запросе на случку, данный кобель не должен быть вновь на значен той же сучке.</li><li>Сводить можно только собак одной породы.</li><li>Породы имеют приоритет</li><li>Администратор системы может создавать дополнительные требования к кобелям, которые могут быть сгруппированы в несколько приоретизированных групп.</li><li>Владельцы сучек могут, выбирать группы требований, которым должен соответствовать кобель</li></ol></div><p>Общий алгоритм выбора кобеля сучке следующий:</p><div class="olist arabic"><ol class=arabic><li>Для каждой сучки выполняется поиск кобеля последовательно по группам доп. требований<ol class=loweralpha type=a><li>Выполняется поиск кобеля соответствующий требованиям группы</li><li>При нахождении свободно кобеля назначается случка</li><li>Если нет ни одного свободного кобеля соответствующего требованиям, рассматривается следующая группа.
Если ни в одной из групп нет свободных кобелей, то поиск выполняется повторно начиная с первой группы при появлении свободного кобеля</li></ol></li><li>Если в группе на одному кобелю могут быть назначены несколько сучек, то учитываются правила<ol class=loweralpha type=a><li>Сучки распределяются согласну приоритету породы</li><li>Среди сучек одной породы, кобель назначется той, которая запросила случку первой</li></ol></li><li>В каждой группе требований выполняется алгоритм поиска кобеля:<ol class=loweralpha type=a><li>Поиск хотя бы одного кобеля в группе требований<ol class=lowerroman type=i><li>Если нет ни одного свободного кобеля - переход в следующую группу</li><li>Если свободен только один подходящий кобель - назначить случку</li><li>Если свободных кобелей несколько, то выполняется поиск кобеля, с которым была последняя случка</li><li>Если такого кобеля не найдено, то выполняется поиск кобеля с наибольшим количеством мест в очери на случку.
При наличии кобелей с равной занятостью, выбирается кобель с наибольшим временем без случки</li></ol></li></ol></li><li>Если была смена кобеля перед случкой, то данный кобель больше не должен назначаться на случку с данной сучкой</li></ol></div></section></section><section class="doc-section level-2"><h3 id=_todos_todo>Todos (<mark>todo</mark>)</h3></section></section></section><section class="doc-section level-1"><h2 id=_дальнейшее_чтение>Appendix B: Дальнейшее чтение</h2><section class="doc-section level-2"><h3 id=_люди>Люди</h3><section class="doc-section level-3"><h4 id=apx_peop_uncle_bob>Анкл Боб</h4></section><section class="doc-section level-3"><h4 id=_эрик_майер>Эрик Майер</h4></section><section class="doc-section level-3"><h4 id=_дэвид_вест>Дэвид Вест</h4></section><section class="doc-section level-3"><h4 id=_эрик_эванс>Эрик Эванс</h4></section><section class="doc-section level-3"><h4 id=_кевлин_хэнни>Кевлин Хэнни</h4></section><section class="doc-section level-3"><h4 id=_рич_хикки>Рич Хикки</h4></section><section class="doc-section level-3"><h4 id=_трюгве_реенскауг>Трюгве Реенскауг</h4></section><section class="doc-section level-3"><h4 id=apx_peop_coplien>Джеймс Коплейн (James Coplien)</h4></section></section><section class="doc-section level-2"><h3 id=_книги>Книги</h3><section class="doc-section level-3"><h4 id=apx_book_ddd>DDD</h4></section><section class="doc-section level-3"><h4 id=apx_book_object_thinking>Object Thinking</h4></section><section class="doc-section level-3"><h4 id=apx_book_lean_arch>Lean Architecture for Agile Software Development</h4></section><section class="doc-section level-3"><h4 id=apx_book_clean_code>Clean Code</h4></section><section class="doc-section level-3"><h4 id=apx_book_clean_arch>Clean Architecture</h4></section><section class="doc-section level-3"><h4 id=apx_book_eff_java>Effective Java</h4></section><section class="doc-section level-3"><h4 id=apx_book_api>Practical API Design</h4></section><section class="doc-section level-3"><h4 id=apx_book_ood_booch>Object-Oriented Design with Applications</h4></section><section class="doc-section level-3"><h4 id=apx_book_ooa_coad>Object-Oriented Analysis</h4></section><section class="doc-section level-3"><h4 id=apx_book_oose>Object-Oriented Software Engineering: Use Case Drive Approach</h4></section><section class="doc-section level-3"><h4 id=apx_book_ooram>Working with objects: The OOram Software Engineering Method</h4></section><section class="doc-section level-3"><h4 id=apx_book_func_arch>Functional Design and Architecture</h4><p><a class=bare href=https://leanpub.com/functional-design-and-architecture>https://leanpub.com/functional-design-and-architecture</a></p></section><section class="doc-section level-3"><h4 id=apx_book_gof>Design Patterns: Elements of Reusable Object-Oriented Software</h4></section><section class="doc-section level-3"><h4 id=apx_book_impl_ddd>Object-Oriented Software Engineering: Use Case Drive Approach</h4></section><section class="doc-section level-3"><h4 id=apx_book_func_ddd>Domain Modeling Made Functional</h4></section><section class="doc-section level-3"><h4 id=apx_book_ppp_of_ddd>Patterns, principles and practises of DDD</h4></section></section><section class="doc-section level-2"><h3 id=_научные_статьи>Научные статьи</h3><section class="doc-section level-3"><h4 id=apx_paper_comm_sense>The Common Sense of Object Orientated Programming</h4></section></section><section class="doc-section level-2"><h3 id=_публицистические_статьи>Публицистические статьи</h3><section class="doc-section level-3"><h4 id=apx_artc_seg>Segue</h4></section></section><section class="doc-section level-2"><h3 id=_блог_посты>Блог посты</h3><section class="doc-section level-3"><h4 id=apx_screaming_arch>Screaming architecture</h4><p>Ссылка: <a class=bare href=https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html>https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html</a></p></section></section><section class="doc-section level-2"><h3 id=_доклады>Доклады</h3><section class="doc-section level-3"><h4 id=apx_talk_dci>DCI: Practical Tips and Lessons for Nerds</h4><p>Ссылка: <a class=bare href="https://www.youtube.com/watch?v=SxHqhDT9WGI">https://www.youtube.com/watch?v=SxHqhDT9WGI</a></p></section><section class="doc-section level-3"><h4 id=apx_talk_dci_glimpse_of_rygve>A Glimpse of Trygve: From Class-oriented Programming to Real OO</h4><p>Ссылка: <a class=bare href="https://www.youtube.com/watch?v=lQQ_CahFVzw">https://www.youtube.com/watch?v=lQQ_CahFVzw</a></p></section><section class="doc-section level-3"><h4 id=apx_talk_clean_coders_hate>Clean Coders Hate What Happens to Your Code When You Use These Enterprise Programming Tricks</h4><p>Ссылка: <a class=bare href="https://www.youtube.com/watch?v=FyCYva9DhsI">https://www.youtube.com/watch?v=FyCYva9DhsI</a></p></section><section class="doc-section level-3"><h4 id=apx_talk_giving_code_a_good_name>Giving code a good name</h4><p>Ссылка: <a class=bare href="https://www.youtube.com/watch?v=CzJ94TMPcD8">https://www.youtube.com/watch?v=CzJ94TMPcD8</a></p></section><section class="doc-section level-3"><h4 id=apx_talk_oop_is_dead>OOP is Dead! Long Live OODD!</h4><p>Ссылка: <a class=bare href="https://www.youtube.com/watch?v=RdE-d_EhzmA">https://www.youtube.com/watch?v=RdE-d_EhzmA</a></p></section></section></section><section class="doc-section level-1"><h2 id=_spring>Appendix C: Spring</h2><section class="doc-section level-2"><h3 id=_не_использовать_компонент_скан_todo>Не использовать компонент скан (<mark>todo:</mark>)</h3><p>Заметает бардак в зависимостях под ковёр
Проблемы с циклическими зависимости проявляются ток в рантайме</p></section></section></article></section></div></main><script src=/js/app.js></script></body></html>