---
title: "ФП виновно в снижении стоимости програм. Вот мои доказательства, господа присяжные заседатели"
date: 2023-10-26T08:25:37+07:00
draft: true
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font
:sectlinks:
:imagesdir: /posts/23/10/images

== Введение

Когда я рассказываю про link:++{{<ref "ergo-approach/landing">}}++[Эргономичный подход] мне очень часто задают вопросы: "Почему не JPA?", "Почему неизменяемая модель данных" и "Почему ФП, а не "нормальное" (императивное) программирование"?
Ключевым из них является третий вопрос.

Так почему ФП?
Потому что я верю в истинность гипотезы о том, что программы, написанные в функциональном стиле проще понимать, отлаживать и изменять (далее - Гипотеза).
Благодаря этому суммарная стоимость разработки программы написанной в функциональном стиле будет дешевле как в деньгах бизнеса, так и в нервах программиста.

У этой гипотезы нет неоспоримого подтверждения, но есть целый ряд фактов, которые свидетельствуют в пользу её истинности.

Главный из этих фактов - эмпирическое подтверждение Гипотезы, описанное в книге Structured Design.

== Структурный дизайн

В главе "THE MORPHOLOGY OF SIMPLE SYSTEMS" книги Structured Design (эта книга ввела в нашу индустрию понятия сцепленности (Coupling) и функциональной связанности (Cohesion)), Константин приводит иллюстрацию того, что он называет моделью, ориентированной на трансформацию (выделение цветами моё):

image::why-fp-286c9.png[]

Затем Константин пишет:

[quote, Larry Constantine, "Structured Design, p. 144"]
____
It [transform-centered model] was derived empirically from a careful review of the morphology of systems, comparing systems that *had proven* to be *cheap to implement, to maintain, and to modify* with ones that had been expensive.
[...]
The umpteenth round in this game produced what came to be called the transform-centered model.
*Most of the cheap systems had it* - none of the costly systems did!

Она [модель, ориентированная на трансформацию] была получена эмпирически на основе тщательного анализа морфологии систем со сравнением систем, которые *были доказано дёшевы в разработки, обслуживании и модификации*, с системами, которые были дорогостоящими.
[...]
Энный раунд этой игры породил то, что стало называться моделью, ориентированной на трансформации.
*Она присутствовала в большинстве дешевых систем* - ни одна из дорогостоящих систем не имела её!
____

И если предположить, что трансформации являются чистым  функциями в терминах ФП, то в этой модели отчётливо видна функциональная архитектура: красные афферентные модули (ввод), жёлтые эфферентные модули (вывод) и голубой модуль координации - императивная оболочка, зелёные модули центральной трансформации - чистое ядро.

Константин не пишет прямым текстом, что трансформации - это чистые функции, но если изучить книгу и исторический контекст, то это становится очевидно.

Для того чтобы функция была чистой, она не должна иметь побочных эффектов.
В современно мире, функция может иметь следующие виды побочных эффектов:

. Ввод-вывод в консоль, файл или сеть;
. Выброс исключения;
. Запуск нового потока;
. Изменение полей структур данных, переданных ей на вход по указателю;
. Чтение и изменение полей глобальных структур данных, доступных по статической ссылке (обращение к общему окружению);

Первый вид эффектов (ввод-вывод) исключён самой моделью.

Выброс исключения, запуск нового потока изменение структур по указателю исключены историческим контекстом - все эти штуки только-только начали появляться в момент разработки структурного дизайна (https://en.wikipedia.org/wiki/Exception_handling_(programming)[исключения], https://en.wikipedia.org/wiki/Thread_(computing)[потоки], https://en.wikipedia.org/wiki/Pointer_(computer_programming)[указатели]).

[NOTE]
====
Любопытный факт - с указателями Советский союз смог догнать и перегнать Америку и придумал их в 1955 году, на 12 лет раньше западных учёных.
====

Касательно обращения к общему окружению, Константин прямым текстом говорит, что обращений к общему окружению *не* следует избегать любой ценой.
С другой стороны, он приводит такую иллюстрацию "эффекта общего окружения", которой хочется избежать любой ценой.

[quote, Larry Constantine, Structured Design, p. 88]
____
Whenever two or more modules interact with a common data environment, those modules are said to be common-environment coupled.
[...]
A common environment may be a shared communication region, a conceptual file in any storage medium, a physical device or file, a common data base area, and so on.
[...]
The point is not that common-environment coupling is bad, or that it should be avoided at all cost.
To the contrary, there are circumstances in which this may be the method of choice.
However, it should be clear that a small number of elements shared among a few modules can enormously complicate the structure of a system - from the point of view of understanding it, maintaining it, or modifying it.

image::why-fp-509f0.png[]

Всякий раз, когда два или более модуля взаимодействуют с данными в общем окружении, считается, что эти модули сцепленны через общее окружение.
[...]
Общим окружением может быть общая область обмена данными, концептуальный файл на любом носителе информации, физическое устройство или файл, общая область базы данных и так далее.
[...]
Дело не в том, что сцепленность через общее окружение плоха или что ее следует избегать любой ценой.
Напротив, существуют обстоятельства, при которых этот метод может быть предпочтительным.
Однако должно быть очевидно, что небольшое количество элементов, совместно используемых несколькими модулями, может чрезвычайно усложнить структуру системы с точки зрения ее понимания, обслуживания или модификации.
____

Так же косвенным свидетельством в пользу того, что трансформации должны быть чистыми функциями, является тот факт, что в статье https://www.academia.edu/58429322/Structured_design[Structured Design] Константин пишет:

[quote, Larry Constantine, Structured Design]
____
A predictable, or well-behaved, module is one that, when given the identical inputs, operates identically each time it is called.
Also, a well-behaved module operates independently of its environment.

Предсказуемый, или [хорошо управляемый/исправный/хорошо себя ведущий], модуль - это модуль, который при задании идентичных входных данных работает одинаково при каждом его вызове.
Кроме того, исправный модуль работает независимо от своей среды.
____

Это определение well-behaved модуля (подпрограммы) буквально является определением чистой функции.

---

Итого:

. Трансформации не могут иметь никаких эффектов, кроме обращения к общему окружению;
. При этом Константин иллюстрирует "эффект общего окружения" картинкой, которая повергнет в ужас любого разработчика;
. И называет исправными подпрограммы, которые обладают свойствами чистых функций.

Достаточно ли этого, для того чтобы считать, что трансформации были чистыми функциями и, следовательно, модель, ориентированная на трансформации является эквивалентом функциональной архитектуры?
Я считаю что да.

Это, в свою очередь, значит что есть эмпирические свидетельства тому, что применение чистой архитектуры ведёт к системам "дешёвым в разработке, обслуживании и модификации".

Это могло бы быть неопровержимым доказательством, если бы не одно но.
Результаты этого исследования не были опубликованы в рецензируемом научном журнале потому что "исходные данные и заметки были утеряны в беспорядочной гибели института".

Тем не менее, я считаю, что слова учёного с мировым именем заслуживают доверия.
В том числе потому, что они подтверждаются другими экспертами-практиками.

== Косвенные подтверждения Гипотезы

=== ФП в книгах

Призывы максимум кода выделять в чистые функции встречаются во множестве книг, опубликованных начиная с 60-ых годов и публикуемых по сей день.

==== Functional Design: Principles, Patterns, and Practices (2023), Robert Martin

https://www.amazon.com/Functional-Design-Principles-Patterns-Practices/dp/0138176396[Свежая книга] Роберта Мартина, пожалуй самого цитируемого человека на собеседованиях и конференциях по дизайну и хорошему коду, называется Functional Design: Principles, Patterns, and Practices.
Эта книга целиком является агитацией за ФП, поэтому не буду её тут цитировать:)

==== Unit Testing: Principles, Practices, and Patterns (2020), Vladimir Khorikiv

Лучшая, на мой взгляд, https://www.amazon.com/Unit-Testing-Principles-Practices-Patterns/dp/1617296279[книга по автоматизации тестирования] включает в себя три раздела на 23 страницы, посвящённых функциональной архитектуре.

==== Patterns, Principles, and Practices of Domain-Driven Design (2015), Scott Millett

[quote, Scott Millett, "Patterns, Principles, and Practices of Domain-Driven Design, section Favor Hidden‐Side‐Effect‐Free Functions"]
____
Side effects can make code harder to reason about and harder to test, and they can often be the source of bugs.
In a broad programming context, avoiding side effecting functions as much as possible is generally considered good advice.
You even saw in the previous chapter how being side-effect‐free and immutable were two of the main strengths of value objects.
*But if avoiding side effects is good advice, avoiding hidden side effects is a fundamental expectation*.

Побочные эффекты могут усложнить анализ кода и его тестирование и они выступают источником ошибок.
Избегать насколько это возможно, функций с побочными эффектами -  обычно считается хорошим советом в программировании.
Вы даже видели в предыдущей главе, что отсутствие побочных эффектов и неизменяемость были двумя основными преимуществами объектов-значений.
*Но если избегать побочных эффектов - хороший совет, то избегать скрытых побочных эффектов - фундаментальное ожидание*.
____

==== Clean Code (2008), Robert Martin

[quote, Robert Martin, "Clean code, section Have No Side Effects"]
____
*Side effects are lies.*

Your function promises to do one thing, but it also does other hidden things.
Sometimes it will make unexpected changes to the variables of its own class.
Sometimes it will make them to the parameters passed into the function or to system globals.
In either case they are devious and damaging mistruths that often result in strange temporal couplings and order dependencies.

*Побочные эффекты - это ложь.*

Ваша функция обещает сделать что-то одно, но она также выполняет и другие скрытые действия.
Иногда она вносит неожиданные изменения в переменные своего собственного класса.
Иногда делает это с параметрами, передаваемым в функцию, или глобальными переменными системы.
В любом случае это коварные и разрушительные обманы, которые часто приводят к странным временнЫм связям и зависимостям в порядке выполнения.
____

==== Domain-Driven Design (2003), Eric Evans

[quote, Eric Evans, "Domain-Driven Design, section SIDE-EFFECT-FREE FUNCTION"]
____
*Place as much of the logic of the program as possible into functions*, operations that return results with no observable side effects.
Strictly segregate commands (resulting in modifications to observable state) into very simple operations that do not return domain information.
Further control side effects by moving complex logic into VALUE OBJECTS with conceptual definitions fitting the responsibility.

*Помещайте возможный максимум логики программы в функции* - операции, которые возвращают результат без наблюдаемых побочных эффектов.
Строго выделяйте команды (приводящие к изменениям в наблюдаемом состоянии) в очень простые операции, которые не возвращают доменную информацию.
(#todo: посмотреть перевод в книге#)
Дальнейший контроль побочных эффектов осуществляется путем переноса сложной логики в объекты ЗНАЧЕНИЙ с концептуальными определениями, соответствующими ответственности.
____

==== Object-Oriented Software Construction (1997), Bertrand Meyer

[quote, Bertrand Meyer, "Object-Oriented Software Construction, section 23.1 SIDE EFFECTS IN FUNCTIONS"]
____
The first question that we must address will have a deep effect on the style of our designs.
Is it legitimate for functions — routines that return a result — also to produce a side effect, that is to say, to change something in their environment?

*The gist of the answer is no*, but we must first understand the role of side effects, and distinguish between good and potentially bad side effects.

Первый вопрос, на который мы должны ответить, окажет глубокое влияние на стиль наших дизайнов.
Законно ли, чтобы функции — подпрограммы, возвращающие результат, — также производили побочный эффект, то есть изменяли что-то в своей среде?

*Суть ответа - нет*, но сначала мы должны понять роль побочных эффектов и провести различие между хорошими и потенциально плохими побочными эффектами.
____

---

Следующим косвенным доказательством преимущества ФП-стиля является тот факт, что большинство его адептов, ранее на "тёмной стороне".

=== ФП-перебежчики

Наиболее яркими, на мой взгляд, представителями людей слишком слабых духом для императивного программирования являются Роберт Мартин и Рич Хикки.

Мартин - человек, чьё имя приходит на ум первым после слов "объектно-ориентированный дизайн" или "чистый код" - десять лет назад https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html[перешёл с C++ на Clojure] и теперь пишет https://blog.cleancoder.com/uncle-bob/2021/11/28/Spacewar.html[посты-оды функциональному стилю] и книги по функциональному дизайну.

Рич Хикки некогда был адвокатом C++, но в итоге настолько https://dl.acm.org/doi/pdf/10.1145/3386321[устал от проблем, вызванных императивным стилем], что сделал свой собственный https://clojure.org/[функциональный язык] с персистентыми структурами данных и примитивами безопасного конкурентного программирования, свою собственную https://www.datomic.com/[функциональную СУБД] и свою собственную https://docs.datomic.com/cloud/ions/ions.html[модель функционального программирования].
И это всё не академические изыскания - https://clojure.org/community/success_stories[Clojure активно используется в коммерческой разработке] (хотя масштаб использования не сопоставим с Java/C#/Kotlin и т.д., конечно же).

=== ФП в технологиях

Технологии, в частности языки программирования и фреймворки, призваны сделать разработку програм дешевле.
И сейчас наблюдается отчётливый тренд увеличения процента технологий, базирующихся на принципах ФП.

Следовательно, можно предположить, что эти принципы помогают авторами удешевить разработку программ на базе их технологий.

Единственный [line-through]#популярный# известный мне язык родом из этого века, который не подерживает ФП - Go.
Все остальные - Kotlin, Swift, Rust - поддерживают.
Естественно, я не говорю о целом ворохе чисто функциональных языков программирования.

И сейчас даже Java семимильными шагами идёт в сторону ФП стиля - записи, закрытые иерархии, паттерн матчинг, лямбды в конце концов.

А GUI-фреймворки, некогда бывшие вотчиной ООП, в XXI веке все как один - https://react.dev/[React], https://developer.apple.com/xcode/swiftui/[SwiftUI], https://developer.android.com/jetpack/compose[Jetpack Compose] - (ну ладно, основные для наиболее используемых платформ - Web, Android, iOS) предлагают функциональную модель.

== Вероятная причина низкой стоимости ФП-программ

Чем может быть обусловлено снижение стоимости разработки программ при использовании функционального стиля?
Я полагаю - простотой понимания.

При работе с понятной программой, разработчику требуется меньше времени (=денег) на её изучение, для того чтобы внести требуемые правки.
А в результате изучения понятной программы больше вероятность понять программу *правильно* и, как следствие, внести меньше ошибок (=денег) при её модификации.

Но понятность кода во многом является субъективной метрикой - разработчику проще понять код, если он состоит из привычных для него идиом.

Однако есть две области, которые строят точные модели программ - формальная верификация программ и оптимизирующие компиляторы.
И для обеих областей подпрограммы, написанные в функциональном стиле, являются объективно более понятными ([https://dl.acm.org/doi/pdf/10.1145/130943.130947[1]], [https://queue.acm.org/detail.cfm?ref=rss&id=2611829[2]]).

== Заключение

Итого, мы имеем следующие факты:

. Учёный с мировым именем утверждает, что у него были эмпирические данные, свидетельствующие о том, что дешёвые программы имеют структуру, которая чрезвычайно напоминает функциональную архитектуру;
. Множество экспертов-практиков со страниц своих книг призывают возможный максимум кода выносить в чистые функции;
. Множество экспертов-практиков переходят с императивного стиля на функциональный;
. Множество вендоров включают принципы функционального подхода в основу своих технологий;
. Программы написанные в функциональном стиле проще верифицировать и оптимизировать.

Достаточно ли этих фактов, для доказательства истинности Гипотезы?
Для меня - да.
