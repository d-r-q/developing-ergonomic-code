---
title: "Рациональный подход к декомпозиции систем на модули или микросервисы"
description: "Рациональный подход к декомпозиции систем на модули или микросервисы"
date: 2023-03-04T01:25:37+07:00
draft: false
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font
:sectlinks:
:imagesdir: /drafts/effects-diagram/images

[NOTE]
--
Следить за обновлениями блога можно в моём канале: https://t.me/ergonomic_code[Эргономичный код]
--

== Чего от разработки ПО хотят разработчики, продакты и владельцы бизнеса?

Одного и того же - побольше дофаминчика (гормон счастья), поменьше кортизольчика (гормон стресса).
При том источники и дофамина, и кортизола у них одни и те же.
Дофамин вырабатывается, когда фичи выпускаются в срок и без багов, а кортизол - когда сроки срываются и вылазят баги и регрессии.
Бизнесу будет ближе финансовая версия - срыв сроков и баги очевидным образом приводят к увлечению стоимости разработки.
Что приводит к выбросу кортизола уже у владельцев.

== Как обеспечить высокий уровень дофамина всей команды?

Для того чтобы поддерживать высокий уровень дофамина и низкий уровень кортизола у всех участников процесса, нам необходимо декомпозировать системы на модули.
Декомпозиция помогает обеспечить высокую скорость и качество разработки за счёт:

* Ограничения объёма кода, который необходимо изучить и адаптировать к изменениям в требованиях;
* Исключения конфликтов при параллельной разработке независимых функций системы;
* Создания возможности независимого выпуска и развёртывания отдельных функций системы.

Однако, этого можно достичь, только в том случае, если получившиеся модули обладают высокой функциональной связанностью и низкой сцепленностью.

(#todo: картинка#)

Кроме того, для максимизации [line-through]#выброса дофамина# скорости разработки и минимизации [line-through]#выброса кортизола# стоимости разработки, необходимо чтобы сама работа по декомпозиции системы проходила быстро и давала качественные результаты.

== Как обеспечить высокий уровень дофамина всей команды при выполнении декомпозиции?

А для того чтобы эта работа проходила быстро и давала качественные результаты, необходимо, чтобы она была структурирована и стандартизирована.
Таким образом необходим некий рациональный подход к декомпозиции.
И тут в нашей индустрии проблемы.

По моему опыту, в ВУЗах декомпозиции либо не обучают совсем, либо обучают монструозным и фактически устаревшим методологиям вроде RUP-а.
А по мнению Джона Остерхаута в США дела обстоят так же:

[quote, John Ousterhout , A Philosophy of Software Design]
____
Problem decomposition is the central design task that programmers face every day, and yet, other than the work described here, I have not been able to identify a single class in any university where problem decomposition is a central topic.
We teach for loops and object-oriented programming, but not software design.

Декомпозиция - это центральная задача проектирования, с которой программисты сталкиваются каждый день, и все же, кроме работы, описанной здесь, я не смог определить ни одного курса ни в одном университете, где декомпозиция является центральной темой.
Мы учим циклам и объектно-ориентированному программированию, но не проектированию ПО.
____

Из-за этого, в большинстве команд, которые я видел в последние годы, проектирование и декомпозиция заключалась в паре часов несистематизированного рисования прямоугольников и стрелок одним-двумя разработчиками.
А полноценное проектирование и декомпозицию я видел в последний раз в 2005 году и они заняли несколько месяцев.

Для того чтобы обеспечить высокий уровень дофомина и на этапе проектирования и декомпозиции и на этапе последующей реализации, нам необходим подход к декомпозиции, который:

. Вообще есть;
. Прост в изучении;
. Прост в исполнении;
. Даёт хорошие результаты вне зависимости от исполнителя;

Это и будет тем самым рациональным подходом к декомпозиции, который нам необходим.

== А что не так с классикой?

(#todo: дополнить пост материалом об анкл бобе#)

У опытного разработчика, тут может возникнуть вопрос: "Как это нет подхода к декомпозиции? А как же слоёная архитектура? Чистая архитектура? DDD, в конце концов?".
Я изучил все эти и много других подходов к декомпозиции начиная с 60-ых годов, многое взял себе, но не один из этих подходов мне не удалось положить на каждодневную практику.

Подробно основные существующие подходы я рассмотрел в link:++{{<ref "posts/22/08/ergonomic-decomposition">}}++[отдельном посте] и здесь приведу только причины, по которым мне они не подошли:

. Декомпозиция по слоям не масштабируется и даёт плохие результаты с точки зрения связанности и сцепленности;
. Декомпозиции по фичам и компонентам плохо описаны, и при попытке их применения возникает множество вопросов, на которые у источников нет ответов.
  Я нашёл эти ответы самостоятельно и у меня получился подход к декомпозиции на базе эффектов;
. DDD сложен и в изучении, и применении.
  Мне не разу ни удалось "продать" DDD хотя бы РП, фронт-разработчикам, аналитикам и QA-инженерам в собственной команде.
  Кроме того, наличие "на борту" экспертов предметной области, критически важное для DDD, в моей практике является скорее исключением, чем правилом.
. В работах Роберта Мартина:
.. Принципы пакетирования не содержать инструкции по выполнению декомпозиции;
.. Кричащая архитектура описана в одном пятиминутном посте;
.. Чистая архитектура является вариацией на тему слоёной архитектуры со всеми присущими ей недостатками.

Изучением и апробированием классики я занимался 6 лет - с 2014 до 2020 года.
Так и не найдя внятного ответа на вопрос "Как мне декомпозировать систему?", во второй половине 2020 я начал искать собственный подход к декомпозиции и написал разделы книги о link:++{{<ref "book/ergo#_таблица_эффектов">}}++[таблице эффектов] и link:++{{<ref "book/ergo#_принципы_проектирования_системы">}}++[компонентах] (осторожно, устаревшие и не отредактированные черновики).
К марту 2021 года я придумал link:++{{<ref "posts/21/03/250326-project-decomposiotion">}}++[объединить их в один граф] и в итоге это превратилось в декомпозицию на базе эффектов.

== Декомпозиция на базе эффектов

=== Подход проверен и обоснован научно

Прежде чем перейти к самому подходу, хочу подчеркнуть, что он научно обоснован.
Есть три научных статьи, описывающих такой же по сути подход:

* https://www.researchgate.net/publication/283566310_Improving_Design_Decomposition[Improving Design Decomposition];
* https://www.researchgate.net/publication/326260296_Functional_Decomposition_for_Software_Architecture_Evolution[Functional Decomposition for Software Architecture Evolution];
* https://www.researchgate.net/publication/327229270_Identifying_Microservices_Using_Functional_Decomposition_4th_International_Symposium_SETTA_2018_Beijing_China_September_4-6_2018_Proceedings[Identifying Microservices Using Functional Decomposition].

Я не буду здесь подробно останавливаться на этих статьях - они в открытом доступе и заинтересованный читатель может изучить их самостоятельно - приведу лишь главный с моей точки зрения результат:

[quote, "Shmuel Tyszberowicz, Robert Heinrich, Bo Liu and Zhiming Liu", Identifying Microservices Using Functional Decomposition]
____
The evaluation results give us reasons to believe that our approach identifies microservices in a quality that is comparable to a design done by human software designers.
Our approach, however, achieved the microservices identification much faster and with less effort compared to human developers.
While identifying the microservices was a matter of days for the students at KIT and SWU-RISE, by employing our approach it was a matter of hours.

Результаты оценки дают нам основания полагать, что наш подход выявляет микросервисы, качество которых сравнимо с дизайном, выполненным людьми.
При этом наш подход позволяет выявлять микросервисы гораздо быстрее и с меньшими усилиями по сравнению с выполнением этой работы вручную.
В то время как у студентов KIT и SWU-RISE выявление микросервисов потребовало несколько дней, с использованием нашего подхода это заняло несколько часов.
____

=== Концептуальная модель системы

Для того чтобы применить подход к декомпозиции на базе эффектов, систему необходимо представить в виде графа операций и элементов состояния, связанных эффектами чтения и записи.
После чего процесс декомпозиции фактически сводится к кластеризации этого графа.
Пока что создать полностью автоматический алгоритм кластеризации, который бы давал удовлетворительные результаты, мне не удалось, поэтому кластеризация выполняется вручную.
И так как человеку проще выполнять кластеризацию графа, представленного визуально, я разработал специальную диаграмму, для представления графов эффектов.

Концептуальная модель системы и нотация диаграммы подробно описаны в link:++{{<ref "effects-diagram/specification-html">}}++[спецификации].
Упрощённо же можно считать, что:

* Операции - это эндпоинты REST API;
* Ресурсы - таблицы БД;
* Эффекты записи - SQL INSERT/UPDATE/DELETE запросы;
* Эффекты чтения - SQL SELECT-запросы.

Соотвественно, для построения диаграммы эффектов, надо для каждого метода API добавить на диаграмму по прямоугольнику светло-синего цвета, для каждой таблицы добавить по прямоугольнику тёмно-синего цвета, для каждого запроса модификации данных добавить красную стрелку между соответствующей операцией и ресурсом, а для каждого запроса чтения данных - синюю стрелку.
В результате у вас получится картинка, состоящая из таких элементов:

image::short-notation-example.svg[]

Здесь, очевидным образом, операция "Зарегистрировать пользователя" вносит данные в таблицу "Пользователи", а операция "Аутентифицировать пользователя" считывает данные из этой таблицы.
Процесс построения диаграммы эффектов реального проекта с примерами всех распространённых видов ресурсов и операций описан в посте link:++{{<ref "posts/22/06/220611-true-story-project">}}++[Диаграмма эффектов: пример построения].

Также важно отметить, что все элементы диаграммы эффектов один в один транслируются в код:

. Операции - в методы классов сервисов приложения;
. Ресурсы - в классы сущностей и репозиториев (событий и топиков брокеров сообщений, ДТО и клиентов REST API и т.д.);
. Эффекты - в вызовы методов классов репозиториев в методах классов сервисов.

И вот мы наконец-то можем перейти непосредственно к декомпозиции на базе диаграммы эффектов.

=== Декомпозиция на базе диаграммы эффектов

В основе декомпозиции на базе эффектов лежит несколько простых и хорошо известных идей:

. Ресурсы являются глобальными переменными;
. Между всеми методами, которые взаимодействуют с одним ресурсом, появляется сцепленность через общее окружение (common environment coupling);
. Один из основных методов снижения сцепленности системы в целом - это локализация сцепленности через общее окружение в модулях;
. Запись глобальной переменной порождает большую сцепленность, чем чтение.
. В связях между модулями не должно быть циклов;
. Если модулю сложно дать хорошее имя, отражающее его содержание, это говорит о низкой функциональной связанности модуля.

То, что запись порождает большую сцепленность, чем чтение - может быть не очевидно.
Однако это легко продемонстрировать, если рассмотреть их в контексте многопоточной работы.
Считывать глобальную переменную могут сколь угодно много потоков без какой-либо синхронизации и проблем.
Но, как только кто-то начинает изменять эту переменную, всё тут же становится намного сложнее: теперь надо обеспечить безопасный доступ и не создать дедлок, обеспечить протокол взаимодействия (сначала запись, потом чтение), следить за тем, чтобы операция записи не стала бутылочным горлышком в производительности системы и т.д.

Вооружившись этими идеями, легко определить требования к хорошей декомпозиции (кластеризации) диаграммы эффектов:

. Между кластерами нет циклов;
. Эффекты записи (красные стрелки) инкапсулированы в одном кластере;
. Количество эффектов чтения (синих стрелок), пересекающих границы кластеров, минимально;
. Каждому кластеру легко дать имя, отражающее его содержание.

Для простых диаграмм такая кластеризация может быть видна на глаз.
Примером простой диаграммы является диаграмма эффектов проекта True Story Project:

(#todo: картинка геосервисов#)

Здесь сразу же бросаются в глаза 3-4 кластера:

. Работа с изображениями;
. Формирование фида;
. Интеграция с 2Гис;
. Интеграция с Яндекс.Картами.

Тут хорошо видно, что интуитивная декомпозиция зависит и от разработчика диаграммы (как он расположит элементы) и от наблюдателя - я на этой диаграмме вижу 4 кластера, но некоторые другие люди "автоматически" объединяют интеграции в один модуль.

Для того того, чтобы повысить степень детерминированности результата декомпозиции, я разработал специальный алгоритм.

=== Алгоритм декомпозиции на базе диаграммы эффектов

Алгоритм состоит из двух больших этапов - механистический и гуманистический.
Механистический этап может быть практически полностью автоматизирован и выполняться буквально по шагам.
Но он не всегда может породить полную кластеризацию, а в тех случаях когда может - как правило опытный инженер может доработать получившийся результат в лучшую сторону.

Механистическая кластеризация является итеративной и каждая итерация состоит из трёх этапов:

. Генерация кластеров
. Расширение кластеров
. Агрегация ресурсов

Генерация кластеров заключается в том, чтобы перебрать все некластеризаванные ресурсы и кластеризовать их с операциями, которые:

. Связаны только с этим ресурсом
. Связаны с этим ресурсом своим единственным эффектом записи
. Являются операциями чтения, для которых данных ресурс является первичным.
  Определение первичного ресурса (и вообще его наличия) остаётся на усмотрение исполнителя.

Расширене кластеров заключается в том, чтобы перебрать все некластеризованные элементы, связанные только с c элементами внутри одного кластера и добавить их в этот кластер.

Этап агрегации ресурсов заключается в том, чтобы оставшиеся не кластеризованные ресурсы попытаться объединить в "разумные" группы между собой или с кластеризованными ресурсами.
Строго говоря, на этапе агрегации надо перебрать все возможные попарные соединения и выбрать из них "наилучшие".
Однако на практике "наилучшие" пары как правило имеют общую операцию, поэтому эмпирический алгоритм агрегации выглядит так:

. Для каждого некластеризовнного ресурса, выбрать ресурсы, с которыми у него есть общая операция
. Если в списке есть "разумная" пара данному ресурсу - сгруппировать их.
  Универсального и формализованного критерия разумности я пока что не нашёл, поэтому это решение остаётся за исполнителем.

Далее сгруппированные ресурсы рассматриваются как единое целое, в частности все эффекты связывающие любой из ресурсов этой группы с одной и той же операцией считаются одним эффектом.
Если операцию связывают с группой и эффекты чтения и эффекты записи, то считается что операция связана с группой эффектом записи.

После агрегации ресурсов снова возвращаемся к этапу генерации кластеров.
Если этапы генерации и расширения кластеров не привели к уменьшению количества некластеризованных элементов, то, теоретически, этап агрегации можно снова повторить и продолжать это делать до включения всех оставшихся ресурсов в одну группу.
Однако практически уже на второй последовательной итерации агрегации (когда одина группа некластеризованных ресурсов содержит в себе три базовых) пора становиться на стороже и внимательно смотреть на получающиеся группы ресурсов и связанные с ними и операции и, возможно, вернуться к этапу проектирования самих операций и ресурсов.

Третью итерацию (агрегацию 4ёх ресурсов), на мой взгляд стоит выполнять просто на всякий случай, но сам факт необходимости в ней говорит либо о серьёзных ошибках в дизайне операций и агрегатов (по определению агрегатов, как единиц транзакционности), либо о том, что декомпозиция на базе эффектов не подходит для вашей задачи.

В результате применения этого алгоритма, вы получите либо полную, либо частичную первичную декомпозицию.
Но в любом случае лишь первичная декомпозиция и её надо проверить на соответствие здравому смыслу и, при необходимости - доработать.
И так как здесь приходится работать уже с семантикой и особенностями конкретной предметной области, а машины в "понимании" всё ещё слабы, мы вынуждены перейти к гуманистической и слабо предсказуемой части.

Если механический этап породил частичную декомпозицию, то её придётся завершить вручную.
Очевидным образом, на этом этапе останутся некластеризованными только те элементы, которые связаны с двумя и более кластерами.
И тут для каждого элемента есть несколько вариантов:

. Для некластеризованных операций записи в первую очередь стоит рассмотреть вариант расцепки операции через очередь сообщений.
. Если с одним из кластеров элемент связан бОльшим количеством связей или эти связи кажутся "сильнее" - его можно внести в тот кластер, с которым он сильнее связан.
  В случае операции, тут стоит принять во внимание её клиента (внешнюю сущность, инициирующую выполнение операции) - если с одним из кластеров у неё общий клиент, то связь с этим кластером кажется сильнее;
. Если элемент выглядит связанным со всеми кластерами в равной степени - его можно поместить в собственный кластер.
  В этот же кластер, возможно, можно будет добавить другие элементы связанные с теми же кластерами.
. Если кластеры, связанные элементом имеют высокую функциональную связанность - их все можно объединить в один кластер.
. Если все эти варианты выглядят странно или нелогично - возможно стоит вернуться к дизайну операций и ресурсов.
. Ещё вариант - пересмотреть состав существующих кластеров, возможно тогда получится получить логичную картинку.

После получения полной кластеризации, каждому кластеру необходимо дать имя, отражающее его содержание.
В случае хорошей декомпозиции - это не составит труда.
Если же определить имя какого-то кластера не получается, то необходимо рассмотреть его внимательнее.
Достаточно часто такие проблемы решаются с помощью разделения проблемного кластера на два более мелких и сфокусированных.
Но поиск разумного имени кластера может привести и к редизайну ресурсов и операций.

После того, как каждому кластеру дано разумное имя полезно проделать ещё одно упражнение - нарисовать граф кластеров.
Такая визуализация помогает увидеть "лес за деревьями" и оценить "разумность" уже самого леса.

Наконец, последний шаг, особенно если получилось больше 5 кластеров - найти подмодули и функционально схожие модули.
Подмодуль - это модуль, обеспечивающий работу одного базового модуля.
В этом случае кластер подмодуля необходимо поместить в кластер модуля.
Как понять, что один модуль обеспечивает работу другого?
К сожалению у меня только общие слова.
Посмотрите в сторону уровней абстракции и политик/механизмов.

Функционально схожие модули - это модули, выполняющие разными способами одну и ту же функциональность, либо выполняющие разные подфункции одной общей функции.
Такие модули надо объединить в общий кластер.
Этому кластеру так же надо дать имя и если это вызывает затруднения, то от объединения лучше отказаться.

Наконец, последнее полезное упражнение - провести топологическую сортировку графа модулей.
Это позволит вам определить стабильность модулей (отношение количества входящих зависимостей к количеству исходящих) и убедиться, что техническая стабильность модулей согласована со стабильностью частей предметной области.
(#todo: для этого не надо выполнять сортировку#)

Всё, теперь можно создавать структуру директорий, соответствующую структуре кластеров, в каждой директории создавать по классу сервиса со всеми операциями кластера и по классу репозитрия/клиента/топика для каждого ресурса кластера.
Так же, в целях снижения сцепленности, в сервисы модуля надо будет добавить по методу на каждую стрелку, входящую в кластер.

Теперь рассмотрим процесс выполнения декомпозиции реального проекта.

== Кейс: Кэмп

Примеры в программировании и особенно дизайне - это всегда боль.
Слишком простые или синтетически не особо полезны.
Слишком сложные и реальные - мало кто станет в них вгружаться, и сложно отделить релевантые детали от лишнего шума.
Кэмп явлется на мой взгляд золотой серединой.

https://play.google.com/store/apps/details?id=ru.ngtrans.camp[Кэмп] - реальный проект который стоил семизначную сумму для заказчика и выполнялся командой из 12 человек в пике, бакенд делали два разработчика и сейчас находится в промышленной эксплуатации.
Суммарно на выполнение проекта было затрачено 5500 человеко/часов, из которых 950 - на бакенд.

Но это был экспериментальный проект, который (с согласия заказчика) выполнялся силами исключительно молодых специалистов, а лиды только проводили ревью и помогали консультациями.
Поэтому по фактическому объёму функциональности проект достаточно компактный.

Проект является специализированной геоинформационной системой для водителей-дальнобойщиков.
В отличие от больших ГИС систем вроде Яндекс.Карт он отличается тем, что позволяет найти не просто гостиницу по дороге, а гостиницу где водитель может и сам переночевать и рефрижиратор на 86 "кубов" припарковать.

Соответственно двумя ключевыми сущностями являются водители и "точки" (кафе, заправки, СТО и т.п.).
Точки в систему вносят сами пользователи после предварительной модерации.
С водителями связаны характеристики машин, которые они водят (сейчас - только тип машины и размер колёс), а с точками - характеристики машин, которые они в состоянии обслужить.

Кроме того, в системе реализована система пуш-уведомлений пользователей о новостях приложения, а так же о результатах модерации добавленной точки.

Вся эта функциональность отражена не следующей диаграмме эффектов:

image::camp/camp-effects-orig.drawio.svg[link={imagesdir}/camp/camp-effects-orig.drawio.svg]

Теперь давайте прогоним по этой диаграмме алгоритм декомпозиции на базе эффектов и посмотрим, что получится.

=== Декомпозиция диаграммы эффектов Кэмпа

Для того, чтобы диаграмма лучше помещалась на страницу, я разобью её на две - основную (верхний независимый граф) и уведомления (нижний граф).
Начнём с основой диаграммы.

И так, поехали.
Что у нас там первое?
Надо перебрать все ресурсы и объединить их сильно связанными с ними операциями.
Перебирать будем в "естественном" порядке - сверху вниз, слева на право по связям.

И начнём с ресурса "Сервис отправки СМС".
С ним связана только операция "Запросить OTP", однако она сама связана операциями записи с другими ресурсами, поэтому пока её откладываем.
То же самое с ресурсом "OTP".

Далее идёт ресурс "Токены".
Его мы наконец можем объединить с операцией "Получить токен из логина/пароля" и получить первый кластер (на первом этапе я буду именовать кластера по порядковому номеру их добавлению на диаграмму).
Операция "Получить токен из отп" тоже явно просится в этот кластер, но так как она связана эффектом записи с другим ресурсом мы её пока откладываем.

Далее идёт ресурс "Пользователи".
Только с ним связаны операции "Изменить пользователя" и "Удалить пользователя", а для операции "Получить пользователя" он явно является первичным и она не связана эффектами записи с другими ресурсами.
Объединяем их все в новый кластер.

Затем рассмотрим схожие ресурсы "Типы машин" и "Размер колес", оба ресурса связаны эффектами чтения с двумя операциями и не один из них не выступает первичным для этих операций, поэтому пока что пропустим их.

Далее у нас снова схожая пара ресурсов "Услуги" и "Тэги".
Оба ресурса связаны своим единственным эффектом чтения с операцией "Получить точки".
Объединяем их все в кластер.

Теперь переходим к ресурсу "Точки на карте".
Он явно является первичным для операции "Получить точки", которая уже находится в кластере.
Кроме того, он является единственным ресурсом операции "Создать точку".
Добавляем их в последний созданный кластер.

Остался последний ресурс - "Топик 'Точка промодерирована'".
Связанные с ним операции - "Удалить точку" и "Изменить точку" связаны эффектами записи с другими ресурсами, поэтому этот ресурс пока что оставляем некластеризованным.

На этом первая итерация генерации кластеров заканчивается и у нас получается такая промежуточная кластеризация:

image::camp/camp-effects-orig-main-1.drawio.svg[link={imagesdir}/camp/camp-effects-orig-main-1.drawio.svg]

Далее идёт этап расширения кластеров, на котором все некластеризованные элементы, связанные только с одним кластером надо поместить в этот кластер.
Сейчас у нас таких элементов нет - все они связаны либо с двумя кластерами, либо с кластерами и другими некластеризованными элементами.

Поэтому переходим к следующему этапу - агрегации ресурсов.
Для этого перебираем оставшиеся некластеризованные ресурсы и смотрим есть ли для них "разумная" пара, с которой они связаны общей операцией.
Перебор снова будем делать в "естественном" порядке.

Поэтому снова начинаем с ресурса "Сервис отправки СМС".
Он через операцию "Запросить OTP" связан с ресурсом "OTP".
Образуют ли они "разумную"" группу?
Вообще разумный вопрос.
Связаны они тем, что сервис является механизмом доставки OTP.
Но сам сервис теоретически может использоваться для доставки другой информации, и OTP можно доставлять с помощью других механизмов.
Тем не менее, прямо сейчас все они решают одну конкретную задачу - обеспечение пользователя одноразовым паролем для входа и я решаю агрегировать эти два ресурса.

Затем идёт пара ресурсов "Типы машин" и "Размер колес".
И то и другое является атрибутами машин, поэтому их я тоже решаю агрегировать.

И у нас остался последний, некластеризованный ресурс - "Топик 'Точка промодерирована'".
Он через операции "Удалить точку" и "Изменить точку" связан с ресурсом "Точки на карте" и является механизмом оповещения об изменениях в последнем.
На мой взгляд они формируют разумную группу и этот ресурс можно занести в кластер.

После выполнения всех этих агрегаций, у нас получается следующий этап кластеризации:

image::camp/camp-effects-orig-main-2.drawio.svg[link={imagesdir}/camp/camp-effects-orig-main-2.drawio.svg]

Теперь заходим на вторую итерацию, однако некластерезованных ресурсов у нас уже не осталось, поэтому переходим сразу к этапу расширения кластеров.

На этом этапе, мы очевидным образом заносим операцию "Запросить OTP" в первый кластер, а операции "Удалить точку" и "Изменить точку" - в третий.

После этого у нас остаётся один некластеризованный элемент - операция "Получить токен из отп":

image::camp/camp-effects-orig-main-3.drawio.svg[link={imagesdir}/camp/camp-effects-orig-main-3.drawio.svg]

Эта операция связана двумя эффектами записи с разными кластерами, поэтому механестически её кластеризовать не получится и надо переходить к гуманистической части.

Однако, напомню, из-за ограничений размера страницы у нас остался не кластеризованным граф уведомлений.
Поэтому давайте сначала кластеризуем его и закончим с мехнестической частью.

image::camp/camp-effects-orig-notifications-0.drawio.svg[link={imagesdir}/camp/camp-effects-orig-notifications-0.drawio.svg,height=500]

И так, на суку висит мочало, начинаем всё сначала.
А именно - объединяем ресурсы с операциями, которые связаны только с ним.

Начнём с ресурса "Сервис отправки Push-уведомлений".
С ним связано две операции, но под критерии текущего этапа подходит только одна - "Создать персональные уведопления".
Объединяем их в кластер.

Далее идёт ресурс "Уведомления".
С ним связаны пять операций - "Создать новостное уведомление", "Создать персональные уведомления", "Удалить уведомление", "Получить список новостных уведомлений", "Получить список персональных уведомлений".
Первые две отбрасываем, так как они связаны эффектом записи с другим ресурсом.
А вот остальные операции подпадают под наши критерии (для "Получить список персональных уведомлений" ресурс является первичным).
Объединяем их в кластер.

Наконец остаётся только ресурс "Прочитанные уведомления", который однозначно кластеризуется с "Прочитать уведомление":

image::camp/camp-effects-orig-notifications-1.drawio.svg[link={imagesdir}/camp/camp-effects-orig-notifications-1.drawio.svg]

На этом первая часть механистического подхода завершается и можно переходить к расширению кластеров.

Но тут мы снова упираемся в проблему.
Эта операция связана с двумя кластерами, один из которых зависит от другого.
Поэтому, чтобы исключить циклы в графе у нас остаётся только вариант подтянуть эту операцию в первый кластер.
Но тогда у нас операции создания уведомлений, изменяющие ресурс уведомлений окажутся в другом кластере.
При том какой из ресурсов этих операций является для них первичным - коллекция уведомлений или пуш сервис - вопрос дискуссионый.
В общем и тут мы снова упираемся в границы механистического подхода и надо переходить к гуманистической части.

Гуманестическую часть я предлагаю начать, с того, чтобы вернуться к основному графу и решить что делать с оставшейся не кластеризованной операцией "Получить токен из отп".
И тут у нас есть целая россыпь вариантов, как поступить с ней:

. Внести в четвёртый кластер.
. Внести в первый кластер.
. Расцепить через очередь сообщений
. Объединить первый и четвёртый кластер и внести туда.
. Операции получения токенов занести в четвёртый и второй кластеры и сделать новый кластер вокруг ресурса "Токены".

image::camp/camp-effects-orig-main-4-variants.drawio.svg[link={imagesdir}/camp/camp-effects-orig-main-4-variants.drawio.svg,height=500]

В целом, все эти варианты имеют право на жизнь.
Но давайте рассмотрим их с точки зрения "тяжести" графа - пусть связь между кластерами синей стрелкой будет стоить одну единицу, а красной - две.
В этом случае вес вариантов выше будет следующий:

. 4
. 3
. 1
. 1
. 5

Вполне предсказуемо, выигрывают варианты 3 и 4, которые исключают эффект записи между кластерами.
Какой вариант выбрать из них?
Я выбираю 4.
Потому что на данном этапе и OTP и сервис отправки смс являются деталями реализации модуля аутентификации:

image::camp/camp-effects-orig-main-4.drawio.svg[link={imagesdir}/camp/camp-effects-orig-main-4.drawio.svg]

Тут у опытного разработчика может включиться "чуйка" и он подумает о том, что если вытащить аутентификационные данные из пользователя в отдельный ресурс и поместить в первый кластер, то сцепленность системы можно ещё уменьшить.
Но выполнение этого я оставлю в качестве упражнения и вернусь к подграфу нотификаций.


Из этой ситуации можно выйти несколькими разными способами:

. Поместить операцию в первый кластер и сказать, что это нормально.
. Объединить первый и второй кластеры и поместить её туда.
  Заодно туда же можно поместить и третий кластер и оставить один большой кластер для уведомлений.

Однако, зная контекст, в этот момент можно обнаружить ошибку в изначальной диаграмме эффектов.

А именно - новостные уведомления, формируются модераторами и отправляются всем пользователям.
А персональные - формируются системой (в ответ на действия модераторв) и отправляются одному пользователю.
Кроме того, хотя система позволяет удалять любые уведомления, фактически удаляются только новостные уведомления.

И если мы эти две штуки расцепим, то улучшим характеристики сцепленности и связанности системы.
Более того, это позволит нам перенести флаг прочитанности персонального уведомления в сам ресурс уведомлений и упростить реализацию:

image::camp/camp-effects-orig-notifications-2.drawio.svg[link={imagesdir}/camp/camp-effects-orig-notifications-2.drawio.svg]

Наконец мы получили полную кластерезацию:

image::camp/camp-effects-orig-clusterization.drawio.svg[link={imagesdir}/camp/camp-effects-orig-clusterization.drawio.svg]

Теперь можно переходить к следующему этапу гуманистической части - именованию кластеров.
На мой взгляд эта задача не представляет труда и название кластеров очевидно:

. Аутентификация.
. Пользователи.
. Машины.
. Точки.
. Новостные уведомления.
. Персональные уведомления.

Переходим к следующему этапу - отрисовка графа кластеров:

image::camp/camp-effects-orig-clusters-graph.drawio.svg[link={imagesdir}/camp/camp-effects-orig-clusters-graph.drawio.svg]

== Ограничения подхода к декомпозиции на базе эффектов

Основное ограничение подхода заключается в том, что он всё ещё находится на стадии опытной эксплуатации и максимальный размер проекта, который я по нему декомпозировал составляет один человеко-год.

С точки зрения типа и характера задач, подход на базе эффектов хорошо подходит для декомпозиции систем с богатым состоянием и правилами его изменения.
Если же в системе состояния как такого не много - компилятры, например, или системы потоковой обработки информации, ток декомпозировать такую систему на основе эффектов не получится.

== Характеристики подхода к декомпозиции на базе эффектов

Итак, для того чтобы максимизировать количество дофамина и минимизировать количество кортизола в команде, на нужен подход к декомпозиции, который обладает следующими характеристиками:

. Вообще есть;
. Прост в изучении;
. Прост в исполнении;
. Даёт хорошие результаты вне зависимости от исполнителя;

Обладет ли подход к декомпозиции на базе эффектов этими характеристиками?

Он безусловно есть.
Возможно пока что описан не идиально, но я продолжу работы в этом направлении.

Для меня он существенно проще в изучении и исполнеии чем DDD.
Является ли он таковым для вас - судить вам.
Вы можете попробовать его применить в своём проекте или его небольшой части - это займёт не много времени, и вне зависимости от результатов поможет вам лучше понять свою систему.
По моему опыту трудозатраты на декомпозицию на базе эффектов идут в соотношении 1-2 человеко/часа проектирования к 1 человеко-месяцу разработки.
Соответсвенно, со скидкой на отсутсвие опыта, на декомпозицию проекта на 2 человеко-месяца вам должно хватить одного человеко-дня.

Наконец, результаты декомпозиции на базе эффектов всё-таки зависят от исполнителя, но в меньшей степени, чем интуитивная декомпозиция или декомпозиция на базе границ в языке предметной области.
