---
title: "Гарантия отправки \"ровно один раз\""
date: 2023-06-02T08:25:37+07:00
draft: false
---
:icons: font
:sectlinks:

[NOTE]
--
Этот материал является "микропостом" - текстом, написанным в режиме потока сознания без особой редактуры.

Следить за обновлениями блога можно в моём канале: https://t.me/ergonomic_code[Эргономичный код]
--

В Проекте Э, мы интегрируемся с внешней системой, отправляя туда часть записей дневника пользователя по протоколу MQTT.
И коллеги попросили делать это ровно один раз.
Что невозможно в нашей вселенной.

Я написал для них обоснование невозможности выполнить их просьбу и решил это оформить в микропост в блог.

Строго говоря обеспечить обеспечить гарантию доставки “ровно один раз” невозможно.
Доказать невозможность обеспечения этой гарантии проще всего через приведение её к задаче https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%B4%D0%B2%D1%83%D1%85_%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D0%BB%D0%BE%D0%B2[двух генералов], неразрешимость которой формально доказана в статье https://ru.wikipedia.org/wiki/%D0%9B%D1%8D%D0%BC%D0%BF%D0%BE%D1%80%D1%82,_%D0%9B%D0%B5%D1%81%D0%BB%D0%B8[Лесли Лэмпорта] (корифея теории распределённых систем, лауреата премии Тюринга) https://lamport.azurewebsites.net/pubs/solved-and-unsolved.pdf[“Solved Problems, Unsolved Problems and Problems in Concurrency”], опубликованной в журнале Association for Computing Machinery - одном из старейших и уважаемых научных сообществ в области информатики.

Если упрощенно и переводя на наши реалии, мы не в состоянии выяснить причину отсутствия подтверждения получения события - проблемы с передачей сообщения (в случае чего отправку надо повторить) или задержка в обработке или проблемы с передачей подтверждения (в случае чего отправку повторять не надо).

Подробно и на русском доказательство описано в этой https://ru.hexlet.io/blog/posts/exactly-once[статье].

Однако и сам MQTT предлагает гарантию доставки ровно один раз и в сети можно найти статьи, описывающие такую гарантию (https://exactly-once.github.io/posts/exactly-once-delivery/[1], https://ably.com/blog/achieving-exactly-once-message-processing-with-ably[2], https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/[3], https://www.eejournal.com/2015/05/28/is-exactly-once-delivery-possible-with-mqtt/[4]).

Но если вчитаться в эти статьи, то они все опираются на то, что в случае сбоя отправка выполняется множество раз, но получатель выполняет дедупликацию на своей стороне.

И даже если предположить, что MQTT может гарантировать (хотя он гарантирует это только в случае сетевых сбоев, но не https://github.com/eclipse/paho.mqtt.c/issues/522#issuecomment-414636745[в случае сбоев постоянного хранилища] клиента или сервера), что сообщение уровня протокола будет доставлено один раз, мы со своей стороны не можем гарантировать отправку ровно одного MQTT-сообщения.

Проблема в том, для того чтобы гарантировать отправку всех событий, нам необходимо повторять отправку до тех пор, пока мы у себя в БД не пометим сообщение как отправленное.
Однако в распределенной системе может случиться такая последовательность:

* Сервер отправляет сообщение;
* MQTT выполняет успешную доставку и сообщает об этом серверу;
* Сервер пытается отметить сообщение отправленным в БД;
* Происходит сбой БД;
* После восстановления работы БД, сервер не знает по какой причине помечено осталось не отправленным - сбой в доставке или сбой в пометке отправленным.

Обычно дедупликацию делают на стороне получателя, но если получатель предоставит нам АПИ для проверки наличия у них события по идентификатору, мы сможем при повторной отправке выполнить дедупликацию на своей стороне.
