<!doctype html><html lang=en-en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Aleksey Zhidkov"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Aleksey Zhidkov"><meta property="og:title" content="The Many Faces of the Single Responsibility Principle - Aleksey Zhidkov"><meta property="og:description" content="The single responsibility principle? Which one do you mean, exactly?"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/en/posts/21/06/210626-srp-interpretations/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/en/posts/21/06/210626-srp-interpretations/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/en/posts/21/06/210626-srp-interpretations/><title>The Many Faces of the Single Responsibility Principle - Aleksey Zhidkov</title><link rel=canonical href=https://azhidkov.pro/en/posts/21/06/210626-srp-interpretations/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/en/index.xml type=application/rss+xml title="Aleksey Zhidkov"><link href=https://azhidkov.pro/en/index.xml rel=feed type=application/rss+xml title="Aleksey Zhidkov"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/en/>Aleksey Zhidkov</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>The Many Faces of the Single Responsibility Principle</h1><h2 class=date>June 21, 2021</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>You can follow the blog’s updates in my channel: <a href=https://t.me/ergonomic_code>Ergonomic code (rus)</a></p></aside><p>It feels like any solid software engineer knows of SOLID in general and the single-responsibility
principle (SRP) in particular.</p><details><summary>In case you don’t…​</summary><div class=content><p>The SOLID is a set of principles guiding object-oriented design.
It was put together by Robert Martin, who’s also known as Uncle Bob.
These principles go as follows:</p><div class="olist arabic"><ol class=arabic><li><span class=big><strong>S</strong></span>ingle Responsibility Principle: A module should have one, and only one, reason to change.</li><li><span class=big><strong>O</strong></span>pen/Closed Principle:: A software artifact should be open for extension but closed for modification.</li><li><span class=big><strong>L</strong></span>iskov Substitution Principle:: What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T</li><li><span class=big><strong>I</strong></span>nterface Segregation Principle:: Clients should not be forced to depend upon interfaces that they do not use.</li><li><span class=big><strong>D</strong></span>ependency Inversion Principle::<ol class=upperalpha><li>High level modules should not depend upon low level modules. both should depend upon abstractions.</li><li>Abstractions should not depend upon details. details should depend upon abstractions.</li></ol></li></ol></div></div></details><p>Whenever someone mentions SRP, I always ask to specify which one.
That’s because with SRP, there are at least five different formulas with three interpretations.
I don’t really see how such a…​ thing can make a good software development guideline.</p><section class="doc-section level-1"><h2 id=_srp_formulas>SRP formulas</h2><p>First off, let’s see the most popular formula—albeit a wrong one:</p><div class=quote-block><blockquote><p>A class should only do one thing</p><footer>— <cite>they say</cite></footer></blockquote></div><p>Well, the principle per se certainly exists.
It’s one of the principles guiding Linux philosophy.
However, Martin himself says in his "Clean Architecture" that it has nothing to do with SRP:</p><div class=quote-block><blockquote><p>It is too easy for programmers to hear the name and then assume that it means that every module should do just one thing.</p><p>Make no mistake, there is a principle like that. […​]
But it is not one of the SOLID principles — it is not the SRP.</p><footer>— <cite>Robert C. Martin, Clean Architecture</cite></footer></blockquote></div><hr><p>Martin himself has provided three formulas for SRP:</p><div class=dlist><dl><dt>The 2003 formula</dt></dl></div><div class=quote-block><blockquote><p>The Single Responsibility Principle (SRP) states that a class or module should have one, and only one, reason to change</p><footer>— <cite>Robert C. Martin, Agile software development Principles Patterns and Practices</cite></footer></blockquote></div><div class=dlist><dl><dt>The 2014 formula</dt></dl></div><div class=quote-block><blockquote><p>Gather together the things that change for the same reasons.
Separate those things that change for different reasons.</p><footer>— <cite>Robert C. Martin, The Single Responsibility Principle</cite></footer></blockquote></div><div class=dlist><dl><dt>The 2018 formula</dt></dl></div><div class=quote-block><blockquote><p>A module should be responsible to one, and only one, actor</p><footer>— <cite>Robert C. Martin, Clean Architecture</cite></footer></blockquote></div><p>To understand what these three have in common, I had to give three reads to every single piece Martin has
ever written on SRP.
You’ll save yourself a day or two and get the same answer in 15 minutes if you make it to the end of
this post.</p><p>Let’s start with looking at how Uncle Bob has been explaining SRP for the last 20 years.</p></section><section class="doc-section level-1"><h2 id=_srp_explanations>SRP explanations</h2><p><strong>Agile software development Principles Patterns and Practices, 2003</strong></p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Fun fact: SRP was formulated eight years later than the other SOLID principles.
The initial order was different and looked like OLDI.
The SOLID acronym was coined not by Uncle Bob, but by Michael Feathers.</p></aside><p>The SRP makes it first appearance in the <a href=https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445>Agile software development Principles Patterns and Practices</a>.
In this book, Martin explains it with separating the code based on what it’s responsible for in the system:</p><div class=quote-block><blockquote><p>Consider the bowling game from Chapter 6.
For most of its development the Game class was handling two separate responsibilities.
It was keeping track of the current frame, and it was calculating the score.
In the end, RCM and RSK separated these two responsibilities into two classes.
The Game kept the responsibility to keep track of frames, and the Scorer got the responsibility to calculate the score. (see page 85.)</p><footer>— <cite>Robert C. Martin, Agile software development Principles Patterns and Practices</cite></footer></blockquote></div><p><strong>Clean Code, 2008</strong></p><p>Martin keeps explaining the basic idea of SRP as separating the code based on its responsibilitiesZZ in his <a href=https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882>Clean Code</a>:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SuperDashboard</span> <span class=kd>extends</span> <span class=nc>JFrame</span> <span class=kd>implements</span> <span class=nc>MetaDataUser</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=nc>Component</span> <span class=nf>getLastFocusedComponent</span><span class=o>()</span>
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>setLastFocused</span><span class=o>(</span><span class=nc>Component</span> <span class=n>lastFocused</span><span class=o>)</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getMajorVersionNumber</span><span class=o>()</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getMinorVersionNumber</span><span class=o>()</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getBuildNumber</span><span class=o>();</span>
<span class=o>}</span></code></pre></div><div class=quote-block><blockquote><p>The seemingly small SuperDashboard class in Listing 10-2 has two reasons to change.
First, it tracks version information that would seemingly need to be updated every time the software gets shipped.
Second, it manages Java Swing components (it is a derivative of JFrame, the Swing representation of a top-level GUI window)</p><footer>— <cite>Robert C. Martin, Clean Code</cite></footer></blockquote></div><p><strong>The Clean Coder, 2011</strong></p><p>Next, in his
<a href="https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073/ref=pd_sim_5/131-9122726-9479409?pd_rd_w=0NdTd&pf_rd_p=d88e414a-c661-4436-b6ed-003c19da9b92&pf_rd_r=6FTHCEPHBC1138C43SJ9&pd_rd_r=28244df1-86a2-478b-85b3-5e3542ecf45b&pd_rd_wg=H5iaV&pd_rd_i=0137081073&psc=1">The
Clean Coder</a>, Uncle Bob explains SRP with separating implementation concerns (that us, the GUI and the
business rules):</p><div class=quote-block><blockquote><p>There is a design principle called the Single Responsibility Principle (SRP).
This principle states that you should separate those things that change for different reasons, and group together those things that change for the same reasons.
GUIs are no exception.</p><p>The layout, format, and workflow of the GUI will change for aesthetic and efficiency reasons, but the underlying capability of the GUI will remain the same.</p><p>[...]</p><p>Design experts have been telling us for decades to keep our GUIs separated from our business rules.</p><footer>— <cite>Robert C. Martin, The Clean Coder</cite></footer></blockquote></div><p><strong>The Single Responsibility Principle, 2014</strong></p><p>In his <a href=https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html>next</a>
piece on SRP, Uncle Bob explicitly uses the "separation of concerns" term:</p><div class=quote-block><blockquote><p>Two years later, Edsger Dijkstra wrote another classic paper entitled On the role of scientific thought. in which he introduced the term: The Separation of Concerns.
[...]
This is the reason we do not put SQL in JSPs.
This is the reason we do not generate HTML in the modules that compute results.
This is the reason that business rules should not know the database schema.
This is the reason we separate concerns.</p><footer>— <cite>Robert C. Martin, https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</cite></footer></blockquote></div><p>Here, we have the first time Martin gives SRP this brand new definition:</p><div class=quote-block><blockquote><p>And this gets to the crux of the Single Responsibility Principle.
This principle is about people.</p><p>When you write a software module, you want to make sure that when changes are requested, those changes can only originate from a single person, or rather, a single tightly coupled group of people representing a single narrowly defined business function.</p><footer>— <cite>Robert C. Martin, https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</cite></footer></blockquote></div><p>Here, he’s talking about separating code by <strong>people behind writing it</strong>.</p><p><strong>Clean Architecture, 2018</strong></p><p>This explanation received its final form in four years, in <a href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164/ref=pd_sim_1/131-9122726-9479409?pd_rd_w=Kj7C7&pf_rd_p=d88e414a-c661-4436-b6ed-003c19da9b92&pf_rd_r=0ZQVJKRJ6VFKKPXGBRJA&pd_rd_r=664e0c37-918c-4613-b12d-6e758d26e96b&pd_rd_wg=DAys9&pd_rd_i=0134494164&psc=1">Clean Architecture</a>:</p><div class=quote-block><blockquote><p>A module should be responsible to one, and only one, actor</p><footer>— <cite>Robert C. Martin, Clean Architecture</cite></footer></blockquote></div><p>Here, an actor is a group of stakeholders—that is, people in some way or another related to the
app and/or engaged in developing it—who share the same needs and wants.</p></section><section class="doc-section level-1"><h2 id=_the_sixth_srp_formula>The sixth SRP formula</h2><p>I think the sixth—mine—SRP formula is far more clear:</p><div class=quote-block><blockquote><p>A module should be responsible for implementing the requirements of just one stakeholder.</p><footer>— <cite>Alexey Zhidkov, The Many Faces of the Single Responsibility Principle</cite></footer></blockquote></div><p>This formula is based around a quite specific concept of a requirement.
I think there are much less conflicting interpretantions to the word "requirement" than there are to
the word "actor."
"Actor" per se isn’t the best word, as it’s usually understood as "the program’s user"—a definition
popularized by the UML.</p><p>In my formula, it’s clear why data storage modules should be separated from data presentation modules.
The former are specified by the DBA, and the latter by the UX designer.
It’s also clear why you should separate the modules responsible for implementing the CFO and COO
responsibilities.
The requirements for these are defined by different people from different departments.</p><p>This formula isn’t perfect as well, though.
First, infrastructure modules will be fulfilling at least two requirements, i.e. the functional and
the quality ones.
Second, I’ve never seen a project that would have the functional and the non-functional
requirements, stakeholder list, and stakeholder relations all clearly written out.</p><p>Neither this SRP formula nor any other one doesn’t provide software engineers with a guide on the
nuts and bolts of how they should be implementing the principle in their everyday work.
Perhaps it would be more useful to break SRP down into multiple down-to-earth recommendations?
For example:</p><div class="olist arabic"><ol class=arabic><li>form a directed acyclic graph of inter-module dependency;</li><li>separate the I/O (GUI included) from the business rules,</li><li>separate the code responsible for different functions of the system,</li><li>write tests.
In your tests, you should only mock external systems and create the system under test manually (as
opposed to with a DI container).</li></ol></div><p>These recommendations don’t require extensive planning ahead with defining the stakeholders and the
requirements.
It’s also easy to see whether you’re following these recommendations when writing your code.</p><p>These are much easier to use in day-to-day work for wider circles of software engineers.
They would also result in a system that’s reliable and easy to maintain.</p><p>I have one more recommendation apart from those listed above.
You should separate the "default library" (the domain) and the "scripts" (functions) of the application.
This is dicussed by both Martin in his Clean Architecture as the separation of entities and
interactors and Evans in his DDD as the separation of application and domain services.
Nether they nor I can provide any objective criteria that could allow to see whether the code
you’re writing adheres to this recommendation.
Therefore, I’m not listing it as a simple and clear one.</p></section><section class="doc-section level-1"><h2 id=_here_we_go_round_the_mulberry_bush>Here we go 'round the mulberry bush</h2><div class=image-block><img src=/posts/21/06/images/years-without-new-srp-version-en.jpg alt="years without new srp version en"></div><p><strong>SOLID relevance, 2020</strong></p><p>The constant change of SRP formulas and interpretantions could be explained with Martin’s own
understanding of SRP changing and evolving.
At first, SRP meant for him that we should separate the code by its responsibilities.
Then it occurred to him that the code should also be separated by implementation concerns.
Finally, Uncle Bob combined both under "people-based" code decomposition.</p><p>This was an excellent explanation of SRP history, all the way until Martin wrote his last post on SRP.
In that post, he went back to concerns-based code decomposition:</p><div class=quote-block><blockquote><p>It is hard to imagine that this principle is not relevant in software.
We do not mix business rules with GUI code.
We do not mix SQL queries with communications protocols.</p><footer>— <cite>Robert C. Martin, https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html</cite></footer></blockquote></div><p>If we take a step back and look at SRP explanation history, it’ll become clear that Uncle Bob keeps
jumping back and forth between these code decomposition criteria:</p><figure class=table-block><figcaption>The history of SRP interpretations</figcaption><table class="frame-all grid-all stretch"><col style=width:11.1111%><col style=width:33.3333%><col style=width:55.5556%><thead><tr><th class="halign-left valign-top">Year</th><th class="halign-left valign-top">Source</th><th class="halign-left valign-top">Decomposition criteria</th></tr></thead><tbody><tr><td class="halign-left valign-top">2003</td><td class="halign-left valign-top">Agile software development Principles Patterns and Practices</td><td class="halign-left valign-top">Responsibilities and<br>a vague actor inkling*</td></tr><tr><td class="halign-left valign-top">2008</td><td class="halign-left valign-top">Clean Code</td><td class="halign-left valign-top">Responsibilities</td></tr><tr><td class="halign-left valign-top">2011</td><td class="halign-left valign-top">The Clean Coder</td><td class="halign-left valign-top">Concerns</td></tr><tr><td class="halign-left valign-top">2014</td><td class="halign-left valign-top">The Single Responsibility Principle</td><td class="halign-left valign-top">Responsibilities, concerns, and actor</td></tr><tr><td class="halign-left valign-top">2018</td><td class="halign-left valign-top">Clean Architecture</td><td class="halign-left valign-top">Responsibilities and actor, +s
concerns to a lesser extent**</td></tr><tr><td class="halign-left valign-top">2020</td><td class="halign-left valign-top">SOLID Relevance</td><td class="halign-left valign-top">Concerns</td></tr></tbody></table></figure><aside class=sidebar><p>* In his Agile software development Principles Patterns and Practices, Martin provides one
more example in the SRP chapter.</p><div class=image-block><img src=/posts/21/06/images/rectangle.png alt=rectangle></div><div class=quote-block><blockquote><p>Two different applications use the Rectangle class.
One application does computational geometry.
It uses Rectangle to help it with the mathematics of geometric shapes.
It never draws the rectangle on the screen.
The other application is graphical in nature.
It may also do some computational geometry, but it definitely draws the rectangle on the screen.</p><footer>— <cite>Robert C. Martin, Agile software development Principles Patterns and Practices</cite></footer></blockquote></div><p>Looking at this example (from 2021), we can conclude that different apps will have different users
(which are one kind of actors) and the draw and area methods serve for implementing the requirements of
different actors.</p><hr><p>** In the Clean Architecture, concerns separation is mentioned as well (the save method
defined by the CTO).
In this book, though, Martin isn’t explicitly discussing the need for concerns-based
decomposition.
Considering the quite unconventional usage of the word "actor," this explanation could be
interpreted as decomposition based on the users alone.
This would be a fourth SRP interpretation, albeit I’ve never encountered it in the wild.</p></aside><p>Responsibilities-based decomposition and implementation concerns-based decomposition aren’t two ways of laying out the same principle.
These are two different principles that lead to different results.</p><section class="doc-section level-2"><h3 id=_separation_of_responsibilities_separation_of_concerns>Separation of responsibilities != Separation of concerns</h3><p>You can separate SQL and JSP and still use the same code in different functions, as well as break
some users' functions while modifying some other users' functions.
Alternatively, you can get each user or each function of the system their own dedicated
microservice, as well as have just one method for json parsing, business rules, and SQL request execution.
You’ll end up with fragile code that’s painful to maintain, though.</p><p>Functionality implementation concerns and functionality per se are orthogonal axes of code decomposition.</p><p>SRP violates one of its own interpretations and mixes together various concerns of software design.
I have zero idea on why Uncle Bob would combine two different principles to make one.</p><p>Perhaps it took Martin himself some time to understand that code should be separated by both
responsibilitity and implementation concerns.
By the time he understood this, the SOLID had already taken off and become a brand no one would want
to lose.</p><p>Can we rely on a principle whose formula and interpretation both change every three years?
I don’t think so.</p></section></section><section class="doc-section level-1"><h2 id=_we_need_new_principles>We need new principles</h2><p>To sum things up:</p><div class=ulist><ul><li>It isn’t quite clear what SRP even is.
Different developers mean different design principles by SRP.
Even Martin himself keep changing the formulas and the examples he’s using to define SRP.</li><li>The Single True Version of SRP I believe in isn’t viable to use in real life projects.
Because in real life projects, no one does the analytics this version would require.</li><li>Even if they did, the SRP ideal would still be an unattainable ideal.
That’s because a significant part of the code will have at least two reasons to change: namely, the
functionality requirements and the implementation method requirements.</li></ul></div><p>Even though SRP is the most questionable SOLID principle, the other four have their fair share
of problems and conflicting readings as well.
Therefore, I don’t think that SOLID as it is can be a good system design guideline.</p><p>Yet still, the SOLID contains quite a lot of good and useful ideas.
That’s why I’m not calling for it to be abolished altogether — I’m suggesting for it to be reinstated.
We should pick out the relevant ideas it contains, make these more specific, and supplement them
with best-practice examples.
Naturally, everything that has now lost its relevance should be deprecated.</p><p>Here’s the most important part: we shouldn’t pigeonhole ourselves by only using those principles
whose first letters can form up a pretty acronym.</p></section></article><br></section></div></main><script src=/js/app.js></script></body></html>