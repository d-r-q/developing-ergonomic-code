<!doctype html><html lang=en-en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Aleksey Zhidkov"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Aleksey Zhidkov"><meta property="og:title" content="The Tests You Can Trust - Aleksey Zhidkov"><meta property="og:description" content="How to devise a testing strategy that'll result in 0 (zero) regressions"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/en/posts/21/03/210321-project-l-testing/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/en/posts/21/03/210321-project-l-testing/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/en/posts/21/03/210321-project-l-testing/><title>The Tests You Can Trust - Aleksey Zhidkov</title><link rel=canonical href=https://azhidkov.pro/en/posts/21/03/210321-project-l-testing/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/en/index.xml type=application/rss+xml title="Aleksey Zhidkov"><link href=https://azhidkov.pro/en/index.xml rel=feed type=application/rss+xml title="Aleksey Zhidkov"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/en/>Aleksey Zhidkov</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>The Tests You Can Trust</h1><h2 class=date>March 13, 2021</h2></header><p>I’m working on a project where I’m the lead back-end developer.
Naturally, I’m trying to keep everything in line with my Ergonomic Approach.</p><p>The code base will be ergonomic if you have a set of tests you can trust.
If the tests pass, it means the build is ready for release.
There’s no other way around this.</p><p>In this post, I’ll talk about the testing strategy I’m using for the 'L' Project.</p><section class="doc-section level-1"><h2 id=_the_l_project>The 'L' Project</h2><p>Since this project is under NDA, I can’t disclose much details.
Here are some key points:</p><div class=ulist><ul><li>The project’s goal is to validate a business hypothesis.</li><li>The 'L' project is supplemental to the client’s main app.
It works via a public HTTP API.</li><li>The project’s main value is concentrated in the front-end.
For that reason, the back-end features just three business rules.</li><li>Most method implementations within the 'L' project pull data from multiple main app methods.</li><li>Therefore, the 'L' project has a quite complex system of data transformation and caching.</li><li>The main app has a test environment.</li><li>The 'L' project is quite limited budget- and time limits-wise.</li><li>I made two major mistakes while analyzing one of the iterations. Therefore, I had to rework and refactor everything twice.</li></ul></div></section><section class="doc-section level-1"><h2 id=_inner_versions_release_cycle>Inner versions release cycle</h2><p>For now, I have the development process organized like this:</p><div class="olist arabic"><ol class=arabic><li>I spend some time writing code.
I’ll probably rework most of the design here.</li><li>I push the code. At the push, the CI tool runs the tests.</li><li>If I forgot to run the tests myself before pushing and the tests failed, I fix the mistakes.</li><li>Once the CI-based tests all pass, it means the internal release is ready.</li></ol></div><p>I don’t do any manual testing whatsoever.
Yet still, two months of development in, we’ve had only 1 (one) bug and 0 (zero) regressions.</p><p>I’ve achieved that by putting the code under 6 types of tests.</p></section><section class="doc-section level-1"><h2 id=_project_modules>Project modules</h2><p>I’ve decided to break the project down into four modules.</p><div class="olist arabic"><ol class=arabic><li>core: the project’s business logic (well, actually, integration logic). It contains the services,
the data model, and the repo interfaces. Moreover, I also put the client implementation for the main
app into this module.</li><li>app: The project’s infrastructure. This module includes Spring, all things database, HTTP, etc.</li><li>itests: HTTP-based tests.</li><li>test-fixtures: the constants and the util functions for all test types.</li></ol></div></section><section class="doc-section level-1"><h2 id=_testing_libraries>Testing libraries</h2><div class=ulist><ul><li><a href=https://junit.org/junit5/>JUnit 5</a>: the de facto standard library for Java testing</li><li><a href=https://kotest.io/docs/assertions/assertions.html>kotest</a>: a Kotlin-tuned assertions library</li><li><a href=https://www.testcontainers.org/>testcontainers</a>: a library for managing Docker containers in
tests</li><li><a href=http://wiremock.org/>WireMock</a>: a tool for mocking servers at the HTTP level</li><li><a href=https://rest-assured.io/>Rest-assured</a> - a DSL for REST services testing.</li></ul></div></section><section class="doc-section level-1"><h2 id=_test_types>Test types</h2><p>I’m using the following test types in this project:</p><div class=ulist><ul><li>Unit testing</li><li>Database testing</li><li>Main app’s API integration testing</li><li>Integration testing</li><li>API testing</li><li>Scenario testing.</li></ul></div><p>In the next step, I’ll also add a bunch of load tests for critical scenarios.</p><p>All tests are labeled with tags, and you can run each group separately.
In practice, though, I created two extra Gradle tasks for running my tests.
The first one, allTest, runs everything apart from scenario tests.
The second one, scenarioTest, runs—you’ve guessed it—the scenario tests only.
The default task, test, runs just the tests with no external dependencies (unit tests, database
tests, and integration tests).</p><section class="doc-section level-2"><h3 id=_unit_tests>Unit tests</h3><div class=dlist><dl><dt>Goal</dt><dd>To check business rules compliance</dd><dt>Interface</dt><dd>Direct method calling</dd><dt>Internal dependencies*</dt><dd>None</dd><dt>External dependencies</dt><dd>None</dd><dt>Number</dt><dd>26</dd></dl></div><p>Due to the project’s character, barely any unit tests are actually used here.
There are three ones that check the business rule compliance and two ones that check up on the main
app’s response parser.</p><p>There are 26 unit tests because one of those business rules is validation.
21 of these all stem from one
<a href=https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests>parameterized
test</a>.</p><p><em>* By internal dependencies, I mean the dependencies the test runs for itself.
By external dependencies, I mean the ones the test is expecting to be running already.</em></p></section><section class="doc-section level-2"><h3 id=_database_tests>Database tests</h3><div class=dlist><dl><dt>Goal</dt><dd>To check the repo implementations</dd><dt>Interface</dt><dd>Direct method calling</dd><dt>Internal dependencies</dt><dd>Postgres (in testcontainers)</dd><dt>External dependencies</dt><dd>None</dd><dt>Number</dt><dd>17</dd></dl></div><p>These tests should validate the SQL expressions to make sure they’re both semantically and
syntactically correct, as well as mapping objects of the &lt;-> rows.
The database for these tests is set up in a container.
The same instance will be used for all tests in the run, though.</p></section><section class="doc-section level-2"><h3 id=_main_apps_api_integration_testing>Main app’s API integration testing</h3><div class=dlist><dl><dt>Goal</dt><dd>To check the main system’s client</dd><dt>Interface</dt><dd>Direct method calling</dd><dt>Internal dependencies</dt><dd>WireMock-powered mock of the main system</dd><dt>External dependencies</dt><dd>The main system</dd><dt>Number</dt><dd>10</dd></dl></div><p>These tests mostly validate the response parsing.
A mock server checks the error handling.</p></section><section class="doc-section level-2"><h3 id=_integration_tests>Integration tests</h3><div class=dlist><dl><dt>Goal</dt><dd>To check the behavior of some large blocks of the system’s core in those cases not covered
by API tests</dd><dt>Interface</dt><dd>Direct method calling</dd><dt>Internal dependencies</dt><dd>Postgres (in testcontainers), WireMock-powered mock of the main system</dd><dt>External dependencies</dt><dd>None</dd><dt>Number</dt><dd>6</dd></dl></div></section><section class="doc-section level-2"><h3 id=_api_tests>API tests</h3><div class=dlist><dl><dt>Goal</dt><dd>These tests are actually meant for four things:<ul><li>They check whether Spring is configurated correctly, especially the controllers and the error
handler.</li><li>They cover all the "happy pass" code of the system and the expected error handling with carpet end-to-end testing.</li><li>They prevent any backward-incompatible changes by freezing the API.</li><li>They generate snippets for <a href=https://spring.io/projects/spring-restdocs>Spring Rest Docs</a>.</li></ul></dd><dt>Interface</dt><dd>addressing the backend through HTTP via RestAssured and a custom client.</dd><dt>Internal dependencies</dt><dd>WireMock-powered mock of the main system</dd><dt>External dependencies</dt><dd>a running app (the backend plus Postgres in docker-compose)</dd><dt>Number</dt><dd>37</dd></dl></div><p>As you can tell by the number alone, I’m mostly relying on API tests when testing the "L" Project.
They test the entire system, covering all the basic "happy passes" and dealing with processing all the
expected errors.
For better backward compatibility control, API tests aren’t dependent on the main app’s modules.
Therefore, there are duplicate URLs and data structures in them.</p><p>There are two kinds of requests—the fixture ones and the control ones.
There’s a dedicated class for executing the fixture requests that presents the backend HTTP
interface as a Kotlin class.
The response to these fixture requests doesn’t get checked.
Control requests are executed via RestAssured.</p></section><section class="doc-section level-2"><h3 id=_scenario_tests>Scenario tests</h3><div class=dlist><dl><dt>Goal</dt><dd>To check the interaction protocols of the frontend and the backend, as well as of the
project’s backend and that of the main app.</dd><dt>Interface</dt><dd>addressing the backend through HTTP via a custom client.</dd><dt>Internal dependencies</dt><dd>None.</dd><dt>External dependencies</dt><dd>a running app (the backend plus Postgres in docker-compose), the main system.</dd><dt>Number</dt><dd>8</dd></dl></div><p>These tests probe the backend in production-like environment:</p><div class=ulist><ul><li>The backend interacts with the main system.</li><li>The tests emulate the frontend’s behavior.</li></ul></div></section></section><section class="doc-section level-1"><h2 id=_mocks_and_stubs>Mocks and stubs</h2><p>I never use mock class libraries, at all.
There are two main reasons behind this.</p><p>On one hand, I don’t trust mock tests.
I have quite a solid working experience with projects that were using mock-based "tests."
They would always have manual testers, who’d always end up finding regressions in seemingly "green" builds.</p><p>On the other hands, mocks are there to test the implementation, not the contract.
That’s why you have to spend as much time rewriting the tests after any refactoring as was spent
actually making that very refactoring.</p><p>Ted Kaminski has a bunch of good articles covering this topic:</p><div class=ulist><ul><li><a href=https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html>The influence
of testing on design</a>: in this one, he discusses the advantages of boundary testing.</li><li><p><a href=https://www.tedinski.com/2018/10/09/relationship-induction-and-tests.html>Testing, induction, and
mocks</a>: in this one, he discusses all the problems caused by mocks.</p><p>I think the most interesting takeaway in the second article is that mocks are quite one-sided.
Mocks say that the system will behave in a certain way.
They never verify that it’s actually behaving in this way in the runtime, though.</p></li></ul></div></section><section class="doc-section level-1"><h2 id=_some_stats>Some stats</h2><p>Some say integration tests take a while to write and run, so I’ll outline some stats I’ve collected down below.</p><div class=dlist><dl><dt>Total endpoints</dt><dd>10</dd><dt>Total tests</dt><dd>104</dd><dt>Local test runtime</dt><dd>~20 seconds</dd><dt>The time it takes to run the CI pipeline on Github Actions</dt><dd>4 to 5 minutes</dd><dt>The relation between the production code and the tests</dt><dd><code>2665 / 3503 = ~3/4</code><br>However, you have to account for these API tests containing pretty heavy JSON response stubs and Spring Rest
Docs-powered docs.</dd></dl></div><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=nf>filter</span><span class=p>(</span>
    <span class=nf>document</span><span class=p>(</span>
        <span class=s>&#34;login-ok&#34;</span><span class=p>,</span>
        <span class=nf>preprocessRequest</span><span class=p>(</span><span class=nf>prettyPrint</span><span class=p>()),</span>
        <span class=nf>preprocessResponse</span><span class=p>(</span><span class=nf>prettyPrint</span><span class=p>()),</span>
        <span class=nf>requestFields</span><span class=p>(</span>
            <span class=nf>fieldWithPath</span><span class=p>(</span><span class=s>&#34;login&#34;</span><span class=p>).</span><span class=nf>description</span><span class=p>(</span><span class=s>&#34;Phone or e-mail&#34;</span><span class=p>)</span>
                <span class=p>.</span><span class=nf>attributes</span><span class=p>(</span><span class=n>credsConstraints</span><span class=p>.</span><span class=nf>constraintsFor</span><span class=p>(</span><span class=s>&#34;login&#34;</span><span class=p>)),</span>
            <span class=nf>fieldWithPath</span><span class=p>(</span><span class=s>&#34;password&#34;</span><span class=p>).</span><span class=nf>description</span><span class=p>(</span><span class=s>&#34;Password&#34;</span><span class=p>)</span>
                <span class=p>.</span><span class=nf>attributes</span><span class=p>(</span><span class=n>credsConstraints</span><span class=p>.</span><span class=nf>constraintsFor</span><span class=p>(</span><span class=s>&#34;password&#34;</span><span class=p>)),</span>
        <span class=p>),</span>
        <span class=nf>responseFields</span><span class=p>(</span>
            <span class=nf>fieldWithPath</span><span class=p>(</span><span class=s>&#34;token&#34;</span><span class=p>).</span><span class=nf>description</span><span class=p>(</span><span class=s>&#34;Authorization token&#34;</span><span class=p>)</span>
                <span class=p>.</span><span class=nf>attributes</span><span class=p>(</span><span class=n>authConstraints</span><span class=p>.</span><span class=nf>constraintsFor</span><span class=p>(</span><span class=s>&#34;token&#34;</span><span class=p>)),</span>
        <span class=p>)</span>
    <span class=p>)</span>
<span class=p>)</span></code></pre></div></section><section class="doc-section level-1"><h2 id=_how_to_fit_tests_into_your_schedule>How to fit tests into your schedule</h2><p>First off, stop thinking of tests as some standalone task when estimating how long the project will take :)
It’s not "one day for a ready-made solution, and one day for running some tests."
It’s "two days for a ready-made solution."</p><p>Second, start with tests.
Well, actually, I’m no advocate of Test-Driven Development.
I’m also against Test-Driven Design.
Still, once I come across a bug or a regression, the first thing I do is conjure up a test that’ll
reproduce the problem.</p><p>The process mostly depends on the feature.
Sometimes I start with an API test, sometimes with a unit tests, and sometimes with no test at all.</p><p>Apart from improving on the development’s speed and quality in the long run, tests are also beneficial
for development performance in the short run, thanks to automating the run and checking the functionality.</p></section><section class="doc-section level-1"><h2 id=_conclusion>Conclusion</h2><p>I couldn’t find the source, but I think somewhere in his "Clean Architecture," Uncle Bob says
something along these lines:</p><div class=quote-block><blockquote><p>"If I had to choose between a system with good architecture and one with good tests, I’d go with the
latter."
If you have tests you can trust, you can fix the architecture.
If there are no tests, you can’t do anything about the system.</p></blockquote></div><p>I wholly agree with that.
Reliable tests are a crucial part of any ergonomic codebase.</p><p>In this project, I’ve had to rework the design twice.</p><div class="olist arabic"><ol class=arabic><li>There was this one time when I had to change the relation between two core entities. It went from
1-N to N-M.</li><li>Second time, I had to make the data load transition from synchronous to asynchronous preload.</li></ol></div><p>Thanks to the testing strategy described above, I managed to implement both of these with no
regressions that could be seen by the client.</p><p><span class=logo><img src=/images/logo.svg alt=logo></span></p></section></article><br></section></div></main><script src=/js/app.js></script></body></html>