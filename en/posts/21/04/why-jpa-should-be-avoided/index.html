<!doctype html><html lang=en-en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Aleksey Zhidkov"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Aleksey Zhidkov"><meta property="og:title" content="Why You Should Avoid Using JPA/Hibernate in Production - Aleksey Zhidkov"><meta property="og:description" content="JPA/Hibernate’s design is causing you to create sluggish & poorly designed software"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/en/posts/21/04/why-jpa-should-be-avoided/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/en/posts/21/04/why-jpa-should-be-avoided/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/en/posts/21/04/why-jpa-should-be-avoided/><title>Why You Should Avoid Using JPA/Hibernate in Production - Aleksey Zhidkov</title><link rel=canonical href=https://azhidkov.pro/en/posts/21/04/why-jpa-should-be-avoided/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/en/index.xml type=application/rss+xml title="Aleksey Zhidkov"><link href=https://azhidkov.pro/en/index.xml rel=feed type=application/rss+xml title="Aleksey Zhidkov"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/en/>Aleksey Zhidkov</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Why You Should Avoid Using JPA/Hibernate in Production</h1><h2 class=date>April 3, 2021</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>You can follow the blog updates in my channel: <a href=https://t.me/ergonomic_code>Ergonomic Code (rus)</a></p><p>22.08.21 edit:</p><div class=ulist><ul><li>Section <a href=#_bad_procedural_programming_style>Bad procedural programming style</a></li><li>Section <a href=#_what_to_do_if_jpa_is_unavoidable>What to do if JPA is unavoidable</a></li><li>Section <a href=#_links>Links</a></li></ul></div></aside><section class="doc-section level-1"><h2 id=_disclaimer_i_passionately_hate_jpa_and_hibernate>Disclaimer: I passionately hate JPA and Hibernate.</h2><p>My relationship with Hibernate (JPA hasn’t yet existed back then) has been rocky from the very beginning.
Somewhere as far back as 2005 or 2007, an interviewer asked me how I’d go about mapping the 1-N relationship with Hibernate.
”I have no idea what Hibernate is,” I said.</p><p>Then in 2008 I got a job at Softage to work on a project based on Swing and Hibernate.
I had zero commercial experience with either, so it seemed to me I was terrible at the job.
I spent a few weeks worrying my head over it and then quit.</p><p>No Java developer can really eschew having to work with JPA altogether, though.
So naturally, I too had to live through with it.
I’ve had to dig up and fix a mountain of bugs and performance issues caused by the coding style JPA enforces.
To do that, I had to understand how JPA works.
Still, I’ll never get back the hours of doing that.
That’s why I hate JPA.</p><p>In this article, I’ve discussed both the facts and my own experience.
It’s up to you to interpret these.</p></section><section class="doc-section level-1"><h2 id=_jpas_philosophy>JPA’s Philosophy</h2><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>To be fair, 90% of my experience with JPA is limited to Hibernate.
I’ve also tried EclipseLink, although it has the very same problems.
So in this article, I’m using JPA and Hibernate almost interchangeably.
However, JPA’s main problems all stem from mutable entities and lazy loading.
These are inherent to its specification, so I doubt it’s possible to completely avoid them.</p></aside><p>Here’s my loose take on JPA’s philosophy: "Forget the database–just declare your own object model. Work with it as if it’s already in the memory in full. We’ll take care about getting all objects saved in the database."</p><p>Perhaps the actual philosophy behind JPA is different–I couldn’t find anything in my research.
However, that’s certainly what the folk version of it sounds like.</p></section><section class="doc-section level-1"><h2 id=_hibernates_simplified_model>Hibernate’s Simplified Model</h2><figure class=image-block><img src=/posts/21/04/en_jpa-model.svg alt="en jpa model"><figcaption>Figure 1. Hibernate’s Simplified Model</figcaption></figure><p>To make the 'Just think all your objects to already be in the memory' promise come true, that’s how Hibernate works:</p><div class="olist arabic"><ol class=arabic><li>The app initiates a transaction via <code>entityManager.getTransaction().begin()</code> (<a href=https://en.wikipedia.org/wiki/Software_transactional_memory>transactions can be stored in memory as well</a>, which doesn’t contradict JPA’s philosophy);</li><li>The app loads the data via entityManager:<ol class=loweralpha type=a><li>EntityManager forms up queries and receives table rows via JDBC-Driver.</li><li>ORM creates proxies for entity objects using these table rows.</li><li>Before passing all the objects on to the app, entityManager saves them into Persistence Context;</li></ol></li><li>The app modifies the objects via setters;<ol class=loweralpha type=a><li>Since these are proxies, though, the setters also mark the objects as dirty on the way.</li></ol></li><li>The app commits the transaction via <code>entityManager.getTransaction().commit()</code>;<ol class=loweralpha type=a><li>Here, the entityManager looks through Persistence Context, then saves or updates all the objects into the database, both dirty and new.</li></ol></li></ol></div><p>Now, it might seem everything’s perfect. Hey mom, no boilerplate code you’d usually need to work with a database!
It’s almost like you could hand this task over to a Java coding bootcamp graduate, and they’d start delivering value from the go.
However, you can only get by with this while working on the very first version of a simple system used by you and your QA.
It’s only when the system gets under any load and starts to evolve you can see this design crumbling.</p></section><section class="doc-section level-1"><h2 id=_jpas_advantages>JPA’s Advantages</h2><p>Everything has both pros and cons.
I must admit there are some bright sides even to JPA.</p><p>With no doubt, it’s the most commonly used database access solution for Java.
This implies three more upsides.</p><div class=ulist><ul><li>There’s a multitude of free JPA learning materials for any level.
As long as you’re writing idiomatic JPA code, you’ll easily find a solution for any problem you might have online.</li><li>It’s easy to hire a developer who’s familiar with JPA. You can just get anyone, and there’ll be a 99% chance they have at least some experience with JPA.</li><li>JPA is supported by everyone and everywhere. For example, Kotlin has made a dedicated <a href=https://kotlinlang.org/docs/no-arg-plugin.html>plugin</a> for JPA compatibility.</li></ul></div><p>What’s more, JPA is using the imperative object-oriented paradigm everyone’s familiar with.
Need someone who can work with JPA? Anyone on the market will fit the bill.
This model is genuinely easy-to-use, and in most cases will help you come up with a perfectly smooth solution.</p><p>Given as an isolated task, JPA can handle saving and loading entity graphs into the database full well.</p><p>JPA is also good at smoothing down the differences between several SQL dialects, which comes handy if your project’s supposed to support multiple DBMSes.
However, this only works as long as you can stick with the lowest common denominator of these dialects.
As a rule, though, every dialect’s best—performance-wise—features are usually unique to it.</p><p>Finally, it’s a solid solution–I can’t recall facing any bugs with Hibernate.</p><p>There are downsides to everything as well, though, and JPA has quite a lot of these.</p></section><section class="doc-section level-1"><h2 id=_jpas_issues>JPA’s issues</h2><p>The root of all JPA’s problems is paradigmatic, not technical.
JPA attempts to make it as if there’s no database at all.
Particularly, it tries to take the developer’s mind off the fact that all changes must be reflected in the database.
Essentially, DMBSes are state mutations managers.
Therefore, JPA has no other choice but to use the imperative programming model.
That’s the only way you can pass a "POJO" to the app and keep track of its state mutations.
So while pursuing this, JPA excludes the more ergonomic declarative model.</p><p>JPA undermines both design and performance.
First, let’s take a look at how JPA can jeopardize software design.</p><section class="doc-section level-2"><h3 id=_classes_must_be_open_for_inheritance>Classes must be open for inheritance</h3><p>JPA requires entity classes to be open for inheritance:</p><div class=quote-block><blockquote><p>The entity class must not be final</p><footer>— <cite>JSR 338: JavaTM Persistence API; Version 2.2; "2.1 The Entity Class"</cite></footer></blockquote></div><p>However, you must either design and document your classes for inheritance or prohibit it.
I’ll quote the classics here: <a href=https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997>Effective Java</a>, chapter "Item 19: Design and document for inheritance or else prohibit it."</p><p>It would take much more effort to design a class for inheritance than to define a data structure with a bunch of fields, as well as setters and getters for these.</p><p>I’ve never seen a JPA Entity designed with inheritance in mind.</p><p>Although JPA’s entity inheritability can cause potential problems, I’ve never encountered any in my experience.</p></section><section class="doc-section level-2"><h3 id=_default_constructors>Default constructors</h3><p>JPA requires that all entity classes include constructors by default:</p><div class=quote-block><blockquote><p>The entity class must have a no-arg constructor.</p><footer>— <cite>JSR 338: JavaTM Persistence API; Version 2.2; "2.1 The Entity Class, " https://github.com/javaee/jpa-spec/blob/master/jsr338-MR/JavaPersistence.pdf</cite></footer></blockquote></div><p>Note that default constructors are an antipattern and a ticking bomb, as they allow for invariant-violating objects.
They also cause <a href=/posts/21/01/210119-effects/#_временная_связность>temporal coupling</a>.
Look <a href=https://blog.ploeh.dk/2011/05/30/DesignSmellDefaultConstructor/>here</a> for more details.</p><p>You can partly avoid this problem by making the default constructor package private and marking it as @Deprecated.</p><p>I’ve never seen anyone but me adhere to this practice, though.</p></section><section class="doc-section level-2"><h3 id=_objects_must_be_mutable>Objects must be mutable</h3><p>JPA can’t work with immutable objects "By Design," and mutability is inherent to its specification:</p><div class=quote-block><blockquote><p>An update to the state of an entity includes both the assignment of a new value to a persistent property or field of the entity as well as the modification of a mutable value of a persistent property or field</p><footer>— <cite>JSR 338: JavaTM Persistence API; Version 2.2; "3.2.4 Synchronization to the Database"</cite></footer></blockquote></div><p>If your entire model is mutable, though, you get all the issues with:</p><div class="olist arabic"><ol class=arabic><li><a href=/posts/21/01/210119-effects/#_временная_связность>temporal coupling (rus)</a>;</li><li><a href=/posts/21/01/210119-effects/#_нелокальность_рассуждений>locality of reasoning (rus)</a>;</li><li><a href=/posts/21/01/210119-effects/#_конкурентное_программирование>concurrent development (rus)</a>.</li></ol></div><p>To minimize its abstraction <a href=https://en.wikipedia.org/wiki/Leaky_abstraction>leaks</a>, JPA needs to make sure an object in memory only corresponds to just one row in the table.
So if instead of mutating an object you create a new instance of it with an updated state, JPA will treat it as a new object. Naturally, it’ll also link it to a new table row.
If you try to save this new instance, JPA will attempt to insert it. This will cause a primary key uniqueness violation.</p><p>You can partly avoid this by making your entities immutable and only ever performing updates with UPDATE queries.
However, this will only work as long as you have to update just one object.
Things get much more complicated if you’re working with an immutable object graph, though. You’ll need to manually write the queries of each type and–manually as well–run the UPDATE queries through the graph.</p></section><section class="doc-section level-2"><h3 id=_bad_procedural_programming_style>Bad procedural programming style</h3><p>The previous two points with addition of several more minor JPA constraints leads to degradation of programming style to procedural.
There are data sturctures without behaviour (JPA entities) and imperative procedures to manipulate them (services).
Welcome to the 1981.</p><p>In seventies classics, like Larry Constantine in <a href=https://archive.org/details/structureddesign00edwa>Structured Design</a>, had discovered universal structure of maintable programs:</p><div class=image-block><img src=/posts/21/04/images/good-module-structure-en.svg alt="good module structure en"></div><p>This structure is still actual in disguise of <a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>Clean Architecture</a> и <a href=https://www.kennethlange.com/functional-core-imperative-shell/>Functional core/Imperative shell</a>.</p><p>However JPA turns it in following structure:</p><div class=image-block><img src=/posts/21/04/images/bad-module-structure-en.svg alt="bad module structure en"></div><p>It’s very difficult to analyze this secret IO.
The difficulty leads to big problems with performance - try to understand count of sql queries executed while request handling, and regressions - try to understand which rows and how will be changed in DB.
Additionally such structures requires usage of mocks in business rules tests (transformation).
And tests with mocks are probing method implementations instead of contracts and breaks after any little refactoring.</p><p>It isn’t relates to JPA directly, but in my practise JPA-developers thinks that they are programming in OO-style and do not study "old junk" such as structured programming and structured design.
As result they are write bad procedural code with low cohesion, high coupling, scopes of decisions effects exceedings scopes of control (see <a href=https://archive.org/details/structureddesign00edwa/page/160/mode/2up>9.4 Scope of effect/scope of control</a>) etc.</p><p>Welcome to the 1981.
I recommend to abstain of usage of go to operator.</p></section><section class="doc-section level-2"><h3 id=_all_code_becomes_side_effect_code>All code becomes side effect code</h3><p>JPA transforms virtually all of your code into side effects code.</p><p>Every getter can get the query executed or start doing so tomorrow.
Every function call can mutate your object and add a new UPDATE request to a transaction.</p><p>You can read more about all the issues that come with side effect code <a href=/posts/21/01/210126-fraud-functions/>here (rus)</a>.</p><hr><p>Let’s now take a look at some performance issues JPA can bring.</p></section><section class="doc-section level-2"><h3 id=_lazy_loading>Lazy loading</h3><p>JPA is big on lazy loading.
It’s the default option for OneToMany and ManyToMany relations. Also, in the JPA world, lazy loading is considered <a href=https://thorben-janssen.com/hibernate-best-practices/#10_Don8217t_use_FetchTypeEAGER>"the best practice</a>."</p><p>I wouldn’t be surprised if lazy loading was responsible for 1 percent of global energy consumption.
Lazy loading was the reason behind 90% of performance issues I’ve had to deal with in JPA-based projects.</p><p>Time and time again, I’d greatly improve on the performance of JPA-based system’s parts with this algorithm.</p><div class="olist arabic"><ol class=arabic><li>Count the number of queries run by the code.</li><li>Your heart will miss a beat once you see a few hundred queries instead of just a few. Get it back in rhythm.</li><li>Throw all your code away. Write a bunch of queries manually. Write new code based off these.</li><li>Voila.</li></ol></div><p>I can only assume here, but I believe that’s what’s usually happening behind the curtains.</p><div class="olist arabic"><ol class=arabic><li>The developer needs to implement a new function ASAP.</li><li>In that part of the code where the new function is supposed to be, there already is an object with a getter returning a list that comprises all the necessary data.</li><li>The developer invokes that getter and loops through it.</li><li><p>In ca. 60% of the time, the developer doesn’t realize that they’re adding a new request by invoking the getter.
By looping through it, they’re adding N more.</p><p>In 30% of the time they do realize that, but brush it off because <a href=https://en.wikiquote.org/wiki/Donald_Knuth>"Premature optimization is the root of all evil."</a></p><p>In 7% of the time they add a new task to the technical debt graveyard.</p><p>Finally, in just 3% of the time they take full responsibility, get the deadline extended, and come up with an effective solution.</p><p>In my experience, I usually have it rougly the same way in JPA projects. In the best-case scenario, I end up with a corresponding 60/0/30/10 percent distribution.</p></li><li>The developer repeats Step no. 3 a few times. Bonus points for using a bunch of nested loops with lazy loading. This way, the number of queries will show exponential growth.</li><li>The developer runs some tests using demo data with just a couple of rows in the table. No problems arise.</li><li>Voila! You’re now free to hire me so that I can fix all these performance issues.</li></ol></div><p>With lazy loading, you must always be on the lookout.
Every time you write something like <code>entity.getXXXs</code>, ask yourself whether this may cause a <a href=https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping>N+1 request</a> to pop up there.
Personally, I lack the self-discipline for that.</p><p>Speaking about lazy loading, we must also mention the infamous LazyInitializationException.
I still keep stumbling upon it in production apps so often you’d be surprised.</p><p>Finally, here’s a problem unique to JPA: it doesn’t offer convenient means to dynamically manage lazy loading.
You could use <code>NamedEntityGraph</code> in some cases. It’s quite cumbersome, though, so you’d be really tempted to get back to lazy loading.</p></section><section class="doc-section level-2"><h3 id=_you_need_an_extra_query_to_refresh_entities>You need an extra query to refresh entities</h3><p>This issue is similar the <a href=#_objects_must_be_mutable>immutable objects one</a> mentioned above. You’ll face it once you need to refresh an entity based off a external DTO, e.g. one you got in a HTTP request.
There are two ways to do this in JPA.</p><div class="olist arabic"><ol class=arabic><li>The idiomatic way: run an extra SELECT query to put the object into PersistenceContext and mutate it.</li><li>The efficient way: use UPDATE again.</li></ol></div><p>The first way seems questionable from the efficiency standpoint.
The second one looks like you’re fighting the framework.
Wasn’t it supposed to make your life easier?</p><p>In theory, you could also store your entities in a HTTP session.
However, in the horizontal scaling era, this option is better left in theory.</p></section><section class="doc-section level-2"><h3 id=_you_need_an_extra_query_to_reference_an_entity>You need an extra query to reference an entity</h3><p>Here’s the third problem that stems from the very same root.
Let’s say you need to create a new entity that references an existing one with a known ID.
There are two ways to do that in JPA: you can either run an extra query–thus sacrificing performance–or fight JPA.</p></section><section class="doc-section level-2"><h3 id=_caching>Caching</h3><p>Basically, you can’t cache JPA entities.</p><p>If your entities have setters, they’ll be uncacheable, just because you won’t be able to synchronize the concurrent access to them.</p><p>Even if your JPA entities are immutable, being cached, they’ll turn useless once the transaction they were loaded into gets closed.
You’ll still be able to access the data within it, but you won’t be able to reference it.</p><p>Finally, for an entity with lazy fields, you’ll eventually get the LazyInitializationException.</p><hr><p>I’m sure this list will go on and on.
For now, I’ve just touched the very tip of the iceberg here.</p><p>It seems like JPA can be used without having to sacrifice either design or performance.
You’ll need to abandon writing idiomatic code, though, which eliminates all the advantages of using JPA.
This approach barely gets talked about, if ever, so learning materials are scarce.
Virtually all developers aren’t familiar with it, and maintenance can get tricky.</p><p>So naturally, we come to the question whether it’s worth it if we’re prioritizing design and performance for our system.
If the answer’s "no," what could be the possible alternatives?</p></section></section><section class="doc-section level-1"><h2 id=_jpa_alternatives>JPA Alternatives</h2><p>All the issues outlined above aren’t inherent to object relational mapping per se.
These problems are inherent to a very specific approach towards ORM.
They are but a natural consequence of it trying to emulate the work with objects within memory.</p><p>Other solutions exist where you don’t need to sacrifice design and performance for the sake of idiomatic code.
Some of these resemble JPA.</p><section class="doc-section level-2"><h3 id=_spring_data_jdbcr2dbc>Spring Data Jdbc/R2dbc</h3><p><a href=https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#reference>docs.spring.io/spring-data/jdbc</a></p><p>Right now, I prefer working with databases via Spring Data Jdbc/R2dbc (SDJ).</p><p>This technology can tick some of the boxes that are commonly thought to be unique to JPA:</p><div class="olist arabic"><ol class=arabic><li>Those developers who are familiar with Spring Data JPA already know most of SDJ.</li><li>It’s still the good old Spring Data tech that can automagically generate implementations for methods such as <code>findByName(name: String)</code>.</li><li>It’s a 'reliable solution from a trusted vendor,' which makes it easier to sell to your client or CTO than other alternatives.</li></ol></div><p>Nonetheless, SDJ is quite ergonomic by design:</p><div class=quote-block><blockquote><p>Spring Data JDBC aims to be much simpler conceptually, by embracing the following design decisions:</p><div class=ulist><ul><li>If you load an entity, SQL statements get run. Once this is done, you have a completely loaded entity. No lazy loading or caching is done.</li><li>If you save an entity, it gets saved. If you do not, it does not. There is no dirty tracking and no session.</li><li>There is a simple model of how to map entities to tables. It probably only works for rather simple cases. If you do not like that, you should code your own strategy. Spring Data JDBC offers only very limited support for customizing the strategy with annotations.</li></ul></div><footer>— <cite>Spring Data JDBC Reference Documentation, https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#jdbc.why</cite></footer></blockquote></div><p>A bit down below we read:</p><div class=quote-block><blockquote><div class=ulist><ul><li>Try to stick to immutable objects — Immutable objects are straightforward to create as materializing an object is then a matter of calling its constructor only. Also, this avoids your domain objects to be littered with setter methods that allow client code to manipulate the objects state. If you need those, prefer to make them package protected so that they can only be invoked by a limited amount of co-located types. Constructor-only materialization is up to 30% faster than properties population.</li><li>Provide an all-args constructor — Even if you cannot or don’t want to model your entities as immutable values, there’s still value in providing a constructor that takes all properties of the entity as arguments, including the mutable ones, as this allows the object mapping to skip the property population for optimal performance.</li></ul></div><footer>— <cite>Spring Data JDBC Reference Documentation, https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#mapping.general-recommendations</cite></footer></blockquote></div><p>What’s more, even though…​</p><div class=quote-block><blockquote><p>All Spring Data modules are inspired by the concepts of “repository”, “aggregate”, and “aggregate root” from Domain Driven Design.</p><footer>— <cite>Spring Data JDBC Reference Documentation, <a class=bare href=https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#jdbc.domain-driven-design>https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#jdbc.domain-driven-design</a></cite></footer></blockquote></div><p>…​every single Spring Data JPA-based project I’ve ever encountered in the wild was nothing like that. Usually, they’d ignore DDD, create a repository per table, and have a complete bi-directed graph of all entities.</p><p>It seems like the team behind SJD is of the same opinion:</p><div class=quote-block><blockquote><p>These are possibly even more important for Spring Data JDBC, because they are, to some extent, contrary to normal practice when working with relational databases.</p><footer>— <cite>Spring Data JDBC Reference Documentation</cite></footer></blockquote></div><p>This so-called "normal practice" is a disastrous nightmare from design, maintenance, and performance standpoints.
It can quickly provide you with a makeshift solution for problem at hands, though.</p><p>Since SDJ doesn’t have lazy loading, you won’t get away with this "normal practice."
The team will have to go through with designing the data model and breaking it down into aggregates.</p><p>So far, I’ve only tried these technologies (that is, JDBC and R2DBC) in two small-scale projects, but I’ve been quite happy with the results.</p></section><section class="doc-section level-2"><h3 id=_jooq>jooq</h3><p><a href=https://www.jooq.org/>jooq.org</a></p><p>jooq is the first JPA alternative I’ve had successfull commercial experience with.</p><p>jooq uses Java DSL to make SQL queries.
It also features a powerful infrastructure for query execution, as well as DAO generation for CRUD operations.</p><p>There are two main downsides to it. First, source code takes an extra step to be generated.
Second, you’ll need a paid license to work with commercial databases.</p></section><section class="doc-section level-2"><h3 id=_ebean>Ebean</h3><p><a href=https://ebean.io/docs/>ebean.io</a></p><p>Ebean is a yet another technology I’ve had some fairly successful commercial experience with.</p><p>This tech is the closest you can get to JPA; it’s a full-fledged ORM.
Unlike JPA, though, Ebean poses no strict design limitations and shows much better performance by default.</p><p>Learning materials on Ebean are few and far between, however, apart from the official docs.
I’ve noticed some peculiarities in its behavior, though.
Moreover, Ebean features an annotation preprocessor which slows the build down quite a bit and doesn’t always work smoothly in IntelliJ Idea.</p><p>Still, I delivered the project on time. I even managed to develop just my usual fair share of new premature gray hair.</p></section><section class="doc-section level-2"><h3 id=_mybatis>MyBatis</h3><p><a href=https://mybatis.org/mybatis-3/>mybatis.org</a></p><p>I haven’t had the chance to try MyBatis myself in commercial environment.
As far as I know, though, it makes a popular alternative to JPA as well.</p></section></section><section class="doc-section level-1"><h2 id=_what_to_do_if_jpa_is_unavoidable>What to do if JPA is unavoidable</h2><p>Often JPA is unavoidable.
Someone is given with large legacy, which must be maintained.
Someone is given with new project, where technologies is dictated by "Architect" or customer.</p><p>Already after my post publication I stumbled upon <a href=https://www.stemlaur.com/blog/2021/03/30/tech-hibern-hate/>this post</a>.
In this post author describes all (and little more) rules, that I use to minimize JPA’s damage in projects where I didn’t managed to avoid it.
In particular I recommend to:</p><div class="olist arabic"><ol class=arabic><li>Stop having public default constructor and setters</li><li>Keep JPA DAOs outside of the domain as much as you can</li><li>Stop adding multi-directional association</li><li>Stop adding entity mappings whenever its possible</li></ol></div></section><section class="doc-section level-1"><h2 id=_conclusion>Conclusion</h2><p>In my opinion, JPA comes in handy when you need a fast, poor, and cheap solution.</p><p>That means using JPA makes sense if:</p><div class="olist arabic"><ol class=arabic><li>you need to come up with a quick prototype, or</li><li>you need to develop a small-scale internal system that’s meant for just a few dozen tables and users.</li></ol></div><p>In these cases, <a href=#_you_need_an_extra_query_to_reference_an_entity>saving entities into the HTTP session</a> would make practical sense.</p><p>I’d recommend against JPA if your project will be facing a higher load or feature a more complex domain model.
Here, you’d be much better off using one of the alternative technologies instead.</p></section><section class="doc-section level-1"><h2 id=_links>Links</h2><p>More links with JPA critics and hacks to workaround it problems:</p><div class=ulist><ul><li><a href=https://www.baeldung.com/spring-persisting-ddd-aggregates>Persisting DDD Aggregates</a></li><li><a href=https://www.stemlaur.com/blog/2021/03/30/tech-hibern-hate/>Stop using JPA/Hibernate</a></li><li><a href=https://leanpub.com/opinionatedjpa/read#ch-questionable-parts>Opinionated JPA with Querydsl, 3. Questionable parts</a></li><li><a href=https://vladmihalcea.com/the-best-way-to-map-a-onetomany-association-with-jpa-and-hibernate/>The best way to map a @OneToMany relationship with JPA and Hibernate</a></li></ul></div></section></article><br></section></div></main><script src=/js/app.js></script></body></html>