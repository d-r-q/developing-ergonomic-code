<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Почему следует избегать использования JPA/Hibernate в продакшене - Алексей Жидков"><meta property="og:description" content="Как дизайн JPA/Hibernate ведёт к созданию медленных приложений с плохим дизайном"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/21/04/why-jpa-should-be-avoided/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/21/04/why-jpa-should-be-avoided/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/21/04/why-jpa-should-be-avoided/><title>Почему следует избегать использования JPA/Hibernate в продакшене - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/21/04/why-jpa-should-be-avoided/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Почему следует избегать использования JPA/Hibernate в продакшене</h1><h2 class=date>April 3, 2021</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p><p>Обновление от 19.11.21:</p><div class=ulist><ul><li>Добавил ссылок на книги в <a href=#_весь_код_становится_кодом_с_побочными_эффектами>Весь код становится кодом с побочными эффектами</a></li></ul></div><p>Обновление от 22.08.21:</p><div class=ulist><ul><li>Раздел <a href=#_плохой_процедурный_стиль_программирования>Плохой процедурный стиль программирования</a></li><li>Раздел <a href=#_что_делать_если_jpa_невозможно_избежать>Что делать, если JPA невозможно избежать</a></li><li>Раздел <a href=#_ссылки>Ссылки</a></li></ul></div></aside><section class="doc-section level-1"><h2 id=_дисклеймер_я_люто_ненавижу_jpahibernate>Дисклеймер - я люто ненавижу JPA/Hibernate</h2><p>Мои отношения с Hibernate (JPA тогда ещё не было) не сложились с самого начала - в далёком то ли 2005, то ли 2007, на собеседовании у меня спросили как замапить отношение 1-N в Hibernate.
А я ответил "Я не знаю, что такое Hibernate".</p><p>Затем в чуть менее далёком 2008 году я устроился в Софтэйдж на какой-то проект на Swing и Hibernate.
Коммерческого опыта ни с тем ни с другим у меня на тот момент не было, поэтому мне казалось, что работал я плохо.
Я сильно парился на эту тему недели две-три, а потом уволился.</p><p>Однако, избежать JPA Java-разработчику практически не реально, поэтому и мне пришлось испить сию чашу до дна.
Я раскопал и починил гору багов и проблем с производительностью, порождённых стилем программирования, насаждаемым JPA, и всё-таки разобрался как она работает в общих чертах.
Но часы моей жизни, потраченные на эти раскопки уже не вернуть.
Вот почему я ненавижу JPA.</p><p>В этом посте я изложил факты и свой опыт, а как их интерпретировать - решайте сами.</p></section><section class="doc-section level-1"><h2 id=_философия_jpa>Философия JPA</h2><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Справедливости ради, 90% моего опыта с JPA - это Hibernate (есть ещё немного EclipseLink, но там все те же проблемы).
Поэтому в этом посте я буду использовать JPA и Hibernate, практически как синонимы.
Но изменяемые сущности и ленивая загрузка - корень причин основных проблем JPA - зашиты в спеку, и я не думаю что можно написать реализацию без приведённых проблем.</p></aside><p>Моя вольная интерпретация философии JPA: "Забудьте про базу данных - просто объявите свою объектную модель. Работайте с ней, как будто она вся в памяти. Мы позаботимся о сохранении объектов в БД".</p><p>Возможно истинная философия JPA какая-то другая (не могу нагуглить), но эта - точно самая распространенная "в народе".</p></section><section class="doc-section level-1"><h2 id=_упрощённая_модель_работы_hibernate>Упрощённая модель работы Hibernate</h2><figure class=image-block><img src=/posts/21/04/jpa-model.svg alt="jpa model"><figcaption>Figure 1. Упрощённая модель работы Hibernate</figcaption></figure><p>Для обеспечения обещания "работайте как будто у вас все объекты в памяти" Hibernate работает примерно так:</p><div class="olist arabic"><ol class=arabic><li>Приложение начинает транзакцию через <code>entityManager.getTransaction().begin()</code> (<a href=https://en.wikipedia.org/wiki/Software_transactional_memory>транзакции бывают и в памяти</a> и это не противоречит философии JPA);</li><li>приложение загружает данные через entityManager:<ol class=loweralpha type=a><li>entityManager формирует запросы и получает строки таблиц через JDBC-Driver;</li><li>ORM на основе строк формирует прокси объектов сущностей;</li><li>перед тем как отдать приложению, entityManager сохраняет все объекты в Persistence Context;</li></ol></li><li>приложение каким-то образом изменяет объекты через сеттеры;<ol class=loweralpha type=a><li>но т.к. это прокси, то сеттеры заодно помечают объекты "грязными";</li></ol></li><li>приложение коммитит транзакцию через <code>entityManager.getTransaction().commit()</code>;<ol class=loweralpha type=a><li>в этот момент entityManager просматривает Persistence Context, сохраняет/обновляет в БД все "грязные" и новые объекты;</li></ol></li></ol></div><p>Казалось бы, всё прекрасно - "Смотри, мам! Никакого шаблонного кода работы с БД!".
Всё настолько легко и просто, что можно дать задачу свеже испечённому выпускнику курсов "стань Java-разработчиком за три месяца" и он сразу начнёт давать результат.
Но это только пока вы делаете первую версию простой системы, которую одновременно используете вы и тестировщик.
А когда система попадает под нагрузку и начинает меняться, этот дизайн начинает показывать своё <s>дьявольское рыло</s> недостатки.</p></section><section class="doc-section level-1"><h2 id=_достоинства_jpa>Достоинства JPA</h2><p>У всего есть свои плюсы и минусы.
Надо признать, что плюсы есть даже у JPA.</p><p>Это безусловно самая распространённая технология работы с БД на платформе Java.
Из этого вытекает ещё три достоинства:</p><div class=ulist><ul><li>По JPA огромное количество материалов всех видов и на любой вкус.
Если использовать JPA идиоматично, то любые проблемы и решения гуглятся моментально;</li><li>нанять разработчика, знающего JPA не проблема - берёте с любого рынка и с вероятностью 99% он имеет хоть какой-то опыт работы с JPA;</li><li>JPA поддержано везде, где его можно поддержать.
В Котлине, например, сделали специальный <a href=https://kotlinlang.org/docs/no-arg-plugin.html>плагин</a> для совместимости с JPA.</li></ul></div><p>Кроме того, JPA предлагает знакомую всем модель программирования в императивном ООП-стиле.
Берёте любого программиста с рынка и он знает как работать с JPA.
Эта модель действительно легкая в использовании и практически всегда предлагает вариант решения задачи с нулевым сопротивлением.</p><p>С изолированной задачей сохранения и загрузки графов объектов в БД JPA справляется без каких-либо нареканий.</p><p>Ещё одна задача которую решает JPA - это сокрытие разницы в диалектах SQL, в случае если проект должен поддерживать несколько различных СУБД.
Однако это работает только до тех пор, пока вам удаётся обойтись "наибольшим общим делителем" возможностей SQL-диалектов ваших СУБД.
Но самые полезные для производительности возможности обычно скрываются в уникальных частях диалектов.</p><p>Наконец, именно с точки зрения реализации, это надёжное решение - я не помню чтобы сталкивался с багами в реализации Hibernate.</p><p>Но у всего есть и свои минусы и в JPA их тоже хватает.</p></section><section class="doc-section level-1"><h2 id=_проблемы_jpa>Проблемы JPA</h2><p>Корень проблем JPA лежит не в технической, а парадигмальной плоскости.
JPA пытается создать иллюзию отсутствия базы данных, в частности спрятать от программиста необходимость отражения изменений в БД.
Поэтому, в силу природы баз данных (управление изменяемым состоянием), у JPA нет другого выбора, кроме как использовать императивную модель программирования.
Это единственный способ отдать программе "POJO", а потом отследить изменения его состояния.
И в погоне за этой химерой JPA исключает более эргономичную декларативную модель программирования.</p><p>JPA наносит удар по двум фронтам - дизайн и производительность.
Сначала рассмотрим, как JPA подрывает дизайн программ.</p><section class="doc-section level-2"><h3 id=_весь_код_становится_кодом_с_побочными_эффектами>Весь код становится кодом с побочными эффектами</h3><p>Многие классические книги по проектированию и дизайну програм рекомендуют воздержаться от функций с побочными эффектами:</p><div class="olist arabic"><ol class=arabic><li><a href=https://www.amazon.com/Reliable-software-through-composite-design/dp/0884052842>Reliable software through composite design, глава Predictable Modules</a></li><li><a href=https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215>Domain-Driven Design: Tackling Complexity in the Heart of Software, глава SIDE-EFFECT-FREE FUNCTIONS</a></li><li><a href=https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882>Clean Code, глава Have No Side Effects</a></li></ol></div><p>Однако при использовании JPA буквально весь код становится кодом с побочными эффектами.</p><p>Каждый геттер может привести к выполнению запроса.
Или завтра начать приводить к выполнению запроса.
Каждый вызов функции может мутировать переданный объект.
И добавить новый UPDATE в транзакцию.</p><p>Подробнее о проблемах, свойственных коду с побочными эффектами можно почитать <a href=https://azhidkov.pro/posts/21/01/210126-fraud-functions/>здесь</a>.</p><p>На мой взгляд одной этой проблемы достаточно, для того чтобы исключить JPA из рассмотрения, при выборе технологий реализации нетривиального проекта.
Но побочные эффекты - только лишь одна из многих проблем, которые JPA несёт в проект.</p></section><section class="doc-section level-2"><h3 id=_классы_должны_быть_открытыми_для_наследования>Классы должны быть открытыми для наследования</h3><p>JPA требует, чтобы классы сущностей были открытыми для наследования:</p><div class=quote-block><blockquote><p>The entity class must not be final</p><footer>— <cite>JSR 338: JavaTM Persistence API; Version 2.2; "2.1 The Entity Class"</cite></footer></blockquote></div><p>А классы должны быть либо спроектированы и задокументированы для наследования, либо запрещать его.
Тут сошлюсь на классику: <a href=https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997>Effective Java</a>, глава "Item 19: Design and document for inheritance or else prohibit it".</p><p>При том проектирование класса для наследования требует намного больших усилий, чем определение структуры данных с несколькими полями и геттерами и сеттерами для них.
Я ни разу не видел JPA Entity, спроектированную для наследования.</p><p>Хотя возможность наследования сущностей JPA создаёт потенциал для проблем, на практике я с ними не сталкивался.</p></section><section class="doc-section level-2"><h3 id=_конструктор_по_умолчанию>Конструктор по умолчанию</h3><p>JPA требует включения в классы сущностей конструкторов по умолчанию:</p><div class=quote-block><blockquote><p>The entity class must have a no-arg constructor.</p><footer>— <cite>JSR 338: JavaTM Persistence API; Version 2.2; "2.1 The Entity Class", https://github.com/javaee/jpa-spec/blob/master/jsr338-MR/JavaPersistence.pdf</cite></footer></blockquote></div><p>При этом конструкторы по умолчанию являются анти-паттерном и бомбой замедленного действия - они позволяют создавать объекты, нарушающие инварианты, и создают <a href=https://azhidkov.pro/posts/21/01/210119-effects/#_временная_связность>временнУю связанность</a>.
Поподробнее об этом можно почитать, например, <a href=https://blog.ploeh.dk/2011/05/30/DesignSmellDefaultConstructor/>здесь</a>.</p><p>Эту проблему можно частично обойти, сделав конструктор по умолчанию package private и пометив его @Deprecated.
Правда я не видел, чтобы кто-то кроме меня следовал этой практике.</p></section><section class="doc-section level-2"><h3 id=_объекты_должны_быть_изменяемыми>Объекты должны быть изменяемыми</h3><p>JPA не может работать с неизменяемым объектами "By Design", и мутабельность так же зашита в спецификацию:</p><div class=quote-block><blockquote><p>An update to the state of an entity includes both the assignment of a new value to a persistent property or field of the entity as well as the modification of a mutable value of a persistent property or field</p><footer>— <cite>JSR 338: JavaTM Persistence API; Version 2.2; "3.2.4 Synchronization to the Database"</cite></footer></blockquote></div><p>Если же у вас вся модель изменяемая, то вы получаете все проблемы с:</p><div class="olist arabic"><ol class=arabic><li><a href=https://azhidkov.pro/posts/21/01/210119-effects/#_временная_связность>временной связанностью</a>;</li><li><a href=https://azhidkov.pro/posts/21/01/210119-effects/#_нелокальность_рассуждений>нелокальностью рассуждений</a>;</li><li><a href=https://azhidkov.pro/posts/21/01/210119-effects/#_конкурентное_программирование>конкурентным программированием</a>.</li></ol></div><p>Для того чтобы минимизировать <a href=https://en.wikipedia.org/wiki/Leaky_abstraction>протечки</a> своей абстракции, JPA необходимо обеспечить строгое соответствие одного объекта в памяти одной строке в БД.
Поэтому, если вы вместо мутации объекта создадите новый экземпляр с обновлённым состоянием, для JPA это будет новый объект, соответствующий новой строке БД.
И при попытке сохранить новый экземпляр, JPA его попытается вставить и получит ошибку нарушения уникальности первичного ключа.</p><p>Это можно частично обойти, сделав сущности неизменяемыми, и выполняя обновления через UPDATE-запросы.
Но это будет хорошо работать, только пока вам надо обновить один объект.
Если же вы работаете с графом неизменяемых объектов, то придётся руками написать запросы для всех типов и руками же обойти этот граф чтобы UPDATE-ы.</p></section><section class="doc-section level-2"><h3 id=_плохой_процедурный_стиль_программирования>Плохой процедурный стиль программирования</h3><p>Предыдущие два пункта и ещё ряд более мелких ограничений, которые JPA накладывает на сущности ведут к деградации подхода к разработке до процедурного.
Есть структуры данных без поведения (JPA сущности) и императивные процедуры для манипуляции ими (сервисы).
Добро пожаловать в 1981 год.</p><p>Ещё в 70 годах класски, например Ларри Константин в <a href=https://archive.org/details/structureddesign00edwa>Структурном дизайне</a>, вывели универсальную структуру поддерживаемых программ:</p><div class=image-block><img src=/posts/21/04/images/good-module-structure.svg alt="good module structure"></div><p>Эта структура и сейчас по большому счёту актуальна в виде <a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>Чистой архитектуры</a> и <a href=https://www.kennethlange.com/functional-core-imperative-shell/>Функционального ядра/императивной оболочки</a>.</p><p>Однако JPA превращаёт её в такую структуру:</p><div class=image-block><img src=/posts/21/04/images/bad-module-structure.svg alt="bad module structure"></div><p>Этот секретный ввод и вывод очень сложно анализировать, что ведёт к большим проблемам с производительностью - попробуйте понять сколько запросов будет выполнено в процессе обработки запроса, и регрессиям - попробуйте понять сколько, каких и как строк измениться в БД.
Плюс такая структура требует использования моков при тестировании бизенс-правил (трансформации). А тесты с моками проверяют не контракт метода, а реализацию и "ломаются" при любом маломальском рефакторинге.</p><p>Непосредственно к JPA это не относится, но на моей практике программисты считают, что пишут в ОО-стиле и не изучают "старьё" вроде структурного программирования и дизайна.
Порождая в итоге плохой процедурный код с низкой связностью (cohesion), высокой связанностью (coupling), выходом областей действия решений за рамки области контроля (см. <a href=https://archive.org/details/structureddesign00edwa/page/160/mode/2up>9.4 Scope of effect/scope of control</a>) и т.п.</p><p>Добро пожаловать в 1971 год.
Рекомендую воздержаться от использования оператора Go To.</p><hr><p>Теперь рассмотрим проблемы с производительностью, которые несёт использование JPA</p></section><section class="doc-section level-2"><h3 id=_ленивая_загрузка>Ленивая загрузка</h3><p>JPA активно продвигает ленивую загрузку.
Это вариант по умолчанию для отношений OneToMany и ManyToMany и ленивая загрузка считается <a href=https://thorben-janssen.com/hibernate-best-practices/#10_Don8217t_use_FetchTypeEAGER>"лучшей практикой</a>" в мире JPA.</p><p>Я не удивлюсь, если ленивая загрузка ответственна за 1% мирового потребления электроэнергии.
Ленивая загрузка была причиной 90% проблем с производительностью, которые мне приходилось решать в проектах с JPA.</p><p>Я много раз (например <a href=https://azhidkov.pro/portfolio/#threads>здесь</a>) на порядки увеличивал производительность частей системы, использующих JPA, по следующему алгоритму:</p><div class="olist arabic"><ol class=arabic><li>посчитать количество запросов, выполняемых кодом;</li><li>пригладить волосы, вставшие дыбом от сотен запросов вместо несколько штук;</li><li>выкинуть старый код, написать несколько запросов руками, написать на этой базе новый код;</li><li>готово.</li></ol></div><p>Тут я могу только предполагать, но думаю рецепт создания подобных проблем такой:</p><div class="olist arabic"><ol class=arabic><li>разработчику нужно срочно реализовать новую функциональность;</li><li>в месте, куда разработчик собирается добавлять новую функциональность, у него уже есть объект с геттером, возвращающим список с нужными данными;</li><li>разработчик вызывает этот геттер и пробегается по нему циклом;</li><li><p>примерно в 60% случаев, разработчик не осознаёт, что вызвав геттер он добавляет новый запрос.
А пробежавшись по нему циклом - ещё N.</p><p>Ещё в 30% осознаёт, но решает что <a href=https://ru.wikiquote.org/wiki/%D0%94%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%B4_%D0%9A%D0%BD%D1%83%D1%82>"преждевременная оптимизация - корень всех зол"</a>.</p><p>Ещё в 7% случаев добавляет задачу на кладбище техдолга.</p><p>И наконец только в 3% случаях, берёт на себя ответственность, двигает сроки и решает задачу эффективно.</p><p>По моим наблюдениям у меня в проектах с JPA процентовка примерно такая же, в лучшем случае - 60, 0, 30, 10 соотвественно.</p></li><li>разработчик повторяет шаг 3 несколько раз, лучше сделать 2-3 вложенных цикла с ленивой загрузкой, чтобы получить экспоненциальный рост количества запросов;</li><li>разработчик тестирует на демо-данных с двумя строками в таблице и не видит никаких проблем;</li><li>готово, можно нанимать меня для решения проблем с производительностью.</li></ol></div><p>С ленивой загрузкой надо быть постоянно начеку.
Каждый раз, написав что-то в духе <code>entity.getXXXs</code>, задумываться - не случится ли здесь <a href=https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping>N+1 запрос</a>.
Лично мне не хватает дисциплины на это.</p><p>В результате получается что-то вроде этого (дойдите до твита сами, если адблокер блокирует изображение):</p><blockquote class=twitter-tweet><p lang=en dir=ltr>Migration from <a href="https://twitter.com/hashtag/Hibernate?src=hash&ref_src=twsrc%5Etfw">#Hibernate</a> to <a href="https://twitter.com/hashtag/JOOQ?src=hash&ref_src=twsrc%5Etfw">#JOOQ</a> looks good so far <a href=https://t.co/gCDHPDguy0>pic.twitter.com/gCDHPDguy0</a></p>— Dmitry Baev (@baevdm) <a href="https://twitter.com/baevdm/status/1423636838275768322?ref_src=twsrc%5Etfw">August 6, 2021</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><p></p><p>Так же, говоря о ленивой загрузке, невозможно обойти печально известный LazyInitializationException.
Я всё ещё продолжаю встречать его в продакшене с завидной регулярностью.</p><p>Наконец, специфичной для JPA проблемой является то, что оно не предоставляет удобных средств для динамического управления ленивой загрузкой.
Где-то можно использовать <code>NamedEntityGraph</code>, но из-за его многословности слишком высок соблазн откатиться к ленивой загрузке.</p></section><section class="doc-section level-2"><h3 id=_дополнительный_запрос_для_обновления_сущности>Дополнительный запрос для обновления сущности</h3><p>Та же проблема, что и с <a href=#_объекты_должны_быть_изменяемыми>неизменяемыми объектами</a> , возникает, если вы хотите обновить сущность на основании DTO, полученном извне (в HTTP-запросе, например).
В JPA есть два способа сделать это:</p><div class="olist arabic"><ol class=arabic><li>Идиоматичный - выполнить дополнительный SELECT для того чтобы поместить объект в PersistenceContext, и обновить его;</li><li>Эффективный - снова воспользоваться UPDATE-ом.</li></ol></div><p>Первый вариант не удачный с точки зрения производительности.
Второй попахивает битвой с собственным фреймворком, который вроде бы должен упрощать жизнь.</p><p>Теоретически есть ещё вариант хранить сущности в HTTP сессии, но в эпоху горизонтального масштабирования это вариант исключительно теоретический.</p></section><section class="doc-section level-2"><h3 id=_дополнительный_запрос_для_вставки_ссылки>Дополнительный запрос для вставки ссылки</h3><p>Третья проблема из той же серии - вставка новой сущности, которая ссылается на существующую с известным ИДом.
И снова есть всё те же два варианта: либо делать дополнительный запрос, жертвуя производительностью, или бороться с JPA.</p></section><section class="doc-section level-2"><h3 id=_кэширование>Кэширование</h3><p>Кэшировать JPA сущности нельзя.</p><p>Если они у вас с сеттерами, то их нельзя кэшировать, хотя бы потому, что вы не сможете синхронизировать к ним конкурентный доступ.</p><p>Но даже неизменяемая JPA сущность, сохранённая в кэше, превратится в тыкву, как только закроется транзакция, в которой она была загружена.
Прочитать из неё данные ещё можно, но вот сослаться на неё уже нельзя.</p><p>Наконец, если у сущности есть ленивые поля, то рано или поздно стрельнет LazyInitializationException.</p><hr><p>Я уверен, что этот список будет и дальше расти.
Сейчас я выписал только то, что лежит на поверхности.</p><p>Получается, что теоретически JPA можно использовать, не жертвуя качеством дизайна и производительностью.
Однако придётся пожертвовать идиоматичностью использования JPA.
А вслед за ней уходят и все остальные достоинства JPA - материалов по такому подходу уже практически нет, в поддержке проявляются острые углы, разработчики этот подход не знают и т.п.</p><p>Возникает вопрос - стоит ли игра свеч, если качество дизайна и производительность являются приоритетными качественными атрибутами системы?
И чем воспользоваться, если ответ - "нет"?</p></section></section><section class="doc-section level-1"><h2 id=_альтернативы_jpa>Альтернативы JPA</h2><p>Все вышеперечисленные проблемы не присущи объектно-реляционному маппингу как таковому.
Это проблемы одного конкретного подхода к ОРМу, вызванные его стремлением сэмулировать работу с объектами в памяти.
Поэтому существуют другие решения, даже похожие на JPA, в которых идиоматичное использование не вынуждает жертвовать дизайном и производительностью.</p><section class="doc-section level-2"><h3 id=_spring_data_jdbcr2dbc>Spring Data Jdbc/R2dbc</h3><p><a href=https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#reference>docs.spring.io/spring-data/jdbc</a></p><p>Сейчас я предпочитаю работать с БД по средствам Spring Data Jdbc/R2dbc (далее - SDJ).</p><p>Эта технология обладает частью достоинств, которые считают уникальными для JPA:</p><div class="olist arabic"><ol class=arabic><li>программисты знакомые со Spring Data JPA уже знают большую часть SDJ;</li><li>это всё та же всеми любимая технология Spring Data, которая "автомагически" генерирует реализации методов вида <code>findByName(name: String)</code>;</li><li>это "надёжное решение от проверенного вендора" - его намного легче "продать" заказчику или СТО, чем другие альтернативы.</li></ol></div><p>При всём при этом SDJ имеет эргономичную философию:</p><div class=quote-block><blockquote><p>Spring Data JDBC aims to be much simpler conceptually, by embracing the following design decisions:</p><div class=ulist><ul><li>If you load an entity, SQL statements get run. Once this is done, you have a completely loaded entity. No lazy loading or caching is done.</li><li>If you save an entity, it gets saved. If you do not, it does not. There is no dirty tracking and no session.</li><li>There is a simple model of how to map entities to tables. It probably only works for rather simple cases. If you do not like that, you should code your own strategy. Spring Data JDBC offers only very limited support for customizing the strategy with annotations.</li></ul></div><footer>— <cite>Spring Data JDBC Reference Documentation, https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#jdbc.why</cite></footer></blockquote></div><p>И чуть ниже:</p><div class=quote-block><blockquote><div class=ulist><ul><li>Try to stick to immutable objects — Immutable objects are straightforward to create as materializing an object is then a matter of calling its constructor only. Also, this avoids your domain objects to be littered with setter methods that allow client code to manipulate the objects state. If you need those, prefer to make them package protected so that they can only be invoked by a limited amount of co-located types. Constructor-only materialization is up to 30% faster than properties population.</li><li>Provide an all-args constructor — Even if you cannot or don’t want to model your entities as immutable values, there’s still value in providing a constructor that takes all properties of the entity as arguments, including the mutable ones, as this allows the object mapping to skip the property population for optimal performance.</li></ul></div><footer>— <cite>Spring Data JDBC Reference Documentation, https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#mapping.general-recommendations</cite></footer></blockquote></div><p>Более того, хотя</p><div class=quote-block><blockquote><p>All Spring Data modules are inspired by the concepts of “repository”, “aggregate”, and “aggregate root” from Domain Driven Design.</p><footer>— <cite>Spring Data JDBC Reference Documentation, <a class=bare href=https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#jdbc.domain-driven-design>https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#jdbc.domain-driven-design</a></cite></footer></blockquote></div><p>Все проекты на Spring Data JPA, с которыми я сталкивался на практике, игнорируют DDD, создают по репозиторию на таблицу и строят полносвязный двунаправленный граф всех сущностей.
Кажется, с этим согласны и авторы SDJ:</p><div class=quote-block><blockquote><p>These are possibly even more important for Spring Data JDBC, because they are, to some extent, contrary to normal practice when working with relational databases.</p><footer>— <cite>Spring Data JDBC Reference Documentation</cite></footer></blockquote></div><p>Эта так называемая "normal practice" - просто кошмар с точки зрения дизайна, поддержки и производительности, хотя и позволяет быстро решить задачу в моменте.</p><p>С SDJ "normal practice" не пройдёт из-за отсутствия ленивой загрузки, и команде всё-таки придётся озадачиться дизайном модели данных и разбиением её на агрегаты.</p><p>Пока что я попробовал эти технологии (JDBC и R2DBC) только в двух небольших проектах, но результатами очень доволен.</p></section><section class="doc-section level-2"><h3 id=_jooq>jooq</h3><p><a href=https://www.jooq.org/>jooq.org</a></p><p>jooq - первая альтернативная технология, с которой у меня есть успешный коммерческий опыт.</p><p>В основе jooq-а лежит Java DSL для написания SQL запросов.
Но автор так же сделал мощную инфраструктуру исполнения запросов и генерации DAO для CRUD операций.</p><p>Основных недостатка два - генерация исходного кода отдельным шагом и платная лицензия для работы с платными базами данных.</p></section><section class="doc-section level-2"><h3 id=_ebean>Ebean</h3><p><a href=https://ebean.io/docs/>ebean.io</a></p><p>Следующая альтернативная технология, с которой у меня есть более-менее удачный коммерческий опыт.</p><p>Эта технология наиболее близка к JPA и является полноценным ОРМом.
Но в отличие от JPA, Ebean не накладывает таких ограничений на дизайн и по умолчанию намного более производительная.</p><p>Однако по Ebean мало информации помимо официальной документации, а некоторые особенности в поведении всё-таки встречались.
Плюс Ebean использует препроцессор аннотаций, который заметно тормозит сборку и не всегда корректно работает в Идее.</p><p>Тем не менее проект сдан, сдан в срок и седых волос прибавилось не больше, чем обычно.</p></section><section class="doc-section level-2"><h3 id=_mybatis>MyBatis</h3><p><a href=https://mybatis.org/mybatis-3/>mybatis.org</a></p><p>MyBatis я сам в коммерческих проектах не трогал, но насколько мне известно, это тоже популярная альтернатива JPA.</p></section></section><section class="doc-section level-1"><h2 id=_что_делать_если_jpa_невозможно_избежать>Что делать, если JPA невозможно избежать</h2><p>Зачастую JPA избежать невозможно.
Кому-то достаётся огромный легаси, который надо поддерживать.
Кому-то - новый проект, где технологии диктуются "Архитектором" или заказчиком.</p><p>Уже после публикации своего поста, я наткнулся на <a href=https://www.stemlaur.com/blog/2021/03/30/tech-hibern-hate/>этот пост</a>.
И там автор описывает все правила (и ещё чуть-чуть), которые я использую для минимизации вреда JPA, в проектах где его не удалось избежать.
В частности:</p><div class="olist arabic"><ol class=arabic><li>Stop having public default constructor and setters</li><li>Keep JPA DAOs outside of the domain as much as you can</li><li>Stop adding multi-directional association</li><li>Stop adding entity mappings whenever its possible</li></ol></div></section><section class="doc-section level-1"><h2 id=_заключение>Заключение</h2><p>По моему мнению, применение JPA уместно, когда важно сделать быстро, дёшево и плохо.
То есть применение JPA уместно в двух случаях:</p><div class="olist arabic"><ol class=arabic><li>быстрое прототипирование;</li><li>разработка небольших внутренних информационных систем на пару десятков таблиц и столько же пользователей.</li></ol></div><p>И в этих случаях, <a href=#_дополнительный_запрос_для_вставки_ссылки>вариант</a> с сохранением сущностей в HTTP сессии становится уже вполне практическим.</p><p>Если же в вашем проекте планируется более сложная доменная модель или более высокая нагрузка, то лучше сэкономить нервы себе и своим пользователям и взять одну из альтернатив. <span class=logo><img src=/images/logo.svg alt=logo></span></p></section><section class="doc-section level-1"><h2 id=_ссылки>Ссылки</h2><p>Ещё ссылки с критикой JPA и костылями для обхода её проблем:</p><div class=ulist><ul><li><a href=https://www.baeldung.com/spring-persisting-ddd-aggregates>Persisting DDD Aggregates</a></li><li><a href=https://www.stemlaur.com/blog/2021/03/30/tech-hibern-hate/>Stop using JPA/Hibernate</a></li><li><a href=https://leanpub.com/opinionatedjpa/read#ch-questionable-parts>Opinionated JPA with Querydsl, 3. Questionable parts</a></li><li><a href=https://vladmihalcea.com/the-best-way-to-map-a-onetomany-association-with-jpa-and-hibernate/>The best way to map a @OneToMany relationship with JPA and Hibernate</a></li></ul></div></section></article><br></section></div></main><script src=/js/app.js></script></body></html>