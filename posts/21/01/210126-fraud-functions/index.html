<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Типы функций: функции-мошенники - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/21/01/210126-fraud-functions/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/21/01/210126-fraud-functions/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/21/01/210126-fraud-functions/><title>Типы функций: функции-мошенники - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/21/01/210126-fraud-functions/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Типы функций: функции-мошенники</h1><h2 class=date>January 26, 2021</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><p>Начало темы
<a href=https://azhidkov.pro/posts/21/01/210105-pure-functions-and-effects-intro/>здесь</a>,
<a href=https://azhidkov.pro/posts/21/01/210112-pure-functions/>здесь</a>
и <a href=https://azhidkov.pro/posts/21/01/210119-effects/>здесь</a>.</p><p><em>С второго взгляда терминология оказалась не такой уж чудесной, как показалась на первый взгляд, но я на этом посте засиделся, так что публикую как есть.
В посте с итогами ещё раз попробую составить приличную терминологию.</em></p><p>Как я уже писал в прошлой статье, эффекты - это то ради чего пишутся программы, и тот критерий, по которому программы оцениваются.
Однако если не соблюдать определённую "эффективную гигиену", то эффекты выходят из-под контроля, что приводит к появлению багов.
"Эффективная гигиена" заключается в разделении сложной логики и эффектов и выделении их в разные функции.
Если же этого не делать, то появляются функции-мошенники.</p><p>Функции-мошенники бывают двух типов:</p><div class=ulist><ul><li>откровенные жулики, которые врут прямо в глаза;</li><li>"честный бизнес", который пишет всю правду, но мелким шрифтом.</li></ul></div><section class="doc-section level-1"><h2 id=_откровенные_жулики>Откровенные жулики</h2><p>Под функцией-жуликом я понимаю функцию, один из эффектов которой не очевиден из её названия и/или сигнатуры.
Кому не очевиден - вопрос.
Пока пусть будет мне:)</p><p>Хрестоматийным примером функции-жулика является ленивая загрузка в ОРМах.
По сигнатуре - рид онли функция, даже просто свойство.
Смотришь в код - всё так.
Пускаешь в прод - <a href=https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping>проблема N+1</a>.</p><p>Или ещё пример:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=nc>String</span> <span class=nf>decrypt</span><span class=o>(</span><span class=nc>String</span> <span class=n>encrypted</span><span class=o>);</span></code></pre></div><p>Казалось бы должна быть функция без эффектов.
Ан нет, это метод интерфейса.
Одна из реализаций, которого идёт в сеть.
А вызывается она внутри транзакции.
Если сервис расшифровки вешается, то у вас условно 25 потоков обработки запросов сжирают весь пул из 25 подключений в ожидании ответа по сети и привет (<em>да, я знаю, что повторяюсь, в книге исправлюсь:)</em>).</p><p>Или более простой, но не менее опасный пример:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=nc>Double</span> <span class=nf>calculateAverage</span><span class=o>(</span><span class=nc>List</span><span class=o>&lt;</span><span class=nc>Integer</span><span class=o>&gt;</span> <span class=n>data</span><span class=o>);</span></code></pre></div><p>Казалось бы - чистая функция, которая считает среднее значение элементов списка.
Ан нет, она там внутри удаляет из списка нулевые элементы.
И чем это аукнется коду, который переиспользовал (написанному другим автором или тем же автором в другое время) эту функцию по сигнатуре (ява доки-то никто не пишет, а если пишут - не читают) - не известно.</p><p>С другой стороны есть честные функции с несколькими эффектами, которые я не считаю жуликами (<s>потому что сам их написал</s>:)).
Например, <a href=https://github.com/d-r-q/qbit/blob/master/qbit-core/src/commonMain/kotlin/qbit/Conn.kt#L134>последний шаг коммита в кубите</a>:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=k>override</span> <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>update</span><span class=p>(</span><span class=n>trxLog</span><span class=p>:</span> <span class=nc>TrxLog</span><span class=p>,</span> <span class=n>newLog</span><span class=p>:</span> <span class=nc>TrxLog</span><span class=p>,</span> <span class=n>newDb</span><span class=p>:</span> <span class=nc>InternalDb</span><span class=p>)</span> <span class=p>{</span>
   <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=n>trxLog</span> <span class=p>!=</span> <span class=n>trxLog</span><span class=p>)</span> <span class=p>{</span>
       <span class=k>throw</span> <span class=nc>ConcurrentModificationException</span><span class=p>(</span><span class=s>&#34;Concurrent transactions isn&#39;t supported yet&#34;</span><span class=p>)</span>
   <span class=p>}</span>
   <span class=n>storage</span><span class=p>.</span><span class=nf>overwrite</span><span class=p>(</span><span class=nc>Namespace</span><span class=p>(</span><span class=s>&#34;refs&#34;</span><span class=p>)[</span><span class=s>&#34;head&#34;</span><span class=p>],</span> <span class=n>newLog</span><span class=p>.</span><span class=n>hash</span><span class=p>.</span><span class=n>bytes</span><span class=p>)</span>
   <span class=k>this</span><span class=p>.</span><span class=n>trxLog</span> <span class=p>=</span> <span class=n>newLog</span>
   <span class=k>this</span><span class=p>.</span><span class=n>db</span> <span class=p>=</span> <span class=n>newDb</span>
<span class=p>}</span></code></pre></div><p>содержит аш 3 эффекта - запись в файл, и обновление двух изменяемых ссылок.</p><p>Но у этой функции есть ряд характеристик легализующих её:</p><div class="olist arabic"><ol class=arabic><li>из её названия очевидно, что она будет обладать эффектами (в частности по отсутствию типа возврата что в Котлине примерно соответствует void-у);</li><li>это единственное что делает эта функция, соотвественно все три эффекта очевидны;</li><li>эти эффекты должны быть атомарны - в файл пишется ссылка на последнюю запись в журнал транзакций, в trxLog обновляется предстваление этого журнала в памяти, в db обновляется индекс этого журнала.
Если хоть что-то из этого не сделать, то пользователь увидет неконсистентное или недурабельное состояние базы данных.</li></ol></div><p>Для того чтобы не подкладывать самому себе бомбы в своём коде у меня всё тот же набивший оскомину рецепт - разделять эффекты и логику.</p><p><a href=https://www.amazon.com/Just-Enough-Software-Architecture-Risk-Driven/dp/0984618104>Автор лучшей книге по архитектуре</a> причисляет функции-жулики к анти-паттернам и предостерегает от "захоронения сокровищ не подходящих местах":</p><div class=quote-block><blockquote><p>Anti-pattern: Buried treasure.
While most of the other advice is on what you should do, this is advice on what to avoid.
It is easy to subvert the other good practices by burying treasure in inappropriate places.
Responsibility-driven design asks you to allocate responsibilities to parts of your design, but you should avoid hinting at one thing while doing another (Wirfs-Brock, Wilkerson and Wiener, 1990).
For example, most developers reading source code will assume that a getX() method will have no side effects and a method named launchSpaceShuttle() will do the obvious thing.
If you signal to the reader that you have allocated a responsibility, you should follow through in the details.</p><footer>— <cite>George Fairbanks, Just Enough Software Architecture</cite></footer></blockquote></div><p>И это единственный анти-паттерн в своём разделе (о стиле кодирования, раскрывающем архитектуру приложения).</p></section><section class="doc-section level-1"><h2 id=_честный_бизнес>"Честный бизнес"</h2><p>"Честный бизнес" - это функции которые одновременно:</p><div class="olist arabic"><ol class=arabic><li>имеют эффекты;</li><li>имеют высокую сложность.</li></ol></div><p>В результате из их сигнатуры очевидно, что что-то происходит, но что именно - без поллитры не разберёшься.</p><p>Этим функциям посвящены главы <a href=https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052>книг</a> и собственный <a href=https://ru.wikipedia.org/wiki/%D0%91%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82>анти-паттерн</a>.</p><p>Пока что лучшее, что мне удалось найти в качестве метрики "ушлости" таких функций - это <a href=https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C>цикломатическая сложность</a>.
Но для того чтобы создать по настоящему большую проблему, одной цикломатической сложности мало.
Если у вас есть чистая функция с высокой цикломатической сложностью, с ней всё равно ещё можно работать.
Во-первых, поток данных в ней будет довольно простой (по определению чистой функции → отсутствия изменяемых переменных).
Во-вторых, вы можете легко обложить её юнит-тестами.</p><p>А вот если в сложной функции есть эффекты, то дело обретает серьёзный оборот.
Теперь, скорее всего, у вас появляются изменяемые переменные, которые делают поток данных практически не отслеживаемым (в сложных функциях).</p><p>А наблюдаемые эффекты ещё больше усугубляют проблему.
Во-первых, с ними в принципе тесты писать сложнее.
Во-вторых, в отличие от параметров, которых редко бывает больше трёх, эффектов в функцию можно заталкать сколько угодно и это не будет никому резать глаз.
Кто-то вообще эффекты не считает, а те кто считает не разглядит их за горой if-ов и for-ов.
Далее, эти эффекты могут быть в том числе чтением неявных параметров.
И чтобы безопасно менять такую функцию, вам надо проверить все комбинации параметров (явных параметров) и эффектов (неявных параметров).
Что на практике невозможно, конечно же (в контексте функции с высокой цикломатической сложность и большим количеством эффектов).</p><p>В итоге, вы получаете монстра, которого не можете ни понять, ни простить, ни протестировать.
И которого надо поменять прямо сейчас.
Я обычно в таких случаях громко матерюсь, перекрещиваюсь, вношу изменения, которые приводят к нужному эффекту в нужном юз кейсе и не кажутся откровенно ошибочными, и пушу:)
Ну и потом молюсь, конечно же:).</p><p>Пример функции-"честного бизнеса" я решил не приводить - вы бы его всё равно не поняли (по определению функции-"честного бизнеса") 🤣.
Но если у вас был опыт работы со "зрелым" проектом или вы возвращались к своему диплому через пару лет, вы понимаете о чём я говорю:)</p><p>Как бороться с "честным бизнесом" в вашем коде?
Думаю вы уже знаете🤣.
Ну а если ещё вдруг нет, то - по средствам разделения сложной логики и эффектов в разные функции.</p><div class=quote-block><blockquote><p>Заметка в бок.</p><p>Вообще это кажись должно было пойти в предыдущий пост, но пришло в этот:)</p><p>Проблему тестирования эффективных функций усугубляет тот факт, что в одну функцию можно затолкать сколько угодно эффектов.
А в силу того, что в случае эффектов их порядок (и наличие вообще) имеет значение, нельзя написать тест кейс с одним ассертом на один эффект - в каждом тест кейсе надо проверять порядок и наличие/отсутствие всех потенциальных эффектов.
Проверять все эффекты важно потому, что если функция, например, сначала удаляет строку (в реляционной БД), а потом вставляет новую с тем же первичным ключом, то нельзя написать тесты отдельно на удаление и на
вставку.
Каждый из этих тестов по отдельности ничего не говорит о том, работает ли функция правильно.</p></blockquote></div></section><section class="doc-section level-1"><h2 id=_заключение>Заключение</h2><p>В этой статье мы рассмотрели два последних типа функций встречающихся в программе.
Для того чтобы программа была эргономичной, количество и размер таких функций в программе необходимо минимизировать, однако полное их исключение из кодовой базы потребует слишком больших усилий, и на мой взгляд не целесообразно.</p></section></article><br></section></div></main><script src=/js/app.js></script></body></html>