<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Чистые и эффективные функции: Эффекты - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/21/01/210119-effects/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/21/01/210119-effects/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/21/01/210119-effects/><title>Чистые и эффективные функции: Эффекты - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/21/01/210119-effects/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li><li class=multilingual-separator><p>|</p></li><li class="navigation-item align-left"><a href=https://azhidkov.pro/en/>En</a></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Чистые и эффективные функции: Эффекты</h1><h2 class=date>January 19, 2021</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><p>Начало темы
<a href=https://azhidkov.pro/posts/21/01/210105-pure-functions-and-effects-intro/>здесь</a>
и
<a href=https://azhidkov.pro/posts/21/01/210112-pure-functions/>здесь</a>.</p><p>Сегодня расскажу о том, что я понимаю под эффектами и обработкой
сигналов.</p><section class="doc-section level-1"><h2 id=_что_я_понимаю_под_эффектами_и_сигналами>Что я понимаю под эффектами и сигналами</h2><p><strong>Обработка сигнала</strong> - акт чтения глобальной изменяемой памяти.</p><p><strong>Отправка сигнала</strong> - акт записи глобальной изменяемой памяти.</p><p><strong>Глобальная изменяемая память</strong> - область памяти, на которую в момент
чтения/записи замаплено изменяемое поле объекта или структуры,
достижимого из GC root.</p><p><strong>Эффект</strong> - операция отправки или обработки сигнала. Является
подмножеством понятия побочный эффект, часто встречаемого в литературе.</p><div class=quote-block><blockquote><p>Примечание</p><p>Термин обработка/отправка сигнала мне самому не очень нравится, но он не
лишён смысла.</p><p>Если рассматривать ввод/вывод, то даже вроде бы синхронный вызов read,
на деле асинхронный и внутри вызова выполняется обработка сигнала
(прерывания) ``данные готовы''. А вызов write - это собственно отправка
сигнала на запись устройству вывода.</p><p>Глобальные переменные тоже можно за уши натянуть на эту терминологию -
если вы читаете изменяемую переменную, то ожидаете, что кто-то её
предварительно записал, тем самым послав вам сигнал.</p></blockquote></div><p>Проще говоря обработка/отправка сигнала - это чтение/запись переменной
объявленной вне области видимости текущей функции. Подчеркну, что в этом
смысле буфферы ввода/вывода так же являются изменяемыми переменными.</p><p>Так же обратите внимание на дуальность отправки и обработки сигналов -
эффект отправки сигнала одним процессом, превращается в эффект обработки
сигнала другим процессом и связаны они изменяемой памятью, через которую
сигнал передаётся.</p><p>Если что-то написал не понятно - пишите в комменты, поясню:)</p></section><section class="doc-section level-1"><h2 id=_это_всё_ради_эффектов>Это всё ради эффектов</h2><p>А теперь сюрприз-сюрприз - мы пишем программы ради эффектов. Конечному
пользователю (в лице QA и продакта:) ) пофиг на технологии, архитектуру,
крутые алгоритмы, стиль кода и т.п. Всё что он может сделать с
программой - это отправить сигнал (который будет обработан программой) и
обработать сигнал (отправленный программой) полученный в ответ. Т.е.
какие-бы то ни было суждения о программе пользователь может делать
только на основании эффектов её исполнения.</p><p>Поэтому в тест-планах всегда есть шаги (набор сигналов для отправки) и
ожидаемый результат (набор сигналов для обработки и проверки). А в
случае информационных систем 90-99% тест кейсов вообще не содержат
каких-либо правил по проверке ожидаемых результатов помимо наблюдаемого
эффекта, т.к. ожидаемый результат бинарный - логин удался или нет,
введённая строка появилась в нужном месте или нет.</p><p>То есть именно на основании эффектов конечный пользователь (в лице QA
или продакта:) ) будет принимать решение о том сделал программист свою
работу или ``всё говно, переделывай''.</p><p>И при таком уровне важности Эффектов для работы программиста, абсолютно
во всех проектах, которые я видел за 16 лет карьеры, они находились в
слепой зоне и никто осознано не подходил к управлению ими. То есть я ни
разу в жизни не видел осознанного подхода к своей работе. Справедливости
ради, сам я тоже не Будда Просветлённый и осознанным подходом пока не
отличаюсь:)</p><p>Наконец, имхо, игнорирование эффектов - это фактически игнорирование
конечного пользователя. Потому что это ваше основное средство
коммуникации с конечным пользователем.</p><p>Надеюсь, я вас убедил в необходимости осознаного управления эффектами,
но что же это значит?</p><p>Осознанное же управление эффектами, это когда программист пишущий
условный <code>print</code> или <code>db.save</code> держит в голове что-то вроде ``сейчас я
программирую отправку сигнала А, в ответ на получение сигнала Б для
удовлетворения пункта 5.2.52 требований''.</p><p>Управление эффектами - неотъемлемая часть
<a href=https://github.com/d-r-q/developing-ergonomic-code/blob/master/book-rus/developing-ergonomic-code.adoc>моего
Эргономичного Подхода</a> и обязательная характеристика эргономичного кода.</p><p>А неосознанная генерация эффектов налево и направо ведёт к куче проблем,
которые я видел абсолютно во всех проектах за 16 лет карьеры (пока не
начал разрабатывать Эргономичный Подход:) ).</p></section><section class="doc-section level-1"><h2 id=_это_всё_из_за_эффектов>Это всё из-за эффектов</h2><section class="doc-section level-2"><h3 id=_временная_связность>ВременнАя связность</h3><div class=quote-block><blockquote><p>Примечание</p><p>Это капец, товарищи! Об этом понятии на русском ваще ничего нагуглить не
могу, в русской вики его вообще нет, а в английской, он упоминается
мелким пунктом где-то в середине. При том что сама википедия ставит его
на второе место по ``плохости''.</p></blockquote></div><p>Эффекты могут обладать неявной временнОй связностью (temporal coupling)
между собой. Это не в том смысле, что связность пропадает со временем, а
в том смысле что, результат выполнения двух эффектов зависит от
очерёдности их исполнения. Например, рассмотрим такую программу:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=kd>val</span> <span class=py>buffer</span> <span class=p>=</span> <span class=nc>StringBuilder</span><span class=p>()</span>
<span class=n>buffer</span><span class=p>.</span><span class=nf>append</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>)</span>
<span class=n>buffer</span><span class=p>.</span><span class=nf>deleteCharAt</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span></code></pre></div><p>В этой программе вызов <code>deleteCharAt</code> зависит от вызова <code>append</code> и если
их переупорядочить, то программа закрешится. Здесь связь очевидна, но
эти вызовы могут быть спрятаны внутри разных функций, внутри разных
классов, внутри разных модулей. И если вы их случайно переупорядочите во
время рефакторинга в таких обстоятельствах - могу лишь пожелать удачи в
<sub>бою</sub> дебаге. Ну и чтобы баг нашли тесты или хотя бы QA, а не
пользователи.</p><p>Чистая же версия этого кода такая:
<img src=channel/ergo/drafts/210119-effects/img-2-immutable-buffer.png alt="чистый код"></p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=kd>val</span> <span class=py>emptyString</span> <span class=p>=</span> <span class=s>&#34;&#34;</span>
<span class=kd>val</span> <span class=py>aString</span> <span class=p>=</span> <span class=n>emptyString</span> <span class=p>+</span> <span class=s>&#34;a&#34;</span>
<span class=kd>val</span> <span class=py>clearedString</span> <span class=p>=</span> <span class=n>aString</span><span class=p>.</span><span class=nf>substring</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>aString</span><span class=p>.</span><span class=n>length</span><span class=p>)</span></code></pre></div><p>И здесь компилятор махом вам даст по рукам, если вы случайно поменяете
эти строки руками. В этой версии связь вызовов очевидна.</p><p>Речь тут идёт не только о памяти - работа с любым изменяемым хранилищем
вроде диска, СУБД, REST API и т.п., создаёт временнУю связность между
кусками кода, которые пишут и читают это хранилище.</p></section><section class="doc-section level-2"><h3 id=_нелокальность_рассуждений>Нелокальность рассуждений</h3><p>Из-за временнОй связности теряется локальность рассуждений о программе.</p><p>Если вы работаете с кодом ``неосознанного'' проекта, то у вас объекты
будут мутабельными. И вы не можете свободно вызывать какие-либо методы
передавая свой объект в качестве параметра, потому как в таком проекте с
высокой долей вероятности вызываемой код так или иначе изменит ваш
объект и далеко не факт, что так, как вам надо, а не иначе.</p><p>В результате передавая объект в чужой метод вы вынуждены ``покинуть''
метод над которым работаете, и пройтись по стэку вызовов, чтобы
удостовериться, что там никто вам не изгадит ваш объект. И дай вам бог,
чтобы на вашем пути не встретились <sub>драконы</sub> полиморфные и рефлексивные
вызовы:) Наконец, если сейчас передача объекта безопасна, то не значит
что завтра ваш коллега или вы сами не подложите себе свинью, в виде
неожиданной мутации.</p></section><section class="doc-section level-2"><h3 id=_регрессии>Регрессии</h3><p>Но положа руку на сердце, вы меняя код задумываетесь о том, как эти
изменения повлияют на порядок эффектов, на какое состояние эти эффекты
направлены, и какие ещё эффекты направлены на это состояние? Прям каждый
раз и прям тщательно всё изучая? Я - нет.</p><p>В итоге я регулярно меняя одно место, ломаю другое. Это ведёт к страху
рефакторинга. Это ведёт к загниваюнию кодовой базы и превращению её в
<a href=https://www.researchgate.net/publication/2938621_Big_Ball_of_Mud/link/54d4eb900cf2970e4e63e44d/download>Big
Ball of Mud</a>.</p></section><section class="doc-section level-2"><h3 id=_тестирование>Тестирование</h3><p>С тестированием изменяемых объектов особых проблем не припоминаю. Ну ток
что в комплекте с изменяемыми объектами зачастую идёт только конструктор
без параметров и пачка сеттеров - это неудобно, но можно полечить просто
добавив конструктор.</p><p>А вот тестирование ввода-вывода - это да, беда. Тестировать ио больно
потому что такие тесты: 1. могут потребовать запуска внешнего сервиса
(СУБД, например) 2.
<a href=https://formulusblack.com/blog/compute-performance-distance-of-data-as-a-measure-of-latency/>как
минимум на порядок, а то и пять</a> медленнее тестов только в памяти 3.
намного менее стабильны 4. вообще непонятно как писать для устройств
отличных от диска и сетевой карты</p><p>Отсюда началась движуха про
<a href=https://martinfowler.com/articles/practical-test-pyramid.html>пирамиду
тестов</a> в которой львиная доля тестов должна быть юнит-тестами и про
``давайте замочим всю систему''.</p><p>Только оби этих практики ведут к тестам, которые ломаются при любом мало
мальском рефакторинге. Это ведёт к страху рефакторинга. Это ведёт к
загниванию кодовой базы и преваращению её в Big Ball of Mud (ссылка
выше:) ).</p><p>И не понятно как это поможет ловить баги в системах ориентированных на
ввод-вывод, где из логики ток тривиальная валидация отданая на откуп
либе.</p><p>Но чёт я отвлёкся от темы, про тесты будет своя серия постов.</p></section><section class="doc-section level-2"><h3 id=_производительность>Производительность</h3><p>Опять же это касается только эффектов ио, т.к. они существенно медленнее
работы с памятью.</p><p>Если у вас эффекты раскиданы по коду произвольным образом, вы можете
случайно засунуть чтение одних и тех же данны с диска в цикл на тысячу
итераций.</p><p>Или словить печально известную
<a href=https://habr.com/ru/company/otus/blog/529692/>проблему N+1</a> и даже не
заметить этого, пока количество таких проблем не положит систему
намертво.</p><p>Или случайно через полиморфный вызов засунуть сетевой вызов внутрь
транзакции БД. После того как уже захватили пачку локов.</p><p>Все эти проблемы опять же вызваны нелокальностью рассуждений, если в
кодовой базе нет дисциплины в работе с эффектами, то они могут
стрельнуть где угодно. А просматривать стэк каждого вызова -
замучаешься. Да и если сегодня вызов чистый, без дисциплины нет
гарантий, что завтра он не станет эффективным.</p></section><section class="doc-section level-2"><h3 id=_конкурентное_программирование>Конкурентное программирование</h3><p>Если у вас есть эффекты, то их надо упорядочивать, а для этого надо идти
в конкурентное программирование. А это очень сложно, поверьте мне на
слово, если ещё сами не убедились в этом на своём опыте:)</p><p>Чистый же код можно спокойно параллелить как угодно и вообще не греть
голову об этом.</p></section><section class="doc-section level-2"><h3 id=_кэширование>Кэширование</h3><p>Ну и опять же с эффектами
<a href=https://martinfowler.com/bliki/TwoHardThings.html>появляется одна из
двух самых сложных задач в программировании</a>. После конкурентности,
конечно :)</p><hr><p>В итоге мы пришли к Дилемме Эффектов - без эффектов никак, а с ними ещё
хуже. Как же быть? Для начала, надо присмотреться к эффектам поближе.</p></section></section><section class="doc-section level-1"><h2 id=_эффекты_бывают_разные>Эффекты бывают разные</h2><p>Из списка проблем вызываемых эффектами видно, что есть два типа
эффектов: 1. работа с глобальным изменяемыми состоянием (измененяемым
переменными) 2. ввод/вывод</p><p>На самом деле, второй тип (ио) это частный случай первого типа
(изменяемой памяти), т.к. любой ввод-вывод начинается с работы с
изменяемыми блоками памяти и в конечном итоге заканчивается там же. Но
между ними есть существенная разница - минимизировать ио без минимизации
функциональности системы для конечного пользователя - нельзя, а вот
минимизировать изменяемое состояние без потерь для конечного
пользователя - можно.</p><p>В программах ориентированных на вычисления (компиляторы, например)
количество изменяемого состояния можно вообще свести к нулю.</p><p>В программах ориентированных на хранение данных (90% бэков) в принципе
можно свести изменяемое состояние к одной переменной - изменяемой ссылке
на неизменяемую структуру данных- см. <a href=https://redux.js.org/>Redux</a> и
<a href=https://www.datomic.com/>Datomic</a>. И
<a href=https://github.com/d-r-q/qbit/>qbit</a> - примажусь к известным и
популярным:)</p><p>Это наблюдение подсказывает нам как разрешить Дилемму Эффектов</p></section><section class="doc-section level-1"><h2 id=_разрешение_дилеммы_эффектов>Разрешение Дилеммы Эффектов</h2><p>Для разрешения Дилеммы Эффектов Эргономичный Подход Сводит К Минимуму
Количество Эффектов В Программе За Счёт (<em>эм, чёт я Тайтл-кейсом
увлёкся:)</em>) минимизации изменяемого состояния, а оставшиеся эффекты
берёт под контроль за счёт дисциплины и ряда других техник, о которых я
напишу позже.</p><p>Если же вы не берёте эффекты под контроль, то в вашем коде начинают
появляться грязные и побочные функции - идеальная среда для размножения
багов - и это тема нашего следующего поста:)</p></section></article><br></section></div></main><script src=/js/app.js></script></body></html>