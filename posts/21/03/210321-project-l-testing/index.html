<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Тесты, которым можно доверять - Алексей Жидков"><meta property="og:description" content="Опыт организации тестирования проекта с 0 (нулём) регрессий."><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/21/03/210321-project-l-testing/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/21/03/210321-project-l-testing/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/21/03/210321-project-l-testing/><title>Тесты, которым можно доверять - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/21/03/210321-project-l-testing/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li><li class=multilingual-separator><p>|</p></li><li class="navigation-item align-left"><a href=https://azhidkov.pro/en/>En</a></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Тесты, которым можно доверять</h1><h2 class=date>March 13, 2021</h2></header><p>Я сейчас делаю проект с чистого листа, в котором я основой и ведущий бакэндер.
И, естественно, я его делаю в соответствии с Эргономичным Подходом.</p><p>Главным условием для того, чтобы кодовая база была эргономичной является набор тестов, которым можно доверять.
Если тесты прошли - можно релизать.
И никак иначе.</p><p>В этом посте я расскажу, как я организовал тестирование "Проекта Л".</p><section class="doc-section level-1"><h2 id=_проект_л>Проект Л</h2><p>Проект под NDA, поэтому в подробностях я его описать не могу, но могу привести ряд ключевых характеристик:</p><div class=ulist><ul><li>Целью проекта является проверка бизнес-гипотезы;</li><li>У заказчика есть большое основное приложение, и Проект Л реализуется как внешний клиент этого приложения, работающий через публичное HTTP API;</li><li>Основная ценность проекта заключена во фронте, поэтому на бэке буквально три тривиальных бизнес-правила;</li><li>Большинство реализаций методов Проекта Л идёт за данными в несколько методов основного приложения;</li><li>Поэтому в Проекте Л довольно сложная схема трансформации и кэширования данных;</li><li>У основного проекта есть тестовая среда;</li><li>У Проекта Л фиксированные и довольно ограниченные бюджет и сроки;</li><li>На этапе анализа одного из этапов я допустил две ошибки, и реализацию пришлось два раза сильно перетрясти и отрефакторить.</li></ul></div></section><section class="doc-section level-1"><h2 id=_релизный_цикл_внутренних_версий>Релизный цикл внутренних версий</h2><p>Сейчас у меня разработка идёт примерно такими циклами:</p><div class="olist arabic"><ol class=arabic><li>Что-то подевелопать.
Возможно, сильно перетрясти реализацию;</li><li>Запушить код, при пуше СИ прогоняет тесты;</li><li>Если я забыл сам прогнать тесты перед пушем и на СИ тесты упали - исправить ошибки;</li><li>Как только тесты на СИ прошли - выкатывается внутренний релиз.</li></ol></div><p>Ручного тестирования не делаю совсем.
И при этом за два месяца разработки мне от заказчика прилетел 1 (один) баг и 0 (ноль) регрессий.</p><p>Добился я этого покрыв код шестью видами тестов.</p></section><section class="doc-section level-1"><h2 id=_модули_проекта>Модули проекта</h2><p>Проект я разбил на четыре модуля:</p><div class="olist arabic"><ol class=arabic><li>core - "бизнес-логика" (на самом деле интеграционная логика) проекта.
Содержит сервисы, модель данных и интерфейсы репозиториев.
Плюс я в этот же модуль положил реализацию клиента основного проекта;</li><li>app - инфраструктура проекта. В этом модуле появляется Spring, работа с БД, ХТТП и т.п.</li><li>itests - тесты, работающие по HTTP;</li><li>test-fixtures - константы и утилитарные функции для всех видов тестирования.</li></ol></div></section><section class="doc-section level-1"><h2 id=_библиотеки_тестирования>Библиотеки тестирования</h2><div class=ulist><ul><li><a href=https://junit.org/junit5/>JUnit 5</a> - де-факто стандартная библиотека тестирования для платформы Java;</li><li><a href=https://kotest.io/docs/assertions/assertions.html>kotest</a> - библиотека ассёртов заточенная под Котлин;</li><li><a href=https://www.testcontainers.org/>testcontainers</a> - библиотека управления Docker-контейнерами в тестах;</li><li><a href=http://wiremock.org/>WireMock</a> - инструмент, который позволяет мокать серверы на уровне HTTP;</li><li><a href=https://rest-assured.io/>Rest-assured</a> - DSL для написания тестов REST-сервисов.</li></ul></div></section><section class="doc-section level-1"><h2 id=_виды_тестов>Виды тестов</h2><p>В проекте у меня есть следующие виды тестов:</p><div class=ulist><ul><li>Юнит-тесты;</li><li>Тесты работы с БД;</li><li>Тесты работы с АПИ основной системы;</li><li>Интеграционные тесты;</li><li>АПИ тесты;</li><li>Сценарные тесты.</li></ul></div><p>В следующем этапе я добавлю ещё пару нагрузочных тестов на критичные сценарии.</p><p>Все тесты помечены тегами и можно запустить каждую группу отдельно.
Но на практике я завёл два дополнительных Gradle-таска для запуска тестов: allTest - запускает всё кроме сценарных тестов и scenarioTest - запускает только сценарные тесты.
Стандартный таск test запускает только тесты без внешних зависимостей (юнит-тесты, тесты БД, интеграционные тесты).</p><section class="doc-section level-2"><h3 id=_юнит_тесты>Юнит-тесты</h3><div class=dlist><dl><dt>Назначение</dt><dd>Проверка бизнес-правил</dd><dt>Интерфейс</dt><dd>Прямой вызов методов боевого кода</dd><dt>Внутренние зависимости*</dt><dd>Нет</dd><dt>Внешние зависимости</dt><dd>Нет</dd><dt>Количество</dt><dd>26</dd></dl></div><p>В силу характера проекта по факту их практически нет - три теста на бизнес-правила и два теста парсер ответов основного проекта.
А 26 штук их из-за того, что одно из проверяемых бизнес-правил - валидация, и 21 из этих тестов порождены одним <a href=https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests>параметризованным тестом</a>.</p><p><em>* Внутренними зависимостями я называю зависимости, которые тест запускает сам для себя, а внешними - которые тест ожидает уже запущенными</em></p></section><section class="doc-section level-2"><h3 id=_тесты_работы_с_бд>Тесты работы с БД</h3><div class=dlist><dl><dt>Назначение</dt><dd>Проверка реализации репозиториев</dd><dt>Интерфейс</dt><dd>Прямой вызов методов боевого кода</dd><dt>Внутренние зависимости</dt><dd>Postgres (в testcontainers)</dd><dt>Внешние зависимости</dt><dd>Нет</dd><dt>Количество</dt><dd>17</dd></dl></div><p>Проверяют SQL-выражения на синтаксическую и семантическую корректность и маппинг объекты &lt;-> строки.
База для тестов поднимается в контейнере, но одна база используется для всех тестов в запуске.</p></section><section class="doc-section level-2"><h3 id=_тесты_работы_с_апи_основной_системы>Тесты работы с АПИ основной системы</h3><div class=dlist><dl><dt>Назначение</dt><dd>Проверка реализации клиента основной системы</dd><dt>Интерфейс</dt><dd>Прямой вызов методов боевого кода</dd><dt>Внутренние зависимости</dt><dd>мок основной системы на WireMock</dd><dt>Внешние зависимости</dt><dd>основная система</dd><dt>Количество</dt><dd>10</dd></dl></div><p>Преимущественно проверяют парсинг ответов.
Для проверки обработки ошибок запускается мок-сервер.</p></section><section class="doc-section level-2"><h3 id=_интеграционные_тесты>Интеграционные тесты</h3><div class=dlist><dl><dt>Назначение</dt><dd>Проверка поведения крупных блоков ядра системы в случаях, не покрытых АПИ тестами</dd><dt>Интерфейс</dt><dd>Прямой вызов методов боевого кода</dd><dt>Внутренние зависимости</dt><dd>Postgres (в testcontainers), мок основной системы на WireMock</dd><dt>Внешние зависимости</dt><dd>Нет</dd><dt>Количество</dt><dd>6</dd></dl></div></section><section class="doc-section level-2"><h3 id=_апи_тесты>АПИ тесты</h3><div class=dlist><dl><dt>Назначение</dt><dd>Эти тесты выполняют сразу четыре роли:<ul><li>Проверяют корректность конфигурации спринга, в особенности контроллеров и обработчика ошибок;</li><li>"Ковровым" энд-ту-энд тестированием покрывают весь "хэппи-пас" код системы, а также обработку ожидаемых ошибок;</li><li>Фиксируют АПИ, предотвращая обратно-несовместимые изменения;</li><li>Генерируют сниппеты для <a href=https://spring.io/projects/spring-restdocs>Spring Rest Docs</a>.</li></ul></dd><dt>Интерфейс</dt><dd>Обращение к бэку по HTTP через RestAssured и кастомного клиента.</dd><dt>Внутренние зависимости</dt><dd>мок основной системы на WireMock</dd><dt>Внешние зависимости</dt><dd>запущенное приложение (бэк+Postgres в docker-compose)</dd><dt>Количество</dt><dd>37</dd></dl></div><p>Как видно из количества, именно на АПИ тесты я сделал упор в тестировании Проекта Л.
Они тестируют всю систему целиком, покрывают все базовые "хэппи пасы" и обработку всех ожидаемых ошибочных ситуаций.
Чтобы обеспечить контроль обратной совместимости, АПИ тесты не зависят от модулей основного приложения и, соответственно, урлы и структуры данных в них дублируются.</p><p>Запросы делятся на два вида: фикстурные и контрольные.
Для выполнения фикстурных запросов написан специальный класс, выставляющий HTTP-интерфейс бэка в виде Котлин-класса.
Ответ на фикстурные запросы никак не проверяется.
Контрольные запросы выполняются по средствам RestAssured.</p></section><section class="doc-section level-2"><h3 id=_сценарные_тесты>Сценарные тесты</h3><div class=dlist><dl><dt>Назначение</dt><dd>Проверка протоколов взаимодействия фронта и бэка и бэка и основной системы</dd><dt>Интерфейс</dt><dd>Обращение к бэку по HTTP через кастомного клиента.</dd><dt>Внутренние зависимости</dt><dd>нет</dd><dt>Внешние зависимости</dt><dd>запущенное приложение (бэк+Postgres в docker-compose), основная система.</dd><dt>Количество</dt><dd>8</dd></dl></div><p>Эти тесты проверяют работу бэка в условиях максимально приближенных к боевым:</p><div class=ulist><ul><li>Бэк работает с основной системой;</li><li>Тесты симулируют поведение фронта.</li></ul></div></section></section><section class="doc-section level-1"><h2 id=_мокистабы>Моки/стабы</h2><p>Я совсем не использую библиотеки для мокирования классов.
Основные причины две.</p><p>С одной стороны, я не доверяю тестам с моками.
У меня довольно большой опыт работы в проектах с "тестами" на моках, и в таких проектах всегда было ручное тестирование и оно всегда находило регрессии в "зелёных" сборках.</p><p>С другой стороны, моки тестируют реализацию, а не контракт.
Из-за чего после каждого рефакторинга приходится ещё примерно столько же времени тратить на переписывание тестов.</p><p>У Теда Нединского есть пара хороших статей на эту тему:</p><div class=ulist><ul><li><a href=https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html>The influence of testing on design</a> - тут он пишет чем хороши тесты на границах системы;</li><li><p><a href=https://www.tedinski.com/2018/10/09/relationship-induction-and-tests.html>Testing, induction, and mocks</a> - а тут он пишет о проблемах, создаваемых моками.</p><p>В этой статье мне показалась особенно интересной мысль об однобокости моков - моки говорят, что система будет вести себя таким-то обрзаом.
Но при этом никак не контролируют, что в рантайме система будет вести себя таким образом.</p></li></ul></div></section><section class="doc-section level-1"><h2 id=_статистика>Статистика</h2><p>Бытует мнение, что интеграционные тесты долго писать и долго прогонять, поэтому приведу немного своей статистики.</p><div class=dlist><dl><dt>Общее количество эндпоинтов</dt><dd>10</dd><dt>Общее количество тестов</dt><dd>104</dd><dt>Время запуска тестов локально</dt><dd>~20 секунд</dd><dt>Время прогона СИ-пайплайна на Github Actions</dt><dd>4-5 минут</dd><dt>Отношение продового кода к тестам</dt><dd><code>2665 / 3503 = ~3/4</code><br>Но надо учитывать, что АПИ-тесты включают довольно развесистые партяники стабов JSON-ответов и доки на Spring Rest Docs:</dd></dl></div><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=nf>filter</span><span class=p>(</span>
    <span class=nf>document</span><span class=p>(</span>
        <span class=s>&#34;login-ok&#34;</span><span class=p>,</span>
        <span class=nf>preprocessRequest</span><span class=p>(</span><span class=nf>prettyPrint</span><span class=p>()),</span>
        <span class=nf>preprocessResponse</span><span class=p>(</span><span class=nf>prettyPrint</span><span class=p>()),</span>
        <span class=nf>requestFields</span><span class=p>(</span>
            <span class=nf>fieldWithPath</span><span class=p>(</span><span class=s>&#34;login&#34;</span><span class=p>).</span><span class=nf>description</span><span class=p>(</span><span class=s>&#34;Телефон или емейл&#34;</span><span class=p>)</span>
                <span class=p>.</span><span class=nf>attributes</span><span class=p>(</span><span class=n>credsConstraints</span><span class=p>.</span><span class=nf>constraintsFor</span><span class=p>(</span><span class=s>&#34;login&#34;</span><span class=p>)),</span>
            <span class=nf>fieldWithPath</span><span class=p>(</span><span class=s>&#34;password&#34;</span><span class=p>).</span><span class=nf>description</span><span class=p>(</span><span class=s>&#34;Пароль&#34;</span><span class=p>)</span>
                <span class=p>.</span><span class=nf>attributes</span><span class=p>(</span><span class=n>credsConstraints</span><span class=p>.</span><span class=nf>constraintsFor</span><span class=p>(</span><span class=s>&#34;password&#34;</span><span class=p>)),</span>
        <span class=p>),</span>
        <span class=nf>responseFields</span><span class=p>(</span>
            <span class=nf>fieldWithPath</span><span class=p>(</span><span class=s>&#34;token&#34;</span><span class=p>).</span><span class=nf>description</span><span class=p>(</span><span class=s>&#34;Авторизационный токен&#34;</span><span class=p>)</span>
                <span class=p>.</span><span class=nf>attributes</span><span class=p>(</span><span class=n>authConstraints</span><span class=p>.</span><span class=nf>constraintsFor</span><span class=p>(</span><span class=s>&#34;token&#34;</span><span class=p>)),</span>
        <span class=p>)</span>
    <span class=p>)</span>
<span class=p>)</span></code></pre></div></section><section class="doc-section level-1"><h2 id=_как_найти_время_на_тесты>Как найти время на тесты</h2><p>Во-первых, не выделять их в оценке отдельным пунктом:)
Не "день на реализацию и день на тесты", а "два дня на реализацию".</p><p>Во-вторых, начинать разработку с тестов.
Вообще, я не сторонник и не практикую Test-Driven Development, противник Test-Driven Design.
Но при этом если я нахожу баг или регрессию, то я первым делом пишу тест, который воспроизводит проблему.
Для новых фич бывает по-разному - когда-то я начинаю с АПИ-теста, когда-то с юнит-теста, когда-то совсем без теста.</p><p>Тесты, помимо повышения скорости разработки и качества в долгосрочной перспективе, прямо сейчас ускоряют разработку, благодаря автоматизации запуска и проверки функциональности.</p></section><section class="doc-section level-1"><h2 id=_заключения>Заключения</h2><p>Не смог найти источник, но кажется в где-то "Чистой Архитектуре" Анкл Боб писал что-то в таком духе:</p><div class=quote-block><blockquote><p>Если у меня будет выбор взять систему с хорошей архитектурой или хорошими тестами, то я выберу вторую".
Если есть тесты которым, можно доверять, то архитектуру можно исправить, а если тестов нет, то с системой ничего невозможно сделать.</p></blockquote></div><p>И я с этим польностью согласен, надёжные тесты - неотъемлемая часть эргономичной кодовой базы.</p><p>В этом проекте мне пришлось дважды перетрясти архитектуру:</p><div class="olist arabic"><ol class=arabic><li>Один раз пришлось поменять отношение между двумя ядерными сущностями с 1-N на N-M;</li><li>Второй раз пришлось поменять загрузку данных с синхронной, на асинхронную предзагрузку.</li></ol></div><p>Благодаря описанной стратегии тестирования мне удалось провести оба рефакторинга без видимых для заказчика регрессий. <span class=logo><img src=/images/logo.svg alt=logo></span></p></section></article><br></section></div></main><script src=/js/app.js></script></body></html>