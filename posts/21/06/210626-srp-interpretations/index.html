<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Многоликий принцип единственности ответственности - Алексей Жидков"><meta property="og:description" content="Принцип единственности ответственности? Что именно вы имеете ввиду?"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/21/06/210626-srp-interpretations/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/21/06/210626-srp-interpretations/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/21/06/210626-srp-interpretations/><title>Многоликий принцип единственности ответственности - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/21/06/210626-srp-interpretations/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/book/ergo>Книга</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li><li class=multilingual-separator><p>|</p></li><li class="navigation-item align-left"><a href=https://azhidkov.pro/en/>En</a></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Многоликий принцип единственности ответственности</h1><h2 class=date>June 21, 2021</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><p>Кажется, любой "солидный" программист знает что такое SOLID вообще и принцип единственности ответственности (SRP) в частности.</p><details><summary>Спойлер, если вдруг не знаете</summary><div class=content><p>SOLID - это название принципов объектно-ориентированного дизайна, сформулированных Робертом Мартином, так же известным как анкл Боб.
Принципы звучат следующим образом:</p><div class="olist arabic"><ol class=arabic><li><span class=big><strong>S</strong></span>ingle Responsibility Principle: A module should have one, and only one, reason to change.</li><li><span class=big><strong>O</strong></span>pen/Closed Principle:: A software artifact should be open for extension but closed for modification.</li><li><span class=big><strong>L</strong></span>iskov Substitution Principle:: What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T</li><li><span class=big><strong>I</strong></span>nterface Segregation Principle:: Clients should not be forced to depend upon interfaces that they do not use.</li><li><span class=big><strong>D</strong></span>ependency Inversion Principle::<ol class=upperalpha><li>High level modules should not depend upon low level modules. both should depend upon abstractions.</li><li>Abstractions should not depend upon details. details should depend upon abstractions.</li></ol></li></ol></div></div></details><p>Когда речь заходит об SRP, я всегда уточняю, что именно имеет ввиду мой собеседник.
Потому что у SRP существует как минимум пять разных формулировок и три интерпретации.
И я не думаю, что подобная эмм…​ штуковина является хорошим руководством по разработке ПО.</p><section class="doc-section level-1"><h2 id=_формулировки_srp>Формулировки SRP</h2><p>Для начала приведу неверную, но самую популярную формулировку:</p><div class=quote-block><blockquote><p>Класс должен делать одну вещь</p><footer>— <cite>народ</cite></footer></blockquote></div><p>Которой вторит и русская википедия:</p><div class=quote-block><blockquote><p>Для каждого класса должно быть определено единственное назначение.
Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.</p><footer>— <cite>Википедия, https://ru.wikipedia.org/wiki/SOLID_(объектно-ориентированное_программирование)</cite></footer></blockquote></div><p>Хотя английская версия той же статьи приводит одну из формулировок Мартина.</p><p>Вообще, такой принцип есть - это один из принципов философии Unix.
Но сам Мартин пишет в Чистой Архитектуре, что это не SRP:</p><div class=quote-block><blockquote><p>It is too easy for programmers to hear the name and then assume that it means that every module should do just one thing.</p><p>Make no mistake, there is a principle like that. […​]
But it is not one of the SOLID principles — it is not the SRP.</p><footer>— <cite>Robert C. Martin, Clean Architecture</cite></footer></blockquote></div><hr><p>Сам Мартин формулирует SRP тремя разными способами:</p><div class=dlist><dl><dt>Формулировка 2003 года</dt></dl></div><div class=quote-block><blockquote><p>The Single Responsibility Principle (SRP) states that a class or module should have one, and only one, reason to change</p><footer>— <cite>Robert C. Martin, Agile software development Principles Patterns and Practices</cite></footer></blockquote></div><div class=dlist><dl><dt>Формулировка 2014 года</dt></dl></div><div class=quote-block><blockquote><p>Gather together the things that change for the same reasons.
Separate those things that change for different reasons.</p><footer>— <cite>Robert C. Martin, The Single Responsibility Principle</cite></footer></blockquote></div><div class=dlist><dl><dt>Формулировка 2018 года</dt></dl></div><div class=quote-block><blockquote><p>A module should be responsible to one, and only one, actor</p><footer>— <cite>Robert C. Martin, Clean Architecture</cite></footer></blockquote></div><p>Чтобы понять, что у них общего, мне потребовалось по три прочтения всех публикаций Мартина об SRP.
Вы же сэкономите день-два жизни и получите ответ за пятнадцать минут, если дочитаете пост до конца.</p><p>Для начала рассмотрим как анкл Боб объясняет SRP последние двадцать лет.</p></section><section class="doc-section level-1"><h2 id=_объяснения_srp>Объяснения SRP</h2><p><strong>Agile software development Principles Patterns and Practices, 2003</strong></p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Любопытный факт - SRP появился на восемь лет позже остальных принципов SOLID, и изначальный порядок был другой - OLDI.
А акроним SOLID придумал не анкл Боб, а Майкл Фэзерс.</p></aside><p>Впервые SRP появился в <a href=https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445>Agile software development Principles Patterns and Practices</a>.
В этой книге Мартин пояснял его на примере разделения кода различных <strong>функций программы</strong>:</p><div class=quote-block><blockquote><p>Consider the bowling game from Chapter 6.
For most of its development the Game class was handling two separate responsibilities.
It was keeping track of the current frame, and it was calculating the score.
In the end, RCM and RSK separated these two responsibilities into two classes.
The Game kept the responsibility to keep track of frames, and the Scorer got the responsibility to calculate the score. (see page 85.)</p><footer>— <cite>Robert C. Martin, Agile software development Principles Patterns and Practices</cite></footer></blockquote></div><p><strong>Clean Code, 2008</strong></p><p>Пояснять SRP на примере разделения кода по <strong>функциям программы</strong> Мартин продолжает и в <a href=https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882>Clean Code</a>:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SuperDashboard</span> <span class=kd>extends</span> <span class=nc>JFrame</span> <span class=kd>implements</span> <span class=nc>MetaDataUser</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=nc>Component</span> <span class=nf>getLastFocusedComponent</span><span class=o>()</span>
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>setLastFocused</span><span class=o>(</span><span class=nc>Component</span> <span class=n>lastFocused</span><span class=o>)</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getMajorVersionNumber</span><span class=o>()</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getMinorVersionNumber</span><span class=o>()</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getBuildNumber</span><span class=o>();</span>
<span class=o>}</span></code></pre></div><div class=quote-block><blockquote><p>The seemingly small SuperDashboard class in Listing 10-2 has two reasons to change.
First, it tracks version information that would seemingly need to be updated every time the software gets shipped.
Second, it manages Java Swing components (it is a derivative of JFrame, the Swing representation of a top-level GUI window)</p><footer>— <cite>Robert C. Martin, Clean Code</cite></footer></blockquote></div><p><strong>The Clean Coder, 2011</strong></p><p>Затем в <a href="https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073/ref=pd_sim_5/131-9122726-9479409?pd_rd_w=0NdTd&pf_rd_p=d88e414a-c661-4436-b6ed-003c19da9b92&pf_rd_r=6FTHCEPHBC1138C43SJ9&pd_rd_r=28244df1-86a2-478b-85b3-5e3542ecf45b&pd_rd_wg=H5iaV&pd_rd_i=0137081073&psc=1">The Clean Coder</a> анкл Боб иллюстрирует SRP уже примером разделения <strong>аспектов реализации</strong> (пользовательского интерфейса и бизнес-правил):</p><div class=quote-block><blockquote><p>There is a design principle called the Single Responsibility Principle (SRP).
This principle states that you should separate those things that change for different reasons, and group together those things that change for the same reasons.
GUIs are no exception.</p><p>The layout, format, and workflow of the GUI will change for aesthetic and efficiency reasons, but the underlying capability of the GUI will remain the same.</p><p>[...]</p><p>Design experts have been telling us for decades to separate our GUIs from our business rules.</p><footer>— <cite>Robert C. Martin, The Clean Coder</cite></footer></blockquote></div><p><strong>The Single Responsibility Principle, 2014</strong></p><p>В <a href=https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html>следующей</a> публикации о SRP анкл Боб уже напрямую использует термин "разделение <strong>аспектов [реализации]</strong>" (separation of concerns):</p><div class=quote-block><blockquote><p>Two years later, Edsger Dijkstra wrote another classic paper entitled On the role of scientific thought. in which he introduced the term: The Separation of Concerns.
[...]
This is the reason we do not put SQL in JSPs.
This is the reason we do not generate HTML in the modules that compute results.
This is the reason that business rules should not know the database schema.
This is the reason we separate concerns.</p><footer>— <cite>Robert C. Martin, https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</cite></footer></blockquote></div><p>Но здесь же, Мартин впервые объясняет SRP совсем в другом ключе:</p><div class=quote-block><blockquote><p>And this gets to the crux of the Single Responsibility Principle.
This principle is about people.</p><p>When you write a software module, you want to make sure that when changes are requested, those changes can only originate from a single person, or rather, a single tightly coupled group of people representing a single narrowly defined business function.</p><footer>— <cite>Robert C. Martin, https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</cite></footer></blockquote></div><p>Здесь уже речь идёт о разделении кода по <strong>людям</strong>.</p><p><strong>Clean Architecture, 2018</strong></p><p>В окончательной же форме это объяснение появляется ещё через четыре года в <a href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164/ref=pd_sim_1/131-9122726-9479409?pd_rd_w=Kj7C7&pf_rd_p=d88e414a-c661-4436-b6ed-003c19da9b92&pf_rd_r=0ZQVJKRJ6VFKKPXGBRJA&pd_rd_r=664e0c37-918c-4613-b12d-6e758d26e96b&pd_rd_wg=DAys9&pd_rd_i=0134494164&psc=1">Clean Architecture</a>:</p><div class=quote-block><blockquote><p>A module should be responsible to one, and only one, actor</p><footer>— <cite>Robert C. Martin, Clean Architecture</cite></footer></blockquote></div><p>Действующим лицом (actor) в этом случае является группа <a href=https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%B9%D0%BA%D1%85%D0%BE%D0%BB%D0%B4%D0%B5%D1%80>стейкходеров</a> (людей так или иначе причастных к программе и её созданию) с одинаковыми потребностями.</p></section><section class="doc-section level-1"><h2 id=_шестая_формулировка_srp>Шестая формулировка SRP</h2><p>Мне кажется более понятной шестая (уже моя) формулировка SRP:</p><div class=quote-block><blockquote><p>Модуль должен отвечать за реализацию требований одного стейкхолдера.</p><footer>— <cite>Алексей Жидков, Многоликий принцип единственности ответсвенности</cite></footer></blockquote></div><p>Эта формулировка привязывается ко вполне определённому понятию - "требование".
На мой взгляд, термин "требование" вызывает намного меньше разночтений, чем "действующее лицо".
"Действующее лицо" - крайне неудачный термин, так как он чаще встречается в значении "пользователь программы", популяризированном UML-ем.</p><p>В моей формулировке понятно, почему надо разделять модули хранения данных и представления.
Одни специфицируются человеком выполняющим роль администратора БД, а другие - человеком, выполняющим роль дизайнера интерфейсов.
Также понятно и почему надо разделять модули, отвечающие за реализацию функций CFO и COO - требования к ним определяется разными людьми из разных отделов.</p><p>Но и с этой формулировкой есть пара проблем.
Во-первых, инфраструктурные модули будут реализовывать минимум по два требования - функциональное и качественное.
Во-вторых, я не видел проекта, где были бы внятно прописаны функциональные и нефункциональные требования, список стейкхолдеров и их привязка друг к другу.</p><p>Ни эта, ни любая другая формулировка SRP не даёт программистам практического руководства к действию в каждодневной работе.
Может быть, будет полезнее разбить SRP на несколько практических рекомендаций?
Например:</p><div class="olist arabic"><ol class=arabic><li>формируйте направленный ациклический граф зависимостей между модулями;</li><li>разделяйте ввод-вывод (в том числе GUI) и бизнес-правила;</li><li>разделяйте код реализующий разные функции системы;</li><li>пишите тесты.
В тестах мокайте только внешние системы, а system under test создавайте "руками" (а не с помощью DI-контейнера).</li></ol></div><p>Эти рекомендации не нуждаются большом предварительном проектировании с определением стейкхолдеров и требований.
И следование им можно контролировать механически.</p><p>Применение таких рекомендаций в каждодневной работе доступно намного более широкому кругу программистов и также даст поддерживаемую и стабильную систему на выходе.</p><p>Помимо приведенных, есть ещё одна важная рекомендация: разделяйте "стандартную библиотеку" (домен) и "скрипты" (функции) приложения.
Об этом пишут и Мартин в Clean Architecture - разделение сущностей и интеракторов, и Эванс в DDD - разделение сервисов приложения и сущностей и доменных сервисов.
Но ни они, ни я не можем дать объективного критерия, по которому можно следить за соблюдением этой рекомендации механически.
Поэтому я не включаю её в ряд простых и понятных.</p></section><section class="doc-section level-1"><h2 id=_на_суку_висит_мочало_начинаем_всё_сначала>На суку висит мочало, начинаем всё сначала</h2><div class=image-block><img src=/posts/21/06/images/years-without-new-srp-version.png alt="years without new srp version"></div><p><strong>SOLID relevance, 2020</strong></p><p>Постоянное изменение формулировок и интерпретаций SRP можно было бы объяснить эволюцией понимания SRP самим Мартином.
Сначала для него SRP был о разделении по функциям программы.
Потом он понял, что по аспектам реализации код тоже необходимо разделять.
Наконец, анкл Боб обобщил их через разделение по требованиям различных действующих лиц.</p><p>Это было отличное объяснение развития событий.
Пока Мартин не написал свой последний пост на тему SRP.
В нём он снова откатился к разделению только по аспектам:</p><div class=quote-block><blockquote><p>It is hard to imagine that this principle is not relevant in software.
We do not mix business rules with GUI code.
We do not mix SQL queries with communications protocols.</p><footer>— <cite>Robert C. Martin, https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html</cite></footer></blockquote></div><p>Если посмотреть на историю объяснений SRP с высоты "птичьего полёта", то становится видно что анкл Боб постоянно скачет между этими критериями декомпозиции кода:</p><figure class=table-block><figcaption>История интерпретаций SRP</figcaption><table class="frame-all grid-all stretch"><col style=width:11.1111%><col style=width:33.3333%><col style=width:55.5556%><thead><tr><th class="halign-left valign-top">Год</th><th class="halign-left valign-top">Источник</th><th class="halign-left valign-top">Критерий разделения</th></tr></thead><tbody><tr><td class="halign-left valign-top">2003</td><td class="halign-left valign-top">Agile software development Principles Patterns and Practices</td><td class="halign-left valign-top">Функциональность и<br>намёк на действующее лицо*</td></tr><tr><td class="halign-left valign-top">2008</td><td class="halign-left valign-top">Clean Code</td><td class="halign-left valign-top">Функциональность</td></tr><tr><td class="halign-left valign-top">2011</td><td class="halign-left valign-top">The Clean Coder</td><td class="halign-left valign-top">Аспект реализации</td></tr><tr><td class="halign-left valign-top">2014</td><td class="halign-left valign-top">The Single Responsibility Principle</td><td class="halign-left valign-top">Функциональность, аспект реализации и действующее лицо</td></tr><tr><td class="halign-left valign-top">2018</td><td class="halign-left valign-top">Clean Architecture</td><td class="halign-left valign-top">Функциональность и действующее лицо,<br>в меньшей степени аспект реализации**</td></tr><tr><td class="halign-left valign-top">2020</td><td class="halign-left valign-top">SOLID Relevance</td><td class="halign-left valign-top">Аспект реализации</td></tr></tbody></table></figure><aside class=sidebar><p>* В Agile software development Principles Patterns and Practices был и другой пример в главе про SRP.</p><div class=image-block><img src=/posts/21/06/images/rectangle.png alt=rectangle></div><div class=quote-block><blockquote><p>Two different applications use the Rectangle class.
One application does computational geometry.
It uses Rectangle to help it with the mathematics of geometric shapes.
It never draws the rectangle on the screen.
The other application is graphical in nature.
It may also do some computational geometry, but it definitely draws the rectangle on the screen.</p><footer>— <cite>Robert C. Martin, Agile software development Principles Patterns and Practices</cite></footer></blockquote></div><p>Глядя на этот пример (из 2021 года) можно прийти к выводу, что у разных приложений будут разные пользователи (один из видов действующих лиц) и методы draw и area реализуют требования разных действующих лиц.</p><hr><p>** В Clean Architecture разделение по аспекту реализации тоже присутствует (метод save, определяемый CTO).
Но в этой книге Мартин уже явно не проговаривает необходимость разделения по аспектам.
В сочетании с нетипичным значением слова actor, это приводит к тому, что такое объяснение можно проинтерпретировать как декомпозицию только на основе пользователей программы.
Это может стать четвёртой интерпретацией SRP, но в жизни я её пока не встречал.</p></aside><p>Разделение по функциональности и аспектам реализации программы - это не две разные точки зрения на один принцип.
Это два разных принципа декомпозиции, которые ведут к разным результатам.</p><section class="doc-section level-2"><h3 id=_разделение_кода_по_функциональности_разделению_кода_по_аспектам_реализации>Разделение кода по функциональности != разделению кода по аспектам реализации</h3><p>Можно разделять SQL и JSP и всё ещё использовать один и тот же код в разных функциях и ломать функции одних пользователей при модификации функций других пользователей.</p><p>И наоборот, можно завести по микросервису для каждого пользователя или функции системы и собрать в один метод и парсинг json-а, и бизнес-правила, и выполнение SQL-запросов.
В итоге получить хрупкий код, который трудно поддерживать.</p><p>Аспекты реализации функциональности и сама функциональность - ортогональные оси декомпозиции кода.</p><p>SRP нарушает одну из собственных интерпретаций и смешивает различные аспекты дизайна программ.
Зачем анкл Боб объединил два разных принципа в один - я не понимаю.
Возможно, он сам не сразу понял, что код надо разделять и по функциональности, и по аспектам реализации, а когда понял - SOLID стал уже брендом, который было жаль терять.</p><p>Можем ли мы полагаться на принцип, формулировка и интерпретация которого меняется каждые три года?
Я думаю нет.</p></section></section><section class="doc-section level-1"><h2 id=_нам_нужны_новые_принципы>Нам нужны новые принципы</h2><p>В итоге мы приходим к тому, что:</p><div class=ulist><ul><li>вообще, не очень понятно, что такое SRP.
Разные разработчики понимают под этой аббривиатурой разные принципы дизайна.
Даже сам Мартин постоянно по-разному формулирует и иллюстрирует SRP;</li><li>то, что мне кажется Единственно Верной Версией SRP, невозможно использовать на практике.
Потому что в реальной жизни необходимую для этой версии аналитику никто не делает.</li><li>а если бы и делали, то SRP-идеал всё равно был бы недостижим.
Так как у значительной части кода будет как минимум две причины для изменения - требования к функциональности и требования к способу реализации.</li></ul></div><p>И хотя SRP является самым неоднозначным принципом SOLID-а, остальные четыре принципа тоже имеют разночтения и пробелемы с приминением на практике.
Поэтому я не думаю, что SOLID в своём текущем виде является хорошим руководством по дизайну систем.</p><p>Тем не менее, в SOLID заключено много хороших и полезных идей, поэтому я не предлагаю упразднить его - я предлагаю его реставрировать.
Актуальные идеи вычленить, уточнить и проиллюстрировать хорошими примерами.
То, что потеряло свою значимость - убрать.</p><p>И главное - не загонять себя в рамки того, чтобы из первых букв новых принципов можно было составить красивый акроним.</p></section></article><br></section></div></main><script src=/js/app.js></script></body></html>