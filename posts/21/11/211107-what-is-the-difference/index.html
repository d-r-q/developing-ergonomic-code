<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Что я делаю не так. - Алексей Жидков"><meta property="og:description" content="Рассмотрим в чём разница для бизнеса между типовым и эргономичным подходами"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/21/11/211107-what-is-the-difference/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/21/11/211107-what-is-the-difference/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/21/11/211107-what-is-the-difference/><title>Что я делаю не так. - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/21/11/211107-what-is-the-difference/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/book/ergo>Книга</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li><li class=multilingual-separator><p>|</p></li><li class="navigation-item align-left"><a href=https://azhidkov.pro/en/>En</a></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Что я делаю не так.</h1><h2 class=date>November 6, 2021</h2></header><div class=quote-block><blockquote><p>"Алексей - один из лучших разработчиков, с которыми я работал. Работой с ним я удовлетворён на 10 баллов из 10, потому что он практически всегда попадает в озвученные сроки, и в работе с ним не приходится накидывать 50% на всякий пожарный".</p><footer>— <cite>Денис Исаев, руководитель проектов</cite></footer></blockquote></div><p>Привет!
Алексей - это я.
В этом посте я расскажу, что я делаю не так, как принято, чтобы получать такие отзывы.</p><p>Свой подход к разработке я называю Эргономичным и от общепринятого он отличается следующим:</p><div class="olist arabic"><ol class=arabic><li>Я не пишу на Java, а пишу на Kotlin</li><li>Я не использую Spring Data JPA, а использую Spring Data JDBC/R2DBC</li><li>Я не игнорирую концепции состояния системы и эффектов операций, а тщательно их проектирую</li><li>Я не структурирую программы исходя из собственного чувства прекрасного, а применяю принципы структурного дизайна</li><li>Я не использую императивный стиль программирования, а предпочитаю декларативный стиль</li><li>Я не декомпозирую систему на слои, а разделяю на концептуальные модули (пакеты)</li><li>Я не отдаю конфигурацию системы на откуп Spring-овой автомагии, а описываю её руками</li><li>Я не пишу тесты, которые проверяют детали реализации, а пишу тесты, которые проверяют поведение</li><li>Я не использую микросервисную архитектуру для структурирования системы, а начинаю с модульных монолитов</li></ol></div><p>Давайте разбираться, почему я всё это делаю не так, как принято и к чему это приводит для бизнеса.</p><section class="doc-section level-1"><h2 id=_язык_программирования>Язык программирования</h2><p>Как это ни странно, Java-команды для разработки обычно выбирают язык Java.
Действительно, Java 17 - неплохой язык программирования, а эргономичный подход можно использовать практически с любым языком.
Но некоторые языки делают разработку дешевле, а применение эргономичного подхода проще, чем другие.</p><p>Для себя я в качестве основного языка разработки выбрал Kotlin ещё в 2015 году.</p><p>Kotlin обладает рядом особенностей, которые положительно влияют и на качество продукта, и на стоимость его разработки:</p><div class="olist arabic"><ol class=arabic><li>Поддержка nullable-значений на уровне системы типов.
По данным Google <a href=#fc>[fc]</a>, в Google Play количество NullPointerException-ов в приложениях на Kotlin на 33% меньше, чем в приложениях на Java.
Я думаю одна эта особенность языка на 1-2% снижает стоимость разработки и на столько же увеличивает лояльность пользователей.</li><li>Корутины.
В Java нет и не предвидится прямого аналога корутин.
Базовая для Java модель конкурентного программирования - на потоках - и масштабируется для IO-интенсивных нагрузок намного хуже, чем корутины и намного более подвержена ошибкам <a href=#sc>[sc]</a>.
Библиотеки, реализующие акторный подход, обладают схожими характеристиками по масштабируемости и надёжности, но намного более громоздки в работе, чем корутины.
Project Loom, не выпущен, и не даёт защиты от утечек асинхронных задач.
Project Reactor, даёт схожую степень масштабируемости, но не даёт тот же уровень надёжности.
Точных данных у меня нет, но я думаю корутины также дают 1-2% снижения стоимости разработки и увеличения стабильности работы приложения.</li><li>Kotlin Multiplatform.
У меня есть <a href=/portfolio/#udobno>опыт</a> успешного выделения самой сложной и дорогой части Android-приложения в общий модуль, с последующим его переиспользованием в iOS-приложении.
Подобного коммерческого опыта с выделением общего кода между сервером и клиентами у меня нет, но я вижу у этой технологии потенциал для сокращения стоимости разработки систем на десятки процентов.</li><li>По данным JetBrains программы на Kotlin содержат на 40% меньше строк исходного кода, чем аналогичные программы на Java <a href=#kf>[kf]</a>.
Это на 40% меньше усилий на написание кода, чтение кода, ревью кода и на экспоненциально меньше ошибок <a href=#cc>[cc]</a>.
Не думаю, что это даёт 40% сокращения стоимости разработки, но процентов 5-10 должно дать.</li><li>Есть ещё целый ряд небольших особенностей - функции расширения, более богатая стандартная библиотека, инлайн функции, овеществлённые дженерики и т.д. - которые по моей субъективной оценке дают ещё 1-2% сокращения стоимости разработки.</li></ol></div><p>Наконец, в контексте эргономичного подхода, лучшая поддержка декларативного программирования (предпочтение неизменяемых переменных и структур данных, функциональные типы и т.п.) Kotlin даёт ещё 1-2% процента снижения стоимости разработки.</p><p>Суммарно всё это даёт удешевление разработки на 10-15%.</p></section><section class="doc-section level-1"><h2 id=_технология_работы_с_бд>Технология работы с БД</h2><p>Обычно для работы с БД Java-команды без какого-либо критического анализа выбирают Spring Data JPA.</p><p>Одним этим решением команда обрекает бизнес на дорогой в разработке продукт с большим количеством ошибок и регрессий и постоянным ростом стоимости и сроков реализации требований.
Технология JPA - крайне неудачна и её драматическое влияние на качество всего продукта в целом я рассмотрю ниже.
Если же говорить только о технической стороне, то выбор JPA ведёт к:</p><div class="olist arabic"><ol class=arabic><li>Низкой отзывчивости приложения, из-за:<ol class=loweralpha type=a><li>Чрезмерной сложности технологии и, как следствие, большой разницей между поведением программы в голове программиста и реальным поведением <a href=#jpas>[jpas]</a></li><li>Лаконичности и "красоты" медленного кода (повсеместно использующего ленивую загрузку)</li><li>Кажущейся тяжеловесности быстрого кода (выполняющего необходимый минимум оптимальных запросов, извлекающих из БД только нужные данные)</li></ol></li><li>Высокой стоимости оборудования, необходимого для обеспечения хоть сколько-нибудь приемлемого уровня производительности</li><li>Большому количеству ошибок из-за:<ol class=loweralpha type=a><li>Всё той же разницей между поведением программы в голове программиста и реальным поведением</li><li>Возможности неявно и случайно (через мутацию объекта, доступного через несколько ссылок внутри транзакции) внести лишние изменения в хранимые данные</li></ol></li><li>Большому количеству регрессий.
JPA подталкивает программистов к тому, чтобы создавать высокую степень связанности (coupling) между различными модулями, через полносвязный двунаправленный граф всех сущностей системы <a href=#jag>[jag]</a>.
Как следствие, повышается вероятность регрессий в одних модулях, при внесении изменений в другие модули.</li><li>Непредсказуемому времени исправления ошибок.
Из-за высокой сложности ("автомагичности") JPA, зачастую программисты сталкиваются с проблемами, которые проявляются только в промышленной эксплуатации.
Такие проблемы совершенно непонятно чем вызваны, в какой момент что-то пошло не так и как всё это отлаживать и исправлять.
Как следствие, в проектах с JPA зачастую бывают "нормальные" исключения в логах - какие-то ошибки, с которыми не понятно что делать, но в целом можно жить.</li></ol></div><p>Подробнее о проблемах свойственных JPA можно почитать в моём <a href=/posts/21/04/why-jpa-should-be-avoided/>посте, посвящённом этому вопросу</a>.</p><p>Для решения описанных проблем я изучил рынок существующих решений для работы с БД, опробовал наиболее перспективные из них на практике и на данный момент остановился на Spring Data JDBC и R2DBC.
У этих технологий два ключевых преимущества перед технологиями, основывающимся на JPA:</p><div class="olist arabic"><ol class=arabic><li>В них минимум "автомагии" и из кода работы с БД очевидно какие запросы будут действительно выполнены.
Это положительно сказывается практически на всех аспектах приложения:<ol class=loweralpha type=a><li>Скорости работы приложения</li><li>Требованиях к ресурсам</li><li>Количеству ошибок</li><li>Времени исправления ошибок</li></ol></li><li>Использование Spring Data JDBC/R2DBC подталкивает программистов к разделению состояния системы на изолированные агрегаты.
Это уменьшает связанность (coupling) системы и как следствие удешевляет её развитие и уменьшает количество регрессий.</li></ol></div><p>В итоге использование Spring Data JDBC/R2DBC означает для бизнеса, что он быстрее и дешевле получит более стабильный и отзывчивый продукт, темп развития которого практически не будет падать со временем.</p></section><section class="doc-section level-1"><h2 id=_управление_состоянием_и_эффектами>Управление состоянием и эффектами</h2><p>Обычно для разработчиков термин "Состояние" ассоциируется только с одноимённым шаблоном проектирования, а "Эффект" вообще не имеет ассоциаций в контексте разработки информационных систем.</p><p>Между тем хранение и обработка <strong>состояния</strong>, является главной целью информационной системы.
Конечный пользователь воспринимает систему через эффекты отображения её текущего состояния, а корректность работы системы определяет по набору эффектов, осуществлённых в ответ на его действия.
Подробнее о состоянии, эффектах и их значимости можно почитать в моём <a href=/posts/21/01/210119-effects/>посте, посвящённом этому вопросу</a>.</p><p>Непонимание этих фундаментальных понятий приводит к тому, что команды формируют структуру состояния информационной системы хаотично, без какой-либо стратегии.
Это порождает запутанный граф состояния системы, зачастую с циклами и нестабильными зависимостями.
Такой граф сложно и понять, и модифицировать.</p><p>А пренебрежение эффектами ведёт к тому, что они разбросаны по коду в произвольных местах.
Это усложняет понимание того, к каким эффектам приведёт та или иная операция и наоборот, какие операции могут привести к тому или иному эффекту.
Также это существенно усложняет автоматизацию тестирования - тестирование кода с эффектами требует подготовки окружающей среды, с последующей проверкой изменений в ней.</p><p>Из-за этого разработчикам сложно понять все последствия вносимых изменений, и у них нет надёжной сетки безопасности в виде автоматических тестов.
В итоге, особенно под давлением, разработчики вносят вслепую изменения, которые решают поставленную задачу.
А выявление побочных эффектов этих изменений отдают на откуп QA и пользователям.
Порождая при этом дополнительные циклы разработчик-QA - дополнительные рабочие и календарные часы.</p><p>Отдельный вклад в хаос вносит применение JPA, которая:</p><div class="olist arabic"><ol class=arabic><li>Подталкивает программистов к созданию высоко связанной структуры состояний с двунаправленными связями <a href=#jag>[jag]</a>.</li><li>Подталкивает программистов к разбросу эффектов (ленивой загрузки и изменения полей сущностей, с последующим автоматическим сохранением) по всему коду бизнес-логики <a href=#hbp>[hbp]</a></li></ol></div><p>В итоге для бизнеса всё это выливается в повышенную стоимость и сроки реализации продукта, в том числе из-за большего количества регрессий.</p><p>Я же осознанно и целенаправлено формирую структуру состояния системы таким образом, чтобы минимизировать стоимость внесения изменений в неё.
Руководствуюсь я при этом давно известными принципами дизайна:</p><div class="olist arabic"><ol class=arabic><li>В структуре состояния системы не должно быть циклов <a href=#asdppp>[asdppp]</a></li><li>Зависимости должны быть направлены в сторону более стабильных элементов <a href=#asdppp>[asdppp]</a></li><li>Детали устройства элементов состояния с высокой вероятностью изменений должны быть инкапсулированы в границах соответствующих модулей <a href=#ih>[ih]</a></li><li>Наращивание функциональности системы должно выполняться за счёт расширения структуры состояния, а не модификации существующих элементов <a href=#asdppp>[asdppp]</a></li></ol></div><p>Для того чтобы сделать максимально явной связь операций системы и их эффектов на состояние, я использую менее известные, но тоже проверенные техники:</p><div class="olist arabic"><ol class=arabic><li>Структурный дизайн <a href=#sd>[sd]</a></li><li>Архитектуру функциональное ядро/императивная оболочка, которую я считаю развитием структурного дизайна <a href=#fcis>[fcis]</a></li></ol></div><p>Применение этих техник даёт:</p><div class="olist arabic"><ol class=arabic><li>Сокращение трудоёмкости реализации требований за счёт того, что:<ol class=loweralpha type=a><li>Изменения в структуре состояний инкапсулируются в одном модуле, либо затрагивают небольшое количество модулей</li><li>Последствия изменений в эффектах операции инкапсулируются в одном модуле, либо затрагивают небольшое количество модулей, список которых можно получить автоматически</li></ol></li><li>Минимизацию количества ошибок за счёт упрощения автоматизации тестирования бизнес-логики системы</li><li>Минимизацию количества регрессий, за счёт:<ol class=loweralpha type=a><li>Минимизации трудоёмкости изменений</li><li>Повышения видимости последствий изменений</li><li>Повышения покрытия автоматическими тестами</li></ol></li></ol></div><p>То есть мы снова приходим к тому, что бизнес получает более качественный продукт за меньшие деньги.</p></section><section class="doc-section level-1"><h2 id=_стиль_программирования>Стиль программирования</h2><p>Я не сталкивался с информационными системами, спроектированными другими людьми и не использующие JPA, поэтому не могу сказать является ли связь между JPA и процедурным стилем программирования причинно-следственной или корреляционной.
Тем не менее JPA не оставляет выбора и вынуждает использовать устаревший процедурный стиль кодирования, когда пакеты процедур (Сервисы) императивно модифицируют структуры данных (Сущности) <a href=#auap>[auap]</a>.</p><p>JPA настолько сложна и непредсказуема, что программисты боятся применять принципы объектно-ориентированного программирования и помещать какой-либо код кроме сеттеров и геттеров в сущности.
Кроме того, спецификация JPA накладывает ряд ограничений на классы сущностей (обязательная открытость для наследования, обязательный конструктор по умолчанию, наличие геттеров и сеттеров), которые непосредственно противоречат принципам объектно-ориентированного дизайна.
Подробнее можно почитать в моём <a href=/posts/21/04/why-jpa-should-be-avoided/#_проблемы_jpa>посте</a>, посвящённом JPA.</p><p>Также JPA исключает и применение функционального подхода, т.к. требует чтобы изменения в состояние вносились посредством императивной модификации изменяемых сущностей.</p><p>Остаётся только процедурное программирование.
Притом, как правило, хаотичное процедурное программирование, руководимое интерпретациями программистов и ревьюверов нескольких популярных книг вроде Чистого Кода Роберта Мартина.
Вместо рациональных методик из классических книг <a href=#sp>[sp]</a>, <a href=#sd>[sd]</a>.</p><p>Всё это ведёт к разработке сложной системы, с высокой связанностью (coupling) и низкой связностью (cohesion), что для бизнеса выливается в высокую стоимость разработки и поддержки, большое количество ошибок, долгий онбординг новых разработчиков <a href=#sd>[sd]</a>.</p><p>От объектно-ориентированной парадигмы я тоже отказался, т.к. несмотря на заявления её сторонников, по моему опыту она плохо подходит для моделирования нашего мира (уступая в этом акторной модели <a href=#pe>[pe]</a>), а следование принципам ООД на уровне кода (Информационный Эксперт из GRASP, в частности) ведёт к созданию божественных объектов <a href=#auap>[auap]</a>, <a href=#dsdp>[dsdp]</a>.
В этом выборе я не одинок - анкл Боб, одна из ключевых фигур в ООП/ООД, примерно с 2010 года <a href=#ot>[ot]</a> предпочитает <strong>программировать</strong> на функциональном Clojure <a href=#wc>[wc]</a> (не отказавшись при этом от объектно-ориентированного подхода в <strong>дизайне</strong>).</p><p>А вот использование адекватных технологий (Spring Data JDBC/R2DBC) позволяет мне работать в рамках декларативной парадигмы.
Академическое функциональное программирование с высокоуровневыми абстракциями, понятными только хорошо тренированным математикам, я тоже не считаю подходящим средством для разработки информационных систем.
Поэтому из функционального программирования я взял только две ключевые на мой взгляд техники - функции без побочных эффектов (чистые функции) и неизменяемые структуры данных.
Это позволяет мне получить все выгоды декларативного программирования, оставляя код доступным для понимания всем программистам.</p><p>Декларативный подход подразумевает разделение кода описывающего желаемые эффекты (бизнес-логики) и их осуществляющего (ввода-вывода).
Однако операции системы в реальном мире подразумевают одновременно и эффекты (в противном случае, операция просто нагреет воздух и не изменит состояние мира) и бизнес-логику (в противном случае, эффекты оставят мир в текущем состоянии).
В отсутствие сложных функциональных техник (вроде интерпретаторов свободных монад), естественным способом объединения бизнес-логики и ввода-вывода являются контролирующие модули из структурного дизайна <a href=#sd>[sd]</a>.
Контролирующие модули являются второй отличительной чертой моего стиля кодирования.</p><p>Всё вместе это превращается в уже упомянутый мной подход функциональное ядро/императивная оболочка <a href=#fcis>[fcis]</a>.
Такой подход кардинально повышает характеристики разработки и продукта, существенные для бизнеса:</p><div class="olist arabic"><ol class=arabic><li>Выделение бизнес-логики в чистые функции упрощает покрытие их автоматическими тестами, включая продвинутые тесты свойств (property testing) <a href=#qc>[qc]</a>.
Это, в свою очередь, снижает количество регрессий и ошибок, снижает стоимость QA, снижает накладные расходы на дополнительные итерации исправления ошибок, повышает качество пользовательского опыта</li><li>Разделение бизнес-логики, ввода/вывода и модулей управления, повышает переиспользуемость отдельных элементов, снижая стоимость разработки</li><li>Декларативный код более прост для понимания, чем императивный и сокращает время онбординга новых разработчиков <a href=#wfpm>[wfpm]</a>, <a href=#tcem>[tcem]</a>, <a href=#ddd>[ddd]</a>, <a href=#rstc>[rstc]</a></li><li>Декларативный код менее подвержен ошибкам при первичной реализации и последующих модификациях и рефакторинге, давая все те же преимущества <a href=#wfpm>[wfpm]</a>, <a href=#them>[them]</a>, <a href=#ddd>[ddd]</a>, <a href=#rstc>[rstc]</a></li><li>Чистые функции проще оптимизировать и людям (их выполнение можно без ограничений распараллеливать и свободно кэшировать результат) и компиляторам <a href=#tcem>[tcem]</a>, что существенно упрощает оптимизацию "горячих точек" приложения</li></ol></div></section><section class="doc-section level-1"><h2 id=_декомпозиция_системы_на_пакеты>Декомпозиция системы на пакеты</h2><p>Обычно дизайн пакетов сводится к разбиению классов на функциональные категории - сервисы, ДТО, исключения и т.п.
Однако нет ни одного авторитетного источника, который бы рекомендовал такой подход и существует множество авторитетных источников, критикующих такой подход <a href=#ih>[ih]</a>, <a href=#asdppp>[asdppp]</a>, <a href=#sd>[sd]</a>, <a href=#auap>[auap]</a>, <a href=#ddd>[ddd]</a>, <a href=#ca>[ca]</a>.</p><p>Критика сводится к четырём тезисам:</p><div class="olist arabic"><ol class=arabic><li>Механическое пакетирование по функциональным категориям не отражает архитектуру приложения и структуру предметной области и тем самым затрудняет понимание системы <a href=#ddd>[ddd]</a>, <a href=#iddd>[iddd]</a>, <a href=#ca>[ca]</a>.
Из своего опыта я могу сказать, что есть 100% корреляция между таким пакетированием и архитектурой "Большой Ком Грязи" <a href=#bbom>[bbom]</a>, т.е. фактическим отсутствием архитектуры</li><li>Такое пакетирование исключает возможности для сокрытия информации и инкапсуляции <a href=#ih>[ih]</a>, <a href=#asdppp>[asdppp]</a>, <a href=#sd>[sd]</a>, <a href=#auap>[auap]</a>.
Если говорить о Java, то в этом языке самым удобным является модификатор доступа package private - который используется, если модификатор доступа не был указан явно.
То есть дизайнеры языка планировали, что именно package private будет наиболее распространённым <a href=#jgoj>[jgoj]</a>.
Пакетирование же по функциональности, вынуждает делать все классы и большинство методов публичными.
Тотальная публичность элементов кода лишает разработчиков одного из ключевых средств локализации изменений и ведёт к чрезмерной трудоёмкости реализации изменений в требованиях.</li><li>Декомпозиция по функциональности ведёт к низкой связности (cohesion) и высокой связанности (coupling) пакетов <a href=#sd>[sd]</a>, <a href=#asdppp>[asdppp]</a>, <a href=#ddd>[ddd]</a>.
Ещё в 60ых года Ларри Константин доказал, что такие программы сложны в понимании и поддержке и как следствие подвержены большому количеству ошибок и регрессий.</li><li>Механическое разбиение превращает разработчиков в Эллочку-людоедку со словарным запасом из ~8 слов - контроллер, сервис, репозиторий, сущность, ДТО, исключение, фабрика, перечисление.
Тем самым искусственно ограничивая разработчика в инструментарии для корректного моделирования предметной области <a href=#ddd>[ddd]</a>, <a href=#iddd>[iddd]</a>.</li></ol></div><p>Всё это ведёт к всё тем же проблемам для бизнеса: программы с таким принципом пакетирования стоят дороже, требуют больших усилий для реализации новой функциональности и особенно подвержены ошибкам и регрессиям.</p><p>Избежать всех этих проблем помогает разбиение классов по пакетам на основе агрегатов DDD и юз кейсов <a href=#ddd>[ddd]</a>, <a href=#ca>[ca]</a>, <a href=#auap>[auap]</a>, <a href=#oose>[oose]</a>, с учётом основных принципов проектирования:</p><div class="olist arabic"><ol class=arabic><li>Принцип ацикличного графа зависимостей <a href=#adpppp>[adpppp]</a></li><li>Принцип сокрытия информации <a href=#ih>[ih]</a></li><li>Принцип стабильных зависимостей <a href=#adpppp>[adpppp]</a></li><li>Принципы высокой связности (cohesion) и низкой связанности (coupling) <a href=#sd>[sd]</a>, <a href=#auap>[auap]</a>, <a href=#ddd>[ddd]</a></li><li>Принцип единственности ответственности <a href=#adpppp>[adpppp]</a></li><li>Принцип расширения поведения, за счёт нового кода</li></ol></div><p>Всё это позволяет декомпозировать систему на набор изолированных пакетов, со стабильным ядром и минимальным количеством связей между ними.
Кроме того, такой подход позволяет использовать Dependency Structure Matrix <a href=#dsm>[dsm]</a> не только для контроля зависимостей между отдельными классами, но и для контроля зависимостей между модулями.</p><p>Для бизнеса это значит, что изменения в требованиях будут требовать минимум усилий и порождать минимум регрессий, а добавление новой функциональности будет выполняться преимущественно за счёт нового кода (и состояния) и тем самым исключать регрессии в принципе.
Это ведёт к сокращению стоимости и сроков разработки, в том числе за счёт сокращения количества ошибок и регрессий.</p></section><section class="doc-section level-1"><h2 id=_использование_spring_для_связки_бинов>Использование Spring для связки бинов</h2><p>Обычно разработчики для связки бинов приложения используют Spring Component Scan и, хоть и реже в последнее время, автоматическое связывание на полях.</p><p>Моя практика показывает, что такой подход ведёт к полной утере разработчиками контроля за зависимостями в приложении, что ведёт к моментальному появлению циклических зависимостей, зависимостей стабильных классов от нестабильных классов и классов с огромным (более 20) количеством зависимостей.
В итоге система быстро скатывается к архитектурному стилю Big Ball of Mud <a href=#bbom>[bbom]</a>.</p><p>Что влечёт для бизнеса все те же проблемы - постоянно увеличивающиеся стоимость и сроки разработки и количество ошибок и регрессий.</p><p>Для того чтобы обеспечить себя и команду инструментарием для контроля за зависимостями и вытащить зависимости на первый план, я применяю рад нестандартных техник конфигурирования Spring-приложений:</p><div class="olist arabic"><ol class=arabic><li>Я отключаю Spring Component Scan</li><li>Я использую инъекцию зависимостей только через конструкторы классов</li><li>Я слежу за тем, чтобы у бинов было не более 3 зависимостей на бины из других пакетов (модулей)</li><li>Я создаю по отдельной Spring Configuration для каждого верхнеуровневого пакета</li><li>В конфигурациях я делаю публичными только бины, определяющие публичный интерфейс пакета, а бины отвечающие за детали его реализации скрываю</li><li>Если какой-то пакет зависит от бина другого пакета, я импортирую не сам бин, а конфигурацию соответствующего пакета</li><li>Каждый класс конфигурации явным образом импортирует все другие конфигурации (включая автоматические), от которых он зависит</li></ol></div><p>Всё это вместе даёт ряд мне инструментов для мониторинга архитектуры и противодействия скатыванию к Big Ball of Mud:</p><div class="olist arabic"><ol class=arabic><li>Архитектура (зависимости между пакетами, в частности) становится доступной в один клин на диаграмме контекстов Spring в IDEA и матрице структуры зависимостей (с гранулярностью на уровне пакетов)</li><li>Добавление новой зависимости начинает требовать существенных усилий (добавление в конструктор класса, изменение класса конфигурации, добавление в конструктор конфигурации) и как следствие создаёт барьер, на котором у программиста появляется шанс остановиться и оценить последствия добавления зависимости</li><li>Появляется несколько дополнительных элементов чек-листа ревью - количество зависимостей в бинах на другие модули, стабильность зависимостей, адекватность области видимости бинов, отсутствие циклов в зависимостях - которые позволяют следить за "здоровьем" архитектуры на регулярной основе</li></ol></div><p>Кроме того, такой подход делает отдельные пакеты полноценными единицами переиспользования с точкой входа в виде Spring Configuration пакета.
В частности, это существенно упрощает изолированное тестирование отдельных пакетов программы.</p><p>Всё это ведёт к созданию архитектуры с продуманной структурой зависимостей.
Хорошо спроектированную структуру легче понять и она минимизирует количество модулей, требующих изменений при изменении в требованиях.
Это даёт бизнесу всё те же преимущества - сокращение стоимости и сроков реализации и количества ошибок и регрессий.</p></section><section class="doc-section level-1"><h2 id=_тестирование>Тестирование</h2><p>Обычно разработчики делают акцент на юнит-тестировании, подразумевая под юнитом отдельный метод.
А для изоляции кода от коллабораторов активно используют моки.</p><p>Такой подход популяризировала Лондонская школа тестирования <a href=#ls>[ls]</a>, но основатели движения TDD - Кент Бек и Роберт Мартин придерживаются других практик <a href=#tdd>[tdd]</a>, <a href=#wtm>[wtm]</a>, <a href=#tab>[tab]</a>, <a href=#wtddgw>[wtddgw]</a>, <a href=#tddid>[tddid]</a>.</p><p>Потому что Лондонскому подходу свойственен ряд существенных недостатков:</p><div class="olist arabic"><ol class=arabic><li>Такие тесты ничего не говорят о работоспособности системы <a href=#wmuaw>[wmuaw]</a>, <a href=#ls>[ls]</a>, <a href=#tim>[tim]</a></li><li>Такие тесты проверяют реализацию, а не поведение и как следствие препятствуют рефакторингу <a href=#wtddgw>[wtddgw]</a>, <a href=#ls>[ls]</a>, <a href=#tim>[tim]</a>.
Что ведёт к его удорожанию, как следствие, отказу от него, как следствие - постепенному сгниванию дизайна.</li><li>Такие тесты оторваны от потребностей заказчика <a href=#wtddgw>[wtddgw]</a>, <a href=#ls>[ls]</a>.
Заказчика не интересует, выбрасывает ли метод Foo.bar исключение при определённых значениях входных параметров.
Заказчика интересует реализовано ли требование запрета на перевод денег, в случае нехватки средств на исходном счету.</li><li>Ценность, как правило, возникает именно в интеграциях.
Уникальный алгоритм торговли на бирже с доходностью 150% совершенно бесполезен, без интеграции с этой биржей.
А Лондонская школа тестирования держит интеграции вне своего фокуса <a href=#ls>[ls]</a>, <a href=#tim>[tim]</a>.</li></ol></div><p>Для бизнеса это значит, что такие тесты лишь увеличивают стоимость первоначальной разработки и последующей поддержки, при этом практически никак не влияют на стоимость QA, количество фич возвращённых разработчикам на исправление ошибок и регрессий и количество ошибок и регрессий, дошедших до конечных пользователей.</p><p>Поэтому я пишу тесты, которые проверяют, что система удовлетворяет требованиям и мокирую только внешние системы, которые слишком дорого использовать в тестах, или которые работают нестабильно.</p><p>Такие тесты позволяют мне:</p><div class="olist arabic"><ol class=arabic><li>Сократить на порядок количество задач возвращённых QA на исправление ошибок и регрессий и количество ошибок и регрессий, дошедших до конечного пользователя</li><li>Выполнять рефакторинг (изменение структуры кода, без изменения поведения) без изменений в тестах</li><li>Быть уверенным в том, что если все тесты прошли, то система удовлетворяет всем согласованным требованиям</li></ol></div><p>Для бизнеса это, как обычно, значит сокращение стоимости и сроков разработки, и меньшее количество ошибок и регрессий дошедших до конечного пользователя.</p><p>Подробнее о моём подходе к тестированию и результатам, которые он даёт можно почитать в посте <a href=/posts/21/03/210321-project-l-testing/>Тесты которым можно доверять</a>.</p></section><section class="doc-section level-1"><h2 id=_архитектура>Архитектура</h2><p>С точки зрения архитектуры сейчас наиболее распространены три варианта, усложняющие жизнь разработчикам и бизнесу.</p><p>Исторически самым распространённым архитектурным стилем был слоёный монолит, который ввиду описанных выше обычаев разработки уже через три-четыре месяца разработки превращался в Layered Big Ball of Mud.</p><p>После начала хайпа микросервисов многие команды начали делать системы по микросервисной архитектуре и получается у них сильно по-разному.</p><p>Если команда не была в состоянии спроектировать модульный монолит, а переход на микросервисную архитектуру не послужил триггером к качественному скачку в дизайнерской квалификации, то команда получала наихудший из возможных вариантов - Distributed Big Ball of Mud <a href=#mm>[mm]</a>, <a href=#mom>[mom]</a>.</p><p>Если команде удалось хорошо спроектировать микросервисы, но декомпозиция системы была единственной причиной их применения, то команда зря заплатила огромные накладные расходы на старте разработке и при последующей поддержке <a href=#mm>[mm]</a>, <a href=#mom>[mom]</a>.</p><p>Применение микросервисной архитектуры со старта проекта уместно в двух случаях <a href=#mm>[mm]</a>, <a href=#mom>[mom]</a>:</p><div class="olist arabic"><ol class=arabic><li>Проект разрабатывается для 1% компаний, которым действительно важны операционные свойства микросервисов - независимые масштабируемость, развёртывание, конфигурируемость и т.п.</li><li>Архитектура разрабатывается для крупной корпорации, которая планирует львиную долю работ отдать на аутсорс и аутстаф разным командам</li></ol></div><p>Наконец, в последнее время набирает хайп Чистая Архитектура Роберта Мартина <a href=#ca>[ca]</a>.
Этому хайпу поддался и я и сделал три коммерческих проекта по Чистой Архитектуре.
В результате пришёл к выводу, что она практически ничего не даёт относительно от остальных моих практик, с точки зрения борьбы с Big Ball of Mud, зато несёт с собой существенные накладные расходы, удорожая разработку.</p><p>К счастью или несчастью, я никогда не разрабатывал архитектуру для проектов, в которых микросервисы были бы уместны со старта.
Поэтому я (снова, после отхода от чистой архитектуры) начинаю проекты с самой простой и дешёвой архитектуры - слоёного монолита.
А для того чтобы он не скатился к Big Ball of Mud, я пользуюсь описанными выше практиками и делаю модульный слоёный монолит.
В отдельных модулях, где я вижу что применение Чистой Архитектуры окупит свою стоимость - я на уровне модуля применяю чистую архитектуру.</p><p>Пока что ни один из моих проектов, выполненных по эргономичному подходу, не дорос до потребностей к операционной работе, которые могут обеспечить только микросервисы, поэтому все они ещё монолитные.
Но я держу в голове потенциальную необходимость выделять из монолита микросервисы и слежу за тем, чтобы модули могли быть выделены в самостоятельные приложения в течение нескольких часов.</p><p>Такой подход совмещает в себе лучшее двух миров - отсутствие лишних расходов на старте, и возможность быстро выделить функциональность, для которой появились особые операционные требования, в отдельный микросервис <a href=#mm>[mm]</a>, <a href=#mom>[mom]</a>.</p><p>Для бизнеса это значит существенное сокращение сроков и стоимости разработки и поддержки продукта.</p></section><section class="doc-section level-1"><h2 id=_что_получается_когда_делаешь_не_так>Что получается, когда делаешь не так</h2><p>Эргономичный подход - это согласованный набор принципов и техник, которые я по крупицам собирал и проверял на практике последние десять лет.
Эти принципы и техники я взял из признанных и проверенных источников от авторов с мировом именем в ИТ - эргономичный подход несёт с собой ноль рисков относительно общепринятого подхода.
Все они служат глобальной цели - минимизации усилий, необходимых для реализации требований, в том числе за счёт сокращения количества ошибок и регрессий.
Игнорирование практик эргономичного подхода, помимо технических проблем, влечёт ещё и проблемы с командой.</p><section class="doc-section level-2"><h3 id=_мотивация_разработчиков>Мотивация разработчиков</h3><p>Для разработчиков обычный подход к разработке создаёт две проблемы:</p><div class="olist arabic"><ol class=arabic><li>Реализация изменений в требованиях выливается в неадекватно большие усилия</li><li>Реализация изменений в требованиях приводит к большому количеству регрессий</li></ol></div><p>По моему опыту, в таких условиях разработчики сначала прокрастинируют, а потом увольнялся в поисках лучших условий.
Тем самым ещё больше увеличивая стоимость и сроки реализации продукта для бизнеса.</p><p>Я тоже так делал.
Но примерно после третьей смены работы, я понял, что подход к работе и условия везде одинаковые.
И мне необходимо самому создать для себя комфортные условия.
Вот почему я встаю в 5 утра - чтобы найти время для эргономичного подхода, который обеспечивает комфортные условия.</p><p>Думаю, я на верном пути.
К текущему моменту я сделал в эргономичном подходе четыре проекта, командами в два-четыре разработчика.
В этих проектах у меня ни разу не возникало потребности мотивировать кого-то.
Ушёл с проекта только один человек.</p><p>Высоко замотивированная команда с низкой ротацией даёт бизнесу всё те же выгоды - сокращение стоимости и сроков реализации продукта.</p></section><section class="doc-section level-2"><h3 id=_разница_в_деньгах>Разница в деньгах</h3><p>Я утверждаю - для бизнеса, эргономичный подход выливается в более качественный продукт за меньшие деньги.</p><p>У меня нет результатов "рандомизированных двойных слепых плацебо контролируемых" исследований, на выборке статистически достоверного размера, для подтверждения этого тезиса.
Однако ряд аргументов в его подкрепление я могу привести:</p><div class="olist arabic"><ol class=arabic><li>Ларри Константин, первооткрыватель морфологии ориентированной на трансформации, одной из основных техник эргономичного подхода, проводил исследования на более чем ста системах.
И в результате пришёл к выводу, что соответствие этой морфологии является надёжным классификатором для разделения систем на дешёвые (в случае соответствия) и дорогие</li><li>Субъективно я чувствую себя более эффективным при работе над системами, сделанными по эргономичному подходу.
Мне реже приходят ошибки и регрессии от QA, я реже испытываю давление по срокам, я реже раздражаюсь на чрезмерно трудоёмкий рефакторинг</li><li>В проектах, сделанных по эргономичному подходу, я трижды проводил крупные рефакторинги и ни разу не внёс регрессий</li><li>По статистике, ошибки я в среднем допускаю одну за спринт</li><li>По статистике, регрессии я в среднем допускаю одну в квартал</li><li>Руководитель проекта, сделанного мной по последней версии эргономичного подхода, дал мне такую рекомендацию: "Алексей - один из лучших разработчиков, с которыми я работал. Работой с ним я удовлетворён на 10 баллов из 10, потому что он практически всегда попадает в озвученные сроки, и в работе с ним не приходится накидывать 50% на всякий пожарный"</li></ol></div><p>Вот к чему ведёт то, что я делаю не так, как это принято.</p></section></section><section class="doc-section level-1"><h2 id=_ссылки>Ссылки</h2><div class="ulist bibliography"><ul class=bibliography><li><a id=asdppp aria-hidden=true></a>[asdppp] <a href=https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445>Agile Software Development, Principles, Patterns, and Practices</a></li><li><a id=auap aria-hidden=true></a>[auap] <a href=https://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062>Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development</a></li><li><a id=bbom aria-hidden=true></a>[bbom] <a href=http://www.laputan.org/mud/>Big Ball of Mud</a></li><li><a id=ca aria-hidden=true></a>[ca] <a href=https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164>Clean Architecture: A Craftsman’s Guide to Software Structure and Design</a></li><li><a id=cc aria-hidden=true></a>[cc] <a href=https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670>Code Complete</a></li><li><a id=ddd aria-hidden=true></a>[ddd] <a href=https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215>Domain-Driven Design: Tackling Complexity in the Heart of Software</a></li><li><a id=dsdp aria-hidden=true></a>[dsdp] <a href=https://www.tedinski.com/2019/04/02/solid-critique.html>Deconstructing SOLID design principles</a></li><li><a id=dsm aria-hidden=true></a>[dsm] <a href=https://dzone.com/articles/dependency-structure-matrix-for-software-architect>Dependency Structure Matrix for Software Architecture</a></li><li><a id=fc aria-hidden=true></a>[fc] <a href=https://medium.com/androiddevelopers/fewer-crashes-and-more-stability-with-kotlin-b606c6a6ac04>Fewer crashes and more stability with Kotlin</a></li><li><a id=fcis aria-hidden=true></a>[fcis] <a href=https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell>Functional Core, Imperative Shell</a></li><li><a id=hbp aria-hidden=true></a>[hbp] <a href=https://thorben-janssen.com/hibernate-best-practices>Hibernate Best Practices</a></li><li><a id=iddd aria-hidden=true></a>[iddd] <a href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/ref=pd_sbs_1/141-8150406-3569707?pd_rd_w=esaTU&pf_rd_p=3676f086-9496-4fd7-8490-77cf7f43f846&pf_rd_r=C3ZFNR15H4FV4HF5NM1B&pd_rd_r=15e71ee5-1ea0-496e-baee-6e3137eba574&pd_rd_wg=49plh&pd_rd_i=0321834577&psc=1">Implementing Domain-Driven Design</a></li><li><a id=ih aria-hidden=true></a>[ih] <a href=https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf>On the Criteria To Be Used in Decomposing Systems into Modules</a></li><li><a id=jag aria-hidden=true></a>[jag] <a href=https://thorben-janssen.com/ultimate-guide-association-mappings-jpa-hibernate>Map Associations with JPA and Hibernate – The Ultimate Guide</a></li><li><a id=jgoj aria-hidden=true></a>[jgoj] <a href=https://www.artima.com/articles/james-gosling-on-java-may-2000>James Gosling on Java, May 2000 A Conversation with Java’s Creator, James Gosling</a></li><li><a id=jpas aria-hidden=true></a>[jpas] <a href="https://download.oracle.com/otn-pub/jcp/persistence-2_2-mrel-spec/JavaPersistence.pdf?AuthParam=1636931989_e38842812dabf1c7bf90c0a5c4c0c202">JSR 338: JavaTM Persistence API, Version 2.2</a></li><li><a id=kf aria-hidden=true></a>[kf] <a href=https://kotlinlang.org/docs/faq.html>Kotlin FAQ</a></li><li><a id=ls aria-hidden=true></a>[ls] <a href=https://freecontent.manning.com/what-is-a-unit-test-part-2-classical-vs-london-schools/>What is a Unit Test? Part 2: classical vs. London schools</a></li><li><a id=mm aria-hidden=true></a>[mm] <a href="https://www.youtube.com/watch?v=5OjqD-ow8GE">Modular Monoliths</a></li><li><a id=mom aria-hidden=true></a>[mom] <a href="https://www.youtube.com/watch?v=AJW2FAJGgVw">Modules or Microservices?</a></li><li><a id=oose aria-hidden=true></a>[oose] <a href=https://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350>Object-Oriented Software Engineering: A Use Case Driven Approach</a></li><li><a id=ot aria-hidden=true></a>[ot] <a href=https://blog.cleancoder.com/uncle-bob/2021/06/25/OnTypes.html>On Types</a></li><li><a id=pe aria-hidden=true></a>[pe] <a href=https://www.amazon.com/Programming-Erlang-Concurrent-Pragmatic-Programmers/dp/193778553X>Programming Erlang: Software for a Concurrent World</a></li><li><a id=qc aria-hidden=true></a>[qc] <a href=https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf>QuickCheck: a lightweight tool for random testing of Haskell programs</a></li><li><a id=rstc aria-hidden=true></a>[rstc] <a href=https://www.amazon.com/Reliable-software-through-composite-design/dp/0884052842>Reliable software through composite design</a></li><li><a id=sc aria-hidden=true></a>[sc] <a href=https://elizarov.medium.com/structured-concurrency-722d765aa952>Structured Concurrency</a></li><li><a id=sd aria-hidden=true></a>[sd] <a href=https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719>Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design</a></li><li><a id=sp aria-hidden=true></a>[sp] <a href=https://www.amazon.com/Structured-Programming-P-I-C-studies-processing/dp/0122005503>Structured Programming</a></li><li><a id=tab aria-hidden=true></a>[tab] <a href=https://www.tedinski.com/2019/03/19/testing-at-the-boundaries.html>Testing at the boundaries</a></li><li><a id=tcem aria-hidden=true></a>[tcem] <a href="https://queue.acm.org/detail.cfm?ref=rss&id=2611829">The Curse of the Excluded Middle</a></li><li><a id=tdd aria-hidden=true></a>[tdd] <a href=https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530>Test Driven Development: By Example</a></li><li><a id=tddid aria-hidden=true></a>[tddid] <a href=https://martinfowler.com/articles/is-tdd-dead/>Is TDD Dead?</a></li><li><a id=tim aria-hidden=true></a>[tim] <a href=https://www.tedinski.com/2018/10/09/relationship-induction-and-tests.html>Testing, induction, and mocks</a></li><li><a id=wc aria-hidden=true></a>[wc] <a href=https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html>Why Clojre?</a></li><li><a id=wfpm aria-hidden=true></a>[wfpm] <a href=https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf>Why functional programming matters</a></li><li><a id=wmuaw aria-hidden=true></a>[wmuaw] <a href=https://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf>Why Most Unit Testing is Waste</a></li><li><a id=wtddgw aria-hidden=true></a>[wtddgw] <a href="https://www.youtube.com/watch?v=EZ05e7EMOLM">TDD, Where Did It All Go Wrong</a></li><li><a id=wtm aria-hidden=true></a>[wtm] <a href=https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html>When to Mock</a></li></ul></div></section></article><br></section></div></main><script src=/js/app.js></script></body></html>