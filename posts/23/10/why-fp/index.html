<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="ФП виновно в снижении стоимости програм. Вот мои доказательства, господа присяжные заседатели - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/23/10/why-fp/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/23/10/why-fp/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/23/10/why-fp/><title>ФП виновно в снижении стоимости програм. Вот мои доказательства, господа присяжные заседатели - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/23/10/why-fp/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>ФП виновно в снижении стоимости програм. Вот мои доказательства, господа присяжные заседатели</h1><h2 class=date>October 31, 2023</h2></header><section class="doc-section level-1"><h2 id=_введение><a class=link href=#_введение>Введение</a></h2><p>Среди особенностей Эргономичного подхода у моих заказчиков, коллег и студентов наибольшее сопротивление вызывает использование Spring Data JDBC, а не [Spring Data] JPA (де-факто стандарта работы с БД на платформе Java).</p><p>Изначально я собирался писать пост "Почему не JPA", но немного подумав понял, что ответ умещается в одно предложение: потому что JPA по своей природе (persistence context и dirty checking) не поддерживает неизменяемую модель данных - неотъемлемую часть функционального стиля программирования, который, в свою очередь, является неотъемлемой частью Эргономичного подхода.
И это объективный факт.</p><p>Почему для ЭП я выбрал ФП, а не "нормальное" императивное программирование?
На этот вопрос также можно ответить одним предложением: потому что функциональный стиль помогает мне <a href=https://azhidkov.pro/microposts/23/07/project-e-retro-v3/>снижать стоимость разработки для бизнеса</a> и <a href=https://azhidkov.pro/ergo-approach/landing/#_кейсы>делать руководителей проектов счастливыми</a>.</p><p>Уверен, многие не согласятся с истинностью утверждения "применение функционального стиля ведёт к снижению стоимости разработки".
Поэтому я пока буду называть его Гипотезой и приведу факты, доказывающие её истинность.</p><p>Главный из этих фактов - эмпирическое подтверждение Гипотезы, описанное в книге Structured Design.</p></section><section class="doc-section level-1"><h2 id=_структурный_дизайн><a class=link href=#_структурный_дизайн>Структурный дизайн</a></h2><p>В 60-ых годах прошлого века учёный <a href=https://en.wikipedia.org/wiki/Larry_Constantine>Ларри Константин</a> написал книгу Structured Design.
В этой книге он впервые ввёл понятия сцепленности (coupling) и функциональной связанности (cohesion), которые до сих пор лежат в основе большинства подходов к проектированию и кодированию программ.</p><p>Помимо этого, в главе <a href=https://archive.org/details/structureddesign00edwa/page/128/mode/2up>"THE MORPHOLOGY OF SIMPLE SYSTEMS"</a> (для просмотра необходимо пройти бесплатную регистрацию и "занять" книгу), Константин приводит иллюстрацию того, что он называет моделью, ориентированной на трансформацию (выделение цветами моё):</p><div class=image-block><img src=/posts/23/10/images/why-fp-286c9.png alt="why fp 286c9"></div><p>Упрощённо, эта модель разбивает код на четыре вида - ввод, вывод, трансформации и координацию.</p><p>Затем Константин пишет:</p><div class=quote-block><blockquote><p>It [transform-centered model] was derived empirically from a careful review of the morphology of systems, comparing systems that <strong>had proven</strong> to be <strong>cheap to implement, to maintain, and to modify</strong> with ones that had been expensive.</p><div class=literal-block><pre>[...]</pre></div><p>The umpteenth round in this game produced what came to be called the transform-centered model.
<strong>Most of the cheap systems had it</strong> - none of the costly systems did!</p><hr><p>Она [модель, ориентированная на трансформацию] была получена эмпирически на основе тщательного анализа морфологии систем со сравнением систем, которые <strong>были доказано дёшевы в разработки, обслуживании и модификации</strong>, с системами, которые были дорогостоящими.</p><div class=literal-block><pre>[...]</pre></div><p>Энный раунд этой игры породил то, что стало называться моделью, ориентированной на трансформации.
<strong>Она присутствовала в большинстве дешёвых систем</strong> - ни одна из дорогостоящих систем не имела её!</p><footer>— <cite>Larry Constantine, Structured Design, p. 144</cite></footer></blockquote></div><p>И если предположить, что трансформации являются чистым функциями в терминах ФП, то в этой модели отчётливо видна <a href=https://habr.com/ru/articles/571668/>функциональная архитектура</a>:</p><div class=ulist><ul><li>красные афферентные модули (ввод), жёлтые эфферентные модули (вывод) и голубой модуль координации - императивная оболочка</li><li>зелёные модули центральной трансформации - чистое ядро.</li></ul></div><p>Константин не пишет прямым текстом, что трансформации - это чистые функции, но если изучить книгу и её исторический контекст, то это становится очевидно.</p><p>Для того чтобы функция была чистой, она не должна иметь побочных эффектов.
В современном мире функция может иметь следующие основные виды побочных эффектов:</p><div class=ulist><ul><li>Ввод-вывод (в консоль, файл, сеть и т.д.);</li><li>Выброс исключения;</li><li>Запуск нового потока;</li><li>Изменение полей структур данных, переданных ей на вход по указателю;</li><li>Чтение и изменение полей глобальных структур данных, доступных по статической ссылке (обращение к общему окружению, синглтоны);</li></ul></div><p>Первый вид эффектов (ввод-вывод) в подпрограммах трансформации исключён самой моделью.</p><p>Выброс исключения, запуск нового потока и изменение структур данных по указателю исключены историческим контекстом - все эти штуки только-только начали появляться в момент разработки структурного дизайна (<a href=https://en.wikipedia.org/wiki/Exception_handling_(programming)>исключения</a>, <a href=https://en.wikipedia.org/wiki/Thread_(computing)>потоки</a>, <a href=https://en.wikipedia.org/wiki/Pointer_(computer_programming)>указатели</a>).</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Любопытный факт - с указателями Советский Союз смог догнать и перегнать Америку и придумал их в 1955 году, на 12 лет раньше западных учёных.</p></aside><p>Касательно обращения к общему окружению, Константин вроде бы прямым текстом говорит, что этого <strong>не</strong> следует избегать любой ценой.
Но он приводит такую иллюстрацию "эффекта общего окружения", которой хочется избежать любой ценой.</p><div class=quote-block><blockquote><p>Whenever two or more modules interact with a common data environment, those modules are said to be common-environment coupled.</p><div class=literal-block><pre>[...]</pre></div><p>A common environment may be a shared communication region, a conceptual file in any storage medium, a physical device or file, a common data base area, and so on.</p><div class=literal-block><pre>[...]</pre></div><p>The point is not that common-environment coupling is bad, or that it should be avoided at all cost.
To the contrary, there are circumstances in which this may be the method of choice.
However, it should be clear that a small number of elements shared among a few modules can enormously complicate the structure of a system - from the point of view of understanding it, maintaining it, or modifying it.</p><div class=image-block><img src=/posts/23/10/images/why-fp-509f0.png alt="why fp 509f0"></div><hr><p>Всякий раз, когда два или более модуля взаимодействуют с данными в общем окружении, считается, что эти модули сцеплены через общее окружение.</p><div class=literal-block><pre>[...]</pre></div><p>Общим окружением может быть общая область обмена данными, концептуальный файл на любом носителе информации, физическое устройство или файл, общая область базы данных и так далее.</p><div class=literal-block><pre>[...]</pre></div><p>Посыл не в том, что сцепленность через общее окружение плоха или что её следует избегать любой ценой.
Напротив, существуют обстоятельства, при которых этот метод может быть предпочтительным.
Однако должно быть очевидно, что небольшое количество элементов, совместно используемых несколькими модулями, может чрезвычайно усложнить структуру системы с точки зрения её понимания, обслуживания или модификации.</p><footer>— <cite>Larry Constantine, Structured Design</cite></footer></blockquote></div><p>Наконец, в статье <a href=https://www.academia.edu/58429322/Structured_design>Structured Design</a> Константин пишет:</p><div class=quote-block><blockquote><p>A predictable, or well-behaved, module is one that, when given the identical inputs, operates identically each time it is called.
Also, a well-behaved module operates independently of its environment.</p><hr><p>Предсказуемый, или [хорошо управляемый/исправный/хорошо себя ведущий], модуль - это модуль, который при задании идентичных входных данных работает одинаково при каждом его вызове.
Кроме того, исправный модуль работает независимо от своей среды.</p><footer>— <cite>Larry Constantine, Structured Design</cite></footer></blockquote></div><p>Это определение well-behaved модуля (подпрограммы) буквально является определением чистой функции.</p><hr><p>Таким образом, мы получаем:</p><div class="olist arabic"><ol class=arabic><li>Трансформации физически не могли иметь никаких эффектов, кроме обращения к общему окружению;</li><li>При этом Константин иллюстрирует "эффект общего окружения" картинкой, которая повергнет в ужас любого разработчика;</li><li>И называет исправными подпрограммы, которые обладают свойствами чистых функций - в том числе не обращаются к общему окружению.</li></ol></div><p>Достаточно ли этого, для того чтобы прийти к выводу, что трансформации де-факто были чистыми функциями и, следовательно, модель, ориентированная на трансформации, является эквивалентом функциональной архитектуры?
Я считаю что да.</p><p>Это, в свою очередь, значит что есть эмпирические свидетельства тому, что применение функциональной архитектуры ведёт к системам "дешёвым в разработке, обслуживании и модификации".</p><p>Это могло бы быть неопровержимым доказательством Гипотезы, если бы не одно но.
Результаты этого исследования не были опубликованы в рецензируемом научном журнале, потому что "исходные данные и заметки были утеряны в беспорядочной гибели института".</p><p>Тем не менее, я считаю, что слова учёного с мировым именем заслуживают доверия.
В том числе потому, что они подтверждаются другими экспертами-практиками и моим собственным опытом.</p></section><section class="doc-section level-1"><h2 id=_косвенные_подтверждения_гипотезы><a class=link href=#_косвенные_подтверждения_гипотезы>Косвенные подтверждения Гипотезы</a></h2><section class="doc-section level-2"><h3 id=_фп_в_книгах><a class=link href=#_фп_в_книгах>ФП в книгах</a></h3><p>Призывы максимум кода выделять в чистые функции встречаются во множестве книг, опубликованных начиная с 60-ых годов и публикуемых по сей день.</p><section class="doc-section level-3"><h4 id=_functional_design_principles_patterns_and_practices_2023_robert_martin><a class=link href=#_functional_design_principles_patterns_and_practices_2023_robert_martin>Functional Design: Principles, Patterns, and Practices (2023), Robert Martin</a></h4><p><a href=https://www.amazon.com/Functional-Design-Principles-Patterns-Practices/dp/0138176396>Свежая книга</a> Роберта Мартина, пожалуй, самого цитируемого человека на собеседованиях и конференциях по дизайну и хорошему коду, называется Functional Design: Principles, Patterns, and Practices.</p></section><section class="doc-section level-3"><h4 id=_unit_testing_principles_practices_and_patterns_2020_vladimir_khorikov><a class=link href=#_unit_testing_principles_practices_and_patterns_2020_vladimir_khorikov>Unit Testing: Principles, Practices, and Patterns (2020), Vladimir Khorikov</a></h4><p>Лучшая, на мой взгляд, <a href=https://www.amazon.com/Unit-Testing-Principles-Practices-Patterns/dp/1617296279>книга по автоматизации тестирования</a> включает в себя три раздела на 23 страницы, посвящённых функциональной архитектуре.
Потому что она является необходимым</p></section><section class="doc-section level-3"><h4 id=_patterns_principles_and_practices_of_domain_driven_design_2015_scott_millett><a class=link href=#_patterns_principles_and_practices_of_domain_driven_design_2015_scott_millett>Patterns, Principles, and Practices of Domain-Driven Design (2015), Scott Millett</a></h4><div class=quote-block><blockquote><p>Side effects can make code harder to reason about and harder to test, and they can often be the source of bugs.
In a broad programming context, avoiding side effecting functions as much as possible is generally considered good advice.
You even saw in the previous chapter how being side-effect‐free and immutable were two of the main strengths of value objects.
<strong>But if avoiding side effects is good advice, avoiding hidden side effects is a fundamental expectation</strong>.</p><hr><p>Побочные эффекты могут усложнить анализ кода и его тестирование, а так же они часто бывают источником ошибок.
Избегать, насколько это возможно, функций с побочными эффектами - обычно считается хорошим советом в программировании.
Вы даже видели в предыдущей главе, что отсутствие побочных эффектов и неизменяемость были двумя основными преимуществами объектов-значений.
<strong>Но если избегать побочных эффектов - хороший совет, то избегать скрытых побочных эффектов - фундаментальное ожидание</strong>.</p><footer>— <cite>Scott Millett, Patterns, Principles, and Practices of Domain-Driven Design, section Favor Hidden‐Side‐Effect‐Free Functions</cite></footer></blockquote></div></section><section class="doc-section level-3"><h4 id=_clean_code_2008_robert_martin><a class=link href=#_clean_code_2008_robert_martin>Clean Code (2008), Robert Martin</a></h4><div class=quote-block><blockquote><p><strong>Side effects are lies.</strong></p><p>Your function promises to do one thing, but it also does other hidden things.
Sometimes it will make unexpected changes to the variables of its own class.
Sometimes it will make them to the parameters passed into the function or to system globals.
In either case they are devious and damaging mistruths that often result in strange temporal couplings and order dependencies.</p><hr><p><strong>Побочные эффекты - это ложь.</strong></p><p>Ваша функция обещает сделать что-то одно, но она также выполняет и другие скрытые действия.
Иногда она вносит неожиданные изменения в переменные своего класса.
Иногда делает это с параметрами, передаваемым в функцию, или глобальными переменными системы.
В любом случае это коварные и разрушительные обманы, которые часто приводят к странным временнЫм связям и зависимостям в порядке выполнения.</p><footer>— <cite>Robert Martin, Clean code, section Have No Side Effects</cite></footer></blockquote></div></section><section class="doc-section level-3"><h4 id=_domain_driven_design_2003_eric_evans><a class=link href=#_domain_driven_design_2003_eric_evans>Domain-Driven Design (2003), Eric Evans</a></h4><div class=quote-block><blockquote><p><strong>Place as much of the logic of the program as possible into functions</strong>, operations that return results with no observable side effects.
Strictly segregate commands (resulting in modifications to observable state) into very simple operations that do not return domain information.
Further control side effects by moving complex logic into VALUE OBJECTS with conceptual definitions fitting the responsibility.</p><hr><p><strong>Помещайте возможный максимум логики программы в функции</strong> — операции, которые возвращают результат без наблюдаемых побочных эффектов.
Строго выделяйте команды (приводящие к изменениям в наблюдаемом состоянии) в очень простые операции, которые не возвращают доменную информацию.
Дальнейший контроль побочных эффектов осуществляется путём переноса сложной логики в ОБЪЕКТЫ-ЗНАЧЕНИЯ, чьё концептуальное описание подходит для включения ответственности [за выполнение этой логики].</p><footer>— <cite>Eric Evans, Domain-Driven Design, section SIDE-EFFECT-FREE FUNCTION</cite></footer></blockquote></div></section><section class="doc-section level-3"><h4 id=_object_oriented_software_construction_1997_bertrand_meyer><a class=link href=#_object_oriented_software_construction_1997_bertrand_meyer>Object-Oriented Software Construction (1997), Bertrand Meyer</a></h4><div class=quote-block><blockquote><p>The first question that we must address will have a deep effect on the style of our designs.
Is it legitimate for functions — routines that return a result — also to produce a side effect, that is to say, to change something in their environment?</p><p><strong>The gist of the answer is no</strong>, but we must first understand the role of side effects, and distinguish between good and potentially bad side effects.</p><hr><p>Первый вопрос, на который мы должны ответить, окажет глубокое влияние на стиль наших дизайнов.
Законно ли, чтобы функции — подпрограммы, возвращающие результат, — также производили побочный эффект, то есть изменяли что-то в своей среде?</p><p><strong>Суть ответа - нет</strong>, но сначала мы должны понять роль побочных эффектов и провести различие между хорошими и потенциально плохими побочными эффектами.</p><footer>— <cite>Bertrand Meyer, Object-Oriented Software Construction, section 23.1 SIDE EFFECTS IN FUNCTIONS</cite></footer></blockquote></div><hr><p>Следующим косвенным доказательством преимущества ФП-стиля является тот факт, что большинство его адептов в начале своей карьеры были сторонниками императивного стиля.</p></section></section><section class="doc-section level-2"><h3 id=_фп_перебежчики><a class=link href=#_фп_перебежчики>ФП-перебежчики</a></h3><p>Наиболее яркими, на мой взгляд, представителями людей, слишком слабых духом для императивного программирования, являются Роберт Мартин и Рич Хикки.</p><p>Мартин — человек, чьё имя приходит на ум первым после слов "объектно-ориентированный дизайн" или "чистый код" - десять лет назад <a href=https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html>перешёл с C++ на Clojure</a> и теперь пишет <a href=https://blog.cleancoder.com/uncle-bob/2021/11/28/Spacewar.html>посты-оды функциональному стилю</a> и книги по функциональному дизайну.</p><p>Хикки некогда был адвокатом C++, но в итоге настолько <a href=https://dl.acm.org/doi/pdf/10.1145/3386321>устал от проблем, вызванных императивным стилем</a>, что сделал собственный <a href=https://clojure.org/>функциональный язык</a> с персистентными структурами данных и примитивами безопасного конкурентного программирования, собственную <a href=https://www.datomic.com/>функциональную СУБД</a> и собственную <a href=https://docs.datomic.com/cloud/ions/ions.html>модель функционального программирования</a>.
И это всё не академические изыскания - <a href=https://clojure.org/community/success_stories>Clojure активно используется в коммерческой разработке</a> (хотя масштаб использования не сопоставим с Java/C#/Kotlin и т.д., конечно же).</p></section><section class="doc-section level-2"><h3 id=_фп_в_технологиях><a class=link href=#_фп_в_технологиях>ФП в технологиях</a></h3><p>Технологии, в частности языки программирования и фреймворки, призваны сделать разработку программ дешевле.
И сейчас наблюдается отчётливый тренд увеличения процента технологий, базирующихся на принципах ФП.
На основании чего можно предположить, что эти принципы помогают авторам удешевить разработку программ на базе их технологий.</p><p>Единственный <s>популярный</s> известный мне язык родом из этого века, который не поддерживает ФП - Go.
Все остальные - Kotlin, Swift, Rust - поддерживают.
Естественно, я не говорю о целом ворохе чисто функциональных языков программирования.</p><p>Сейчас даже Java семимильными шагами идёт в сторону ФП стиля — записи, закрытые иерархии, паттерн мэтчинг, лямбды в конце концов.</p><p>А GUI-фреймворки, некогда бывшие безраздельной вотчиной ООП, в XXI веке все как один - <a href=https://react.dev/>React</a>, <a href=https://developer.apple.com/xcode/swiftui/>SwiftUI</a>, <a href=https://developer.android.com/jetpack/compose>Jetpack Compose</a> (ну ладно, основные для наиболее используемых платформ - Web, Android, iOS) — предлагают функциональную модель.</p></section></section><section class="doc-section level-1"><h2 id=_вероятная_причина_низкой_стоимости_фп_программ><a class=link href=#_вероятная_причина_низкой_стоимости_фп_программ>Вероятная причина низкой стоимости ФП-программ</a></h2><p>Я полагаю, что при прочих равных, в разработке дешевле те программы, которые проще понять.</p><p>Потому что при работе с понятной программой, разработчику требуется меньше времени (=денег) на её изучение, для того чтобы внести требуемые правки.
И при изменении понятной программы меньше вероятность внести ошибку, которая потребует дополнительного времени (=денег) на её исправление.</p><p>И я хотя понятность кода во многом является субъективно метрикой, программы, написанные в функциональном стиле, объективно более понятны.</p><p>Это можно продемонстрировать на двух областях, которые строят точные модели программ - формальная верификация программ и оптимизирующие компиляторы.
Для обеих этих областей подпрограммы, написанные в функциональном стиле, являются объективно более понятными:</p><div class="olist arabic"><ol class=arabic><li>Оптимизирующие компиляторы не могут применять многие из оптимизаций к программам с эффектами из-за того, что не могут предсказать последствия этих оптимизаций ([<a href=https://dl.acm.org/doi/pdf/10.1145/130943.130947>1</a>]</li><li>Наличие оператора присваивания в программе существенно усложняет задачу её формальной верификации ([<a href="https://queue.acm.org/detail.cfm?ref=rss&id=2611829">2</a>]).</li></ol></div><p>Есть и более близкая большинству разработчиков область, в которой большая простота функционального стиля на фоне императивного не вызывает сомнений, - многопоточное программирование.</p><p>Главная сложность написания многопоточных программ в императивном стиле (с разделяемыми изменяемыми структурами данных) в том, что в любой момент ваш код могут остановить и поменять данные, с которыми вы только что работали.
Это как будто вы подносите ко рту конфетку, в последнюю секунду моргаете, открываете глаза, а там уже шпинат.</p><p>По сути та же ситуация может возникнуть и в однопоточной программе в момент вызова функции с передачей в неё изменяемой структуры данных.
Да, тут всё значительно проще - вы точно знаете когда и примерно знаете кто (в случае полиморфного вызова в закрытой системе) может подменить вам конфетку.
Но для того чтобы быть уверенным, что вы съедите именно конфетку, вам надо перед каждым использованием функции (и после каждого её изменения) заглядывать внутрь и изучать, что она делает с вашей конфеткой.</p><p>Эту проблему императивного стиля можно проиллюстрировать на следующем примере:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=kd>val</span> <span class=py>els</span><span class=p>:</span> <span class=nc>ArrayList</span><span class=p>&lt;</span><span class=nc>Int</span><span class=p>&gt;</span> <span class=p>=</span> <span class=nf>arrayListOf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
    <span class=kd>val</span> <span class=py>sum</span> <span class=p>=</span> <span class=nf>sum</span><span class=p>(</span><span class=n>els</span><span class=p>)</span>
    <span class=nf>println</span><span class=p>(</span><span class=s>&#34;Сумма ${els[0]} + ${els[1]} = $sum&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=k>fun</span> <span class=nf>sum</span><span class=p>(</span><span class=n>els</span><span class=p>:</span> <span class=nc>ArrayList</span><span class=p>&lt;</span><span class=nc>Int</span><span class=p>&gt;):</span> <span class=nc>Int</span> <span class=p>=</span> <span class=nc>TODO</span><span class=p>()</span></code></pre></div><p>Что мы можем сказать про поведение этой программы?
Если вынести за скобки то, что прямо сейчас она вылетит с исключением (так реализована функция TODO в Kotlin) - ничего.</p><p>Потому что <code>sum</code> может быть реализована, например, так:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=k>fun</span> <span class=nf>sum</span><span class=p>(</span><span class=n>els</span><span class=p>:</span> <span class=nc>ArrayList</span><span class=p>&lt;</span><span class=nc>Int</span><span class=p>&gt;):</span> <span class=nc>Int</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=py>sum</span> <span class=p>=</span> <span class=mi>0</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>els</span><span class=p>.</span><span class=nf>isNotEmpty</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>sum</span> <span class=p>+=</span> <span class=n>els</span><span class=p>.</span><span class=nf>remove</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>sum</span>
<span class=p>}</span></code></pre></div><p>С такой реализацией вызов этой программы завершится выбросом IndexOutOfBoundsException.
Это хоть и синтетический пример, но он основан на реальных событиях - из-за подобного кода я лично вносил баг, который нашли только в проде.</p></section><section class="doc-section level-1"><h2 id=_для_того_чтобы_снизить_стоимость_разработки_не_надо_знать_теорию_категорий><a class=link href=#_для_того_чтобы_снизить_стоимость_разработки_не_надо_знать_теорию_категорий>Для того чтобы снизить стоимость разработки, не надо знать теорию категорий</a></h2><p>Пуристы во главе с <a href="https://queue.acm.org/detail.cfm?ref=rss&id=2611829">Эриком Мейером</a> со мной не согласятся, но прагматики во главе в <a href="https://x.com/unclebobmartin/status/1593666656466862083?s=20">анкл Бобом</a> меня поддержат в том, что для получения пользы от ФП-стиля не обязательно уходить в идеально чистое функциональное программирование.</p><p>Для этого достаточно с помощью функциональной архитектуры разделить ввод-вывод и логику и сделать модель данных неизменяемой.
А императивную оболочку, как это ни странно, намного удобнее писать в императивном стиле.
И если локальная переменная не утекает за пределы функции - <a href=https://azhidkov.pro/microposts/22/12/why-fp-simpler/>она вполне может быть изменяемой</a> (см. примеры кода в конце поста).</p><p>Я не знаю единого хорошего источника по <s>пролетарскому</s> прагматичному ФП, но могу порекомендовать трек его изучения.</p><div class="olist arabic"><ol class=arabic><li><p>Сначала стоит прочитать пост Владимира Хорикова - <a href=https://habr.com/ru/articles/571668/>Иммутабельная архитектура</a>.</p><p>В этом посте можно быстро схватить основную идею функциональной архитектуры информационных систем.
Но в реализации информационных систем в функциональном стиле слишком много нюансов для одного поста, поэтому одним постом ограничиться не получится.</p></li><li>Затем можно так же быстро посмотреть ещё пару небольших примеров решения "реальных" задач в ФП-стиле в моих постах:<ol class=loweralpha type=a><li><a href=https://azhidkov.pro/posts/22/04/220401-aggregates/#_%D0%B0%D0%BD%D0%B5%D0%BC%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C>Агрегаты</a>;</li><li><a href=https://telegra.ph/Lenivye-vychisleniya-dlya-realizacii-funkcionalnoj-arhitektury-05-07>Ленивые вычисления для реализации функциональной архитектуры</a>.</li></ol></li><li><p>После этого можно прочитать книгу того же Хорикова <a href=https://www.amazon.com/Unit-Testing-Principles-Practices-Patterns/dp/1617296279>Unit Testing Principles, Practices, and Patterns</a> (<a href=https://habr.com/ru/companies/sportmaster_lab/articles/676840/>на русском</a>)</p><p>Тут больше деталей, но так как фокус книги всё-таки на тестировании, не хватает главной части — моделирования неизменяемых данных.</p></li><li><p>Моделирование незименяемых данных хорошо раскрыто в книге <a href=https://pragprog.com/titles/swdddf/domain-modeling-made-functional/>Domain Modeling Made Functional</a>.</p><p>Тут уже прям ФП-ФП с монадами, но после материалов Хорикова у вас будет выбор - идти в эту кроличью нору или нет.</p></li><li><p>Наконец, всё это можно полернуть свежей книгой анкл Боба <a href=https://www.amazon.com/Functional-Design-Principles-Patterns-Practices/dp/0138176396>Functional Design: Principles, Patterns, and Practices</a>.</p><p>В этой книге нет ни одного сложного эффекта (всё эффекты в памяти) и примеры на Clojure, но она хорошо иллюстрирует, тот самый <s>пролетарский</s> прагматичный стиль ФП.</p></li></ol></div></section><section class="doc-section level-1"><h2 id=_заключение><a class=link href=#_заключение>Заключение</a></h2><p>Итого мы имеем следующие факты:</p><div class="olist arabic"><ol class=arabic><li>Учёный с мировым именем утверждает, что у него были эмпирические данные, свидетельствующие о том, что дешёвые программы имеют структуру, которая чрезвычайно напоминает функциональную архитектуру;</li><li>Множество экспертов-практиков со страниц своих книг призывают возможный максимум кода выносить в чистые функции;</li><li>Множество экспертов-практиков переходят с императивного стиля на функциональный;</li><li>Множество вендоров включают принципы функционального подхода в основу своих технологий;</li><li>Программы, написанные в функциональном стиле, проще верифицировать и оптимизировать;</li><li>Писать многопоточные программы намного проще в функциональном стиле;</li><li>При этом код в функциональном стиле может быть вполне понятен человеку без степени доктора математических наук.</li></ol></div><p>Достаточно ли этих фактов, для доказательства того, что функциональный стиль снижает стоимость разработки?
Для меня, особенно с учётом того, что они согласуются с моим опытом, - да.</p></section></article><br></section></div></main><script src=/js/app.js></script></body></html>