<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Рациональный подход к декомпозиции систем на модули или микросервисы - Алексей Жидков"><meta property="og:description" content="Рациональный подход к декомпозиции систем на модули или микросервисы"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/23/04/ergonomic-decomposition/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/23/04/ergonomic-decomposition/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/23/04/ergonomic-decomposition/><title>Рациональный подход к декомпозиции систем на модули или микросервисы - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/23/04/ergonomic-decomposition/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Рациональный подход к декомпозиции систем на модули или микросервисы</h1><h2 class=date>April 15, 2023</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Данный пост является базовым материалом для моего <a href=https://jpoint.ru/talks/329f3cb2b72e4ec6a0e931207191546b/>доклада на JPoint 2023</a></p></aside><section class="doc-section level-1"><h2 id=_чего_от_разработки_по_хотят_разработчики_продакты_и_владельцы_бизнеса><a class=link href=#_чего_от_разработки_по_хотят_разработчики_продакты_и_владельцы_бизнеса>Чего от разработки ПО хотят разработчики, продакты и владельцы бизнеса?</a></h2><p>Одного и того же - побольше дофаминчика (гормон счастья), поменьше кортизольчика (гормон стресса).
Притом источники и дофамина, и кортизола у них одни и те же.
Дофамин вырабатывается, когда фичи выпускаются в срок и без багов, а кортизол - когда сроки срываются и вылазят баги и регрессии.
Бизнесу будет ближе финансовая версия — срыв сроков и баги очевидным образом приводят к увлечению стоимости разработки.
Что приводит к выбросу кортизола уже у владельцев.</p></section><section class="doc-section level-1"><h2 id=_как_обеспечить_высокий_уровень_дофамина_всей_команды><a class=link href=#_как_обеспечить_высокий_уровень_дофамина_всей_команды>Как обеспечить высокий уровень дофамина всей команды?</a></h2><p>Для того чтобы поддерживать высокий уровень дофамина и низкий уровень кортизола у всех участников процесса, нам необходимо декомпозировать системы на модули.
Декомпозиция помогает обеспечить высокую скорость и качество разработки за счёт:</p><div class=ulist><ul><li>Ограничения объёма информации, которую надо осознать и закодировать на этапе первичной реализации функциональности;</li><li>Ограничения объёма кода, который необходимо изучить и адаптировать к изменениям в требованиях;</li><li>Исключения конфликтов при параллельной разработке независимых функций системы;</li><li>Создания возможности независимого выпуска и развёртывания отдельных функций системы.</li></ul></div><p>Однако, этого можно достичь, только в том случае, если получившиеся модули обладают высокой функциональной связанностью и низкой сцепленностью.</p><div class=image-block><img src=/posts/23/04/images/cohesion-and-coupling.png alt="cohesion and coupling"></div><p>Кроме того, для максимизации <s>выброса дофамина</s> скорости разработки и минимизации <s>выброса кортизола</s> стоимости разработки, необходимо чтобы сама работа по декомпозиции системы проходила быстро и давала качественные результаты.</p></section><section class="doc-section level-1"><h2 id=_как_обеспечить_высокий_уровень_дофамина_всей_команды_при_выполнении_декомпозиции><a class=link href=#_как_обеспечить_высокий_уровень_дофамина_всей_команды_при_выполнении_декомпозиции>Как обеспечить высокий уровень дофамина всей команды при выполнении декомпозиции?</a></h2><p>А для того чтобы эта работа проходила быстро и давала качественные результаты, необходимо, чтобы она была структурирована и стандартизирована.
То есть нужна некоторая методика или рациональный подход к решению задачи декомпозиции.
И тут у нашей индустрии есть проблемы.</p><p>По моему опыту, в ВУЗах декомпозиции либо не обучают совсем, либо обучают монструозным и фактически устаревшим методологиям вроде RUP-а.
В других странах дела обстоят не лучше.
Например, про ВУЗы США Джон Остерхаут пишет то же самое:</p><div class=quote-block><blockquote><p>Problem decomposition is the central design task that programmers face every day, and yet, other than the work described here, I have not been able to identify a single class in any university where problem decomposition is a central topic.
We teach for loops and object-oriented programming, but not software design.</p><p>Декомпозиция - это центральная задача проектирования, с которой программисты сталкиваются каждый день, и всё же, кроме работы, описанной здесь, я не смог определить ни одного курса ни в одном университете, где декомпозиция является центральной темой.
Мы учим циклам и объектно-ориентированному программированию, но не проектированию ПО.</p><footer>— <cite>John Ousterhout, A Philosophy of Software Design</cite></footer></blockquote></div><p>Из-за этого, в большинстве команд, которые я видел в последние годы, проектирование и декомпозиция заключалась в паре часов несистематизированного рисования прямоугольников и стрелок одним-двумя разработчиками.
А полноценное проектирование и декомпозицию я видел в последний раз в 2005 году и они заняли несколько месяцев.</p><p>Для того чтобы обеспечить высокий уровень дофамина и на этапе проектирования и декомпозиции и на этапе последующей реализации, нам необходим подход к декомпозиции, который:</p><div class="olist arabic"><ol class=arabic><li>Вообще есть;</li><li>Прост в изучении;</li><li>Прост в исполнении;</li><li>Даёт хорошие результаты вне зависимости от исполнителя;</li></ol></div><p>Это и будет тем самым рациональным подходом к декомпозиции, который нам необходим.</p></section><section class="doc-section level-1"><h2 id=_а_что_не_так_с_классикой><a class=link href=#_а_что_не_так_с_классикой>А что не так с классикой?</a></h2><p>У опытного разработчика тут может возникнуть вопрос: "Зачем нужен очередной велосипед? Этих подходов к декомпозиции — тысячи!".
Я честно проделал домашнюю работу, и перед тем как придумать собственный велосипед изучил более двадцати различных подходов к декомпозиции начиная с 60-ых годов, многое взял себе, но ни один из них мне не удалось положить свою на каждодневную практику.</p><p>Подробно основные распространённые сейчас подходы я рассмотрел в <a href=https://azhidkov.pro/posts/22/08/ergonomic-decomposition/>отдельном посте</a> и здесь приведу только причины, по которым я не смог взять их в свою практику:</p><div class="olist arabic"><ol class=arabic><li>Декомпозиция по слоям не масштабируется и даёт плохие результаты с точки зрения связанности и сцепленности;</li><li>Декомпозиции по фичам и компонентам плохо описаны, и при попытке их применения возникает множество вопросов, на которые у источников нет ответов.</li><li>DDD сложен и в изучении, и применении.
Мне ни разу не удалось "продать" DDD хотя бы РП, фронтенд-разработчикам, аналитикам и QA-инженерам в собственной команде.
Кроме того, наличие "на борту" экспертов предметной области, критически важное для DDD, в моей практике является скорее исключением, чем правилом.</li></ol></div><p>Изучением и апробированием классики я занимался 6 лет - с 2014 до 2020 года.
Так и не найдя внятного ответа на вопрос "Как мне декомпозировать систему?", во второй половине 2020 я начал искать собственный подход к декомпозиции и написал разделы книги о <a href=https://azhidkov.pro/book/ergo/#_таблица_эффектов>таблице эффектов</a> и <a href=https://azhidkov.pro/book/ergo/#_принципы_проектирования_системы>компонентах</a> (осторожно, устаревшие и не редактированные черновики).
К марту 2021 года я придумал <a href=https://azhidkov.pro/posts/21/03/250326-project-decomposiotion/>объединить их в один граф</a> и в итоге это превратилось в декомпозицию на базе эффектов.</p></section><section class="doc-section level-1"><h2 id=_декомпозиция_на_базе_эффектов><a class=link href=#_декомпозиция_на_базе_эффектов>Декомпозиция на базе эффектов</a></h2><section class="doc-section level-2"><h3 id=_концептуальная_модель_системы><a class=link href=#_концептуальная_модель_системы>Концептуальная модель системы</a></h3><p>Для того чтобы применить подход к декомпозиции на базе эффектов, систему необходимо представить в виде графа операций и элементов состояния, связанных эффектами чтения и записи.
После чего процесс декомпозиции фактически сводится к кластеризации этого графа.
Пока что создать полностью автоматический алгоритм кластеризации, который бы давал удовлетворительные результаты, мне не удалось, поэтому кластеризация выполняется вручную.
И так как человеку проще выполнять кластеризацию графа, представленного визуально, я разработал специальную диаграмму, для представления графов эффектов.</p><p>Концептуальная модель системы и нотация диаграммы подробно описаны в <a href=https://azhidkov.pro/effects-diagram/specification-html/>спецификации</a>.
Упрощённо же можно считать, что:</p><div class=ulist><ul><li>Операции — это эндпоинты REST API;</li><li>Ресурсы — таблицы БД;</li><li>Эффекты записи — SQL INSERT/UPDATE/DELETE запросы;</li><li>Эффекты чтения — SQL SELECT-запросы.</li></ul></div><p>Соответственно, для построения диаграммы эффектов надо для каждого метода API добавить на диаграмму по прямоугольнику светло-синего цвета, для каждой таблицы добавить по прямоугольнику тёмно-синего цвета, для каждого запроса модификации данных добавить красную стрелку между соответствующей операцией и ресурсом, а для каждого запроса чтения данных - синюю стрелку.
В результате у вас получится картинка, состоящая из таких элементов:</p><div class=image-block><img src=/posts/23/04/images/short-notation-example.svg alt="short notation example"></div><p>Здесь, очевидным образом, операция "Зарегистрировать пользователя" вносит данные в таблицу "Пользователи", а операция "Аутентифицировать пользователя" считывает данные из этой таблицы.
Процесс построения диаграммы эффектов реального проекта с примерами всех распространённых видов ресурсов и операций описан в посте <a href=https://azhidkov.pro/posts/22/06/220611-true-story-project/>Диаграмма эффектов: пример построения</a>.</p><p>Также важно отметить, что все элементы диаграммы эффектов один в один транслируются в код:</p><div class="olist arabic"><ol class=arabic><li>Операции — в методы классов сервисов приложения;</li><li>Ресурсы — в классы сущностей и репозиториев (событий и топиков брокеров сообщений, DTO и клиентов REST API и т.д.);</li><li>Эффекты — в вызовы методов классов репозиториев в методах классов сервисов.</li></ol></div><p>После визуализации системы с помощью диаграммы эффектов необходимо выполнить её кластеризацию.</p></section><section class="doc-section level-2"><h3 id=_кластеризация_диаграммы_эффектов><a class=link href=#_кластеризация_диаграммы_эффектов>Кластеризация диаграммы эффектов</a></h3><p>В основе подхода к кластеризации диаграммы лежит несколько простых идей:</p><div class="olist arabic"><ol class=arabic><li>Ресурсы являются глобальными переменными;</li><li>Между всеми модулями, которые взаимодействуют с одним ресурсом, появляется сцепленность через общее окружение (common environment coupling);</li><li>Один из основных методов снижения сцепленности системы в целом - это локализация сцепленности через общее окружение внутри одного модуля;</li><li>Запись глобальной переменной порождает большую сцепленность, чем чтение.</li><li>В связях между модулями не должно быть циклов;</li><li>Если модулю сложно дать хорошее имя, отражающее его содержание, это говорит о низкой функциональной связанности модуля.</li></ol></div><p>То, что запись порождает большую сцепленность, чем чтение - может быть не очевидно.
Однако это легко продемонстрировать, если рассмотреть их в контексте многопоточной работы.
Считывать корректно опубликованную глобальную переменную могут сколь угодно много потоков без какой-либо синхронизации и проблем.
Но, как только кто-то начинает изменять эту переменную, всё тут же становится намного сложнее: теперь надо обеспечить безопасный доступ и не создать дедлок, обеспечить протокол взаимодействия (сначала запись, потом чтение), следить за тем, чтобы операция записи не стала бутылочным горлышком в производительности системы и т.д.</p><p>Вооружившись этими идеями, легко определить требования к хорошей кластеризации диаграммы эффектов (декомпозиции системы):</p><div class="olist arabic"><ol class=arabic><li>Между кластерами нет циклов;</li><li>Эффекты записи (красные стрелки) инкапсулированы в одном кластере;</li><li>Количество эффектов чтения (синих стрелок), пересекающих границы кластеров, минимально;</li><li>Каждому кластеру легко дать имя, отражающее его содержание.</li></ol></div><p>Для простых диаграмм такая кластеризация может быть видна на глаз.
Примером простой диаграммы является диаграмма эффектов проекта True Story Project:</p><div class=image-block><a class="image bare" href=/posts/23/04/images/tsp/tsp-decomposition-intuitive-anim.drawio.png title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/tsp/tsp-decomposition-intuitive-anim.drawio.png alt="tsp decomposition intuitive anim.drawio"></a></div><p>Здесь сразу же бросаются в глаза 3-4 кластера:</p><div class="olist arabic"><ol class=arabic><li>Работа с изображениями;</li><li>Формирование фида;</li><li>Интеграция с 2Гис;</li><li>Интеграция с Яндекс.Картами.</li></ol></div><p>На этом примере хорошо видно, что интуитивная декомпозиция зависит и от разработчика диаграммы (как он расположит элементы) и от наблюдателя - я на этой диаграмме вижу 4 кластера, но некоторые люди "автоматически" объединяют интеграции в один модуль.</p><p>Кроме того, большие или запутанные системы на глаз кластеризовать не получится.
Для того чтобы структурировать и ускорить процесс кластеризации таких диаграмм, а также снизить влияние исполнителя на результат, я разработал специальную методику.</p></section><section class="doc-section level-2"><h3 id=_методика_кластеризации_диаграммы_эффектов><a class=link href=#_методика_кластеризации_диаграммы_эффектов>Методика кластеризации диаграммы эффектов</a></h3><p>Методика состоит из двух больших этапов — кластеризации и оптимизации кластеров.
Для этапа кластеризации существует итеративный алгоритм, который простые диаграммы может кластеризовать полностью, а в сложных случаях - упросить и упорядочить рутинную работу, а также подсветить разработчику части системы, требующие особого внимания.</p><p>Общий алгоритм состоит из следующих шагов:</p><div class="olist arabic"><ol class=arabic><li>Кластеризация<ol class=loweralpha type=a><li>Первичная кластеризация по алгоритму<ol class=lowerroman type=i><li>Генерация кластеров</li><li>Расширение кластеров</li><li>Агрегация ресурсов</li></ol></li><li>Завершение кластеризации вручную</li></ol></li><li>Оптимизация<ol class=loweralpha type=a><li>Именование кластеров</li><li>Визуализация графа кластеров</li><li>Анализ графа кластеров</li><li>Объединение кластеров (модулей)<ol class=lowerroman type=i><li>Сокрытие подмодулей</li><li>Группировка функционально схожих кластеров</li></ol></li></ol></li></ol></div><section class="doc-section level-3"><h4 id=_алгоритм_первичной_кластеризации_диаграммы_эффектов><a class=link href=#_алгоритм_первичной_кластеризации_диаграммы_эффектов>Алгоритм первичной кластеризации диаграммы эффектов</a></h4><p>Алгоритм первичной кластеризации является итеративным, и каждая итерация состоит из трёх шагов:</p><div class="olist arabic"><ol class=arabic><li>Генерация кластеров.</li><li>Расширение кластеров.</li><li>Агрегация ресурсов.</li></ol></div><section class="doc-section level-4"><h5 id=_генерация_кластеров><a class=link href=#_генерация_кластеров>Генерация кластеров</a></h5><p>Этап <strong>генерации кластеров</strong> заключается в том, чтобы перебрать все некластеризованные ресурсы и кластеризовать их с операциями, которые:</p><div class="olist arabic"><ol class=arabic><li>Связаны только с этим ресурсом.</li><li>Связаны с этим ресурсом своим единственным эффектом записи.</li><li>Являются операциями чтения, для которых данный ресурс выступает первичным.
Определение первичного ресурса (и вообще его наличия) остаётся на усмотрение исполнителя.</li></ol></div></section><section class="doc-section level-4"><h5 id=_расширение_кластеров><a class=link href=#_расширение_кластеров>Расширение кластеров</a></h5><p>Этап <strong>расширения кластеров</strong> - это самый простой и на 100% механический этап.
Он заключается в том, чтобы перебрать все некластеризованные элементы, связанные только c элементами внутри одного кластера, и добавить их в этот кластер.</p></section><section class="doc-section level-4"><h5 id=_агрегация_ресурсов><a class=link href=#_агрегация_ресурсов>Агрегация ресурсов</a></h5><p>Этап <strong>агрегации ресурсов</strong> заключается в том, чтобы оставшиеся некластеризованные ресурсы попытаться объединить в "разумные" группы между собой или с кластеризованными ресурсами.
Строго говоря, на этапе агрегации надо перебрать все возможные попарные соединения и выбрать из них "разумные".
Однако "разумные" пары, как правило, имеют общую операцию, поэтому эмпирический алгоритм агрегации выглядит так:</p><div class="olist arabic"><ol class=arabic><li>Для каждого некластеризовнного ресурса выбрать ресурсы, с которыми у него есть общая операция.</li><li><p>Если в списке есть "разумная" пара данному ресурсу - сгруппировать их.</p><p>Формального критерия разумности у меня нет, но есть эмпирический.
Группа является разумной, если удаление одного из ресурсов делает существование второго бессмысленным.
Этот критерий может дать ложноотрицательный результат - если исходить только из него, то можно пропустить разумную группу ресурсов, которая, с учётом особенностей предметной области или ограничений системы, является таковой.
Но c ложноположительными результатами - объединением в одну группу ресурсов, которое не является разумным - я в своей практике ещё не сталкивался.</p></li></ol></div><p>Далее сгруппированные ресурсы рассматриваются как единое целое - все эффекты связывающие ресурсы этой группы с одной и той же операцией считаются одним эффектом.
Если операцию связывают с группой и эффекты чтения и эффекты записи, то считается, что операция связана с группой эффектом записи.</p><p>После агрегации ресурсов снова возвращаемся к этапу генерации кластеров.
Если на следующей итерации этапы генерации и расширения кластеров не привели к уменьшению количества некластеризованных элементов, то, теоретически, этап агрегации можно повторить и продолжать это делать до включения всех оставшихся ресурсов в одну группу.
Однако практически уже на второй последовательной итерации агрегации (когда одна группа некластеризованных ресурсов содержит в себе три базовых ресурса) нужно быть начеку.
Большие группы зачастую указывают на операции, которые делают слишком много работы и как следствие обладают высокой сцепленностью - в этом случае придётся вернуться к этапу проектирования самих операций и ресурсов.</p><p>В результате применения этого алгоритма вы получите либо полную, либо частичную кластеризацию.
В случае если алгоритм зашёл в тупик и породил только частичную кластеризацию, её необходимо завершить вручную, основываясь на собственной экспертизе, понимании предметной области и ограничений проекта.</p></section></section><section class="doc-section level-3"><h4 id=_ручное_завершение_кластеризации><a class=link href=#_ручное_завершение_кластеризации>Ручное завершение кластеризации</a></h4><p>При ручном завершении кластеризации сначала стоит попытаться закончить кластеризацию без внесения изменений в множества операций и ресурсов.
Однако иногда первоначальные операции и ресурсы никак не укладываются в хорошие кластеры.
В этом случае придётся изначальные операции и ресурсы немного доработать напильником.</p><section class="doc-section level-4"><h5 id=_завершение_кластеризации_с_сохранением_базовой_диаграммы><a class=link href=#_завершение_кластеризации_с_сохранением_базовой_диаграммы>Завершение кластеризации с сохранением базовой диаграммы</a></h5><p>На этой стадии останутся некластеризованными только те элементы, которые связаны с двумя и более кластерами (в противном случае они бы были кластеризованы на шаге расширения кластеров).
И тут, если сохранять исходную структуру диаграммы, есть три базовых варианта действий:</p><div class="olist arabic"><ol class=arabic><li><strong>Выделение в собственный кластер</strong>.
Если элемент выглядит связанным со всеми кластерами в равной степени - его можно поместить в собственный кластер.
В этот же кластер можно добавить другие элементы, связанные с теми же кластерами.</li><li><strong>Внесение в один из существующих кластеров</strong>.
Если с одним из кластеров элемент связан бОльшим количеством связей или они кажутся "сильнее" - его можно внести в этот кластер.
В случае операции стоит принять во внимание её клиента (внешнюю сущность, инициирующую выполнение операции) - если с одним из кластеров у неё общий клиент, то связь с этим кластером сильнее;</li><li><strong>Объединение в мегакластер</strong>.
Если кластеры, связанные с элементом, имеют высокую функциональную связанность - их все можно объединить в один кластер.</li></ol></div><p>При выборе варианта необходимо руководствоваться сцепленностью и функциональной связанностью дизайна.
Для оценки сцепленности каждого варианта надо посчитать в релевантной части получившегося графа количество синих и удвоенное (для отражения их большей сцепляющей силы) количество красных стрелок, пересекающих границы кластеров.
Полученное число и будет относительной оценкой сцепленности варианта.
И при прочих равных лучше выбрать вариант с меньшим значением этого числа.</p><p>Если брать в расчёт только сцепленность, то наилучшим вариантом всегда будет третий вариант, сводящий количество стрелок, пересекающих границы кластера к нулю.
Однако эта логика ведёт нас к абсурдному выводу: просто всё всегда объединять в один суперкластер с нулевой сцепленностью.
И нулевой функциональной связанностью.
А нашей же задачей является, разбить систему на набор модулей с низкой (не нулевой) сцепленностью и высокой функциональной связанностью.</p><p>Поэтому необходимо проверять ещё и функциональную связанность вариантов.
Для этого каждому кластеру надо дать имя.</p><p>Если вы выбрали первый вариант (выделение в собственный кластер) и название кластера кажется слишком "низкоуровневым" — скорее всего вы идёте к патологической расцепленности и от выделения лучше воздержаться.</p><p>Если вы выбрали второй (поместить в существующий кластер) или третий вариант (объединить всё в один мегакластер) и дать получившемуся кластеру хорошее имя не получается — вы идёте к божественному объекту и лучше поискать другой вариант.</p><p>Если ни один из этих вариантов не даёт удовлетворительный на ваш взгляд результат, то придётся менять исходную диаграмму.
Тут универсального алгоритма нет, но могу дать несколько рекомендаций, с которых можно начать поиск решения.</p></section><section class="doc-section level-4"><h5 id=_завершение_кластеризации_с_изменением_базовой_диаграммы><a class=link href=#_завершение_кластеризации_с_изменением_базовой_диаграммы>Завершение кластеризации с изменением базовой диаграммы</a></h5><p>Для любых проблемных <strong>ресурсов</strong> в первую очередь надо рассмотреть вариант разделения их на несколько независимых ресурсов.
Для этого надо проверить - все ли эффекты считывают/изменяют ресурс целиком или одну и ту же его часть?
Или один из эффектов считывает только колонки A и B (из ресурса таблицы), а второй - C и D?
В этом случае стоит рассмотреть вариант разделения таблицы (и ресурса) на две - с колонками A и B и C и D.
Та же самая логика работает и для эффектов записи.</p><p><strong>Операции записи</strong> можно попробовать кластеризовать с помощью расцепки через очередь сообщений.
Для этого необходимо:</p><div class="olist arabic"><ol class=arabic><li>Выделить основной эффект операции;</li><li>Поместить операцию в кластер, с которым её связывает основной эффект;</li><li>В тот же кластер добавить ресурс очереди сообщений для оповещения об основном эффекте;</li><li>Добавить к исходной операции эффект записи по публикации сообщения в эту очередь;</li><li>Все остальные эффекты отвязать от исходной операции;</li><li>Отвязанные эффекты привязать к новым операциям в тех кластерах, ресурсы которых модифицируются этими эффектами и которые будут вызываться после публикации сообщения.</li></ol></div><p>Расцепку <strong>изменяемых ресурсов</strong> также можно выполнить с помощью очереди сообщений и схожей процедуры:</p><div class="olist arabic"><ol class=arabic><li>Выделить основной эффект на ресурс;</li><li>Перенести ресурс в кластер, с которым его связывает основной эффект;</li><li>В кластер второй операции добавить ресурс очереди сообщений о выполнении этой операции;</li><li>В кластер основной операции добавить операцию, которая выполняет вторичный эффект и вызывается в ответ на появление сообщения в очереди из предыдущего пункта;</li><li>У второй операции эффект на исходный ресурс заменить на эффект записи в эту очередь.</li></ol></div><p>Для кластеризации <strong>ресурсов только на чтение</strong> можно рассмотреть вариант их дублирования.
Для этого в каждом кластере, считывающим проблемный ресурс, надо создать копию исходного ресурса и эффекты чтения направить туда, а исходный ресурс удалить.</p><p>Наконец, <strong>операцию только на чтение</strong> можно попытаться кластеризовать комбинацией дублирования ресурсов и расцепкой через очередь сообщений.
Для этого для каждого ресурса проблемной операции надо:</p><div class="olist arabic"><ol class=arabic><li>Продублировать ресурс;</li><li>В кластеры исходных ресурсов добавить ресурсы очередей сообщений о модификации ресурса;</li><li>Ко всем операциям, имеющим эффект записи на ресурс, добавить эффект записи ресурса очереди сообщений;</li><li>Для каждого дубля ресурса добавить операцию, обновляющую этот ресурс в ответ на появление сообщения в очереди;</li><li>Эффект считывания ресурса проблемной операцией перенаправить на его дубль.</li></ol></div><p>Это не исчерпывающий список возможных вариантов кластеризации проблемных элементов, однако эти способы достаточно часто работают.
В крайнем случае, я надеюсь, они подтолкнут вас к открытию собственного варианта решения вашей проблемы.</p><p>После получения полной кластеризации можно переходить к этапу оптимизации кластеров.</p></section></section><section class="doc-section level-3"><h4 id=_оптимизация_кластеров><a class=link href=#_оптимизация_кластеров>Оптимизация кластеров</a></h4><p>Этап оптимизации кластеров состоит из следующих шагов:</p><div class="olist arabic"><ol class=arabic><li>Именование кластеров</li><li>Визуализация графа кластеров</li><li>Анализ графа кластеров</li><li>Объединение кластеров (модулей)<ol class=loweralpha type=a><li>Сокрытие подмодулей</li><li>Группировка функционально схожих модулей</li></ol></li></ol></div><p>На первом шаге каждому кластеру необходимо дать имя, отражающее его содержание.
В случае хорошей декомпозиции - это не составит труда.
Если же определить имя какого-то кластера не получается, то необходимо рассмотреть его внимательнее.
Часто такие проблемы решаются с помощью разделения проблемного кластера на два более мелких и сфокусированных.
Но поиск разумного имени кластера может привести и к перепроектированию ресурсов и операций.</p><p>После того как каждому кластеру дано разумное имя, надо построить визуализацию графа кластеров.
Такая визуализация помогает увидеть "лес за деревьями" и оценить "разумность" уже самого леса.</p><p>Получив граф кластеров - проверьте его на соответствие вашему здравому смыслу.
Я для этого фокусируюсь в первую очередь на связях и их направлении:</p><div class="olist arabic"><ol class=arabic><li>Разумно ли, что этот модуль зависит от того?</li><li>Может ли целевой модуль зависимости существовать без зависимого?</li><li>Какой из модулей более стабилен (более стабильным должен быть целевой модуль)?</li></ol></div><p>У вас могут быть свои вопросы для оценки соответствия здравому смыслу.</p><p>Наконец, последний шаг - найти и объединить подмодули и функционально схожие модули.
Подмодуль - это модуль, обеспечивающий работу одного более высокоуровневого модуля.
В этом случае кластер подмодуля необходимо поместить внутрь кластера модуля.</p><p>Функционально схожие модули - это модули, выполняющие разными способами одну и ту же функциональность, либо выполняющие разные подфункции одной общей функции.
Такие модули надо объединить в общий кластер.
Этому кластеру также надо дать имя и если это вызывает затруднения, то от объединения лучше отказаться.</p><p>Всё, теперь можно создавать структуру пакетов, соответствующую структуре кластеров, в каждом пакете создавать по классу сервиса со всеми операциями кластера и по классу репозитория/клиента/топика для каждого ресурса кластера.</p><p>На этом теоретическая часть закончена, но это только половина пути, поэтому я предлагаю вам прерваться, попить чаю и сделать разминку для глаз:)</p><hr><p>Сделали?
Теперь можно переходить к примеру.</p></section></section></section><section class="doc-section level-1"><h2 id=_кейс_кэмп><a class=link href=#_кейс_кэмп>Кейс: Кэмп</a></h2><p>Примеры в программировании и особенно дизайне - это всегда боль.
Слишком простые или синтетические не особо полезны.
В реальные, со всеми их сложностями - мало кто станет вгружаться, кроме того, в них трудно отделить релевантные детали от шума.
Кэмп является, на мой взгляд, золотой серединой.</p><p><a href="https://play.google.com/store/apps/details?id=ru.ngtrans.camp">Кэмп</a> - реальный проект, который стоил семизначную сумму для заказчика, выполнялся командой из 12 человек (включая двух бакэндеров) и сейчас запущен в промышленную эксплуатацию.
Суммарно на выполнение проекта было затрачено 5500 человеко/часов, из которых 950 - на бакенд.</p><p>Но есть нюанс - это был экспериментальный проект, который (с согласия заказчика) выполнялся силами исключительно молодых специалистов, а лиды только проводили ревью и помогали консультациями.
Поэтому по фактическому объёму функциональности проект достаточно компактный.</p><p>Проект является специализированной геоинформационной системой для водителей-дальнобойщиков.
В отличие от больших ГИС систем вроде Яндекс.Карт он отличается тем, что позволяет найти не просто гостиницу по дороге, а гостиницу где водитель может и сам переночевать и рефрижератор на 86 "кубов" припарковать.</p><p>Соответственно, двумя ключевыми сущностями являются водители и "точки" (кафе, заправки, СТО и т.п.).
Точки в систему вносят сами пользователи после предварительной модерации.
С водителями связаны характеристики машин, которые они водят (сейчас - только тип машины и размер колёс), а с точками - характеристики машин, которые они в состоянии обслужить.</p><p>Кроме того, в системе есть пуш-уведомления пользователей о новостях приложения, а также о результатах модерации добавленной точки.</p><p>Вся эта функциональность отражена на следующей диаграмме эффектов:</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-orig.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-orig.drawio.svg alt="camp effects orig.drawio"></a></div><p>Теперь давайте прогоним алгоритм декомпозиции на базе эффектов на этой диаграмме и посмотрим что получится.</p><section class="doc-section level-2"><h3 id=_кластеризация_диаграммы_эффектов_проекта_кэмп><a class=link href=#_кластеризация_диаграммы_эффектов_проекта_кэмп>Кластеризация диаграммы эффектов проекта Кэмп</a></h3><p>Напомню, общий алгоритм кластеризации диаграммы эффектов состоит из следующих шагов:</p><div class="olist arabic"><ol class=arabic><li>Кластеризация<ol class=loweralpha type=a><li>Первичная кластеризация по алгоритму<ol class=lowerroman type=i><li>Генерация кластеров</li><li>Расширение кластеров</li><li>Агрегация ресурсов</li></ol></li><li>Завершение кластеризации вручную</li></ol></li><li>Оптимизация<ol class=loweralpha type=a><li>Именование кластеров</li><li>Визуализация графа кластеров</li><li>Анализ графа кластеров</li><li>Объединение кластеров (модулей)<ol class=lowerroman type=i><li>Сокрытие подмодулей</li><li>Группировка функционально схожих кластеров</li></ol></li></ol></li></ol></div><section class="doc-section level-3"><h4 id=_этап_кластеризации><a class=link href=#_этап_кластеризации>Этап кластеризации</a></h4><section class="doc-section level-4"><h5 id=_итерация_1_шаг_генерации_кластеров><a class=link href=#_итерация_1_шаг_генерации_кластеров>Итерация 1, шаг генерации кластеров</a></h5><p>На первом шаге надо перебрать все ресурсы и объединить их с сильно связанными с ними операциями.
Перебирать будем в "естественном" порядке - сверху вниз, слева направо.</p><p>Поэтому начнём с ресурса "Сервис отправки СМС".
С ним связана только операция "Запросить OTP", однако она сама связана эффектом записи с другим ресурсом, поэтому пока их откладываем.</p><p>То же самое с ресурсом "OTP" - он связан с операциями "Запросить OTP" и "Получить токен из отп", но обе операции имеют по два эффекта записи, поэтому этот ресурс также пока пропускаем.</p><p>Далее идёт ресурс "Токены".
Его мы, наконец, можем объединить с операцией "Получить токен из логина/пароля" и получить первый кластер (на первом этапе я буду именовать кластеры по порядковому номеру их добавления на диаграмму).
Операцию "Получить токен из отп" и в этом случае пока откладываем, так как она имеет два эффекта записи.</p><p>Теперь переходим к ресурсу "Пользователи".
Этот ресурс является единственным для операций "Изменить пользователя" и "Удалить пользователя", а для операции чтения "Получить пользователя" он, очевидно, является первичным.
Объединяем их все во второй кластер.</p><p>Затем рассмотрим схожие ресурсы "Типы машин" и "Размер колёс", оба ресурса связаны эффектами чтения с операциями чтения "Получить пользователя" и "Получить точки", но ни один из ресурсов не выступает первичным для этих операций, поэтому пока что пропустим их.</p><p>Теперь переходим к ресурсу "Топик 'Точка промодерирована'".
Связанные с ним операции - "Удалить точку" и "Изменить точку" также связаны эффектами записи с другими ресурсами, поэтому этот ресурс пока что оставляем некластеризованным.</p><p>После чего переходим к ресурсу "Точки на карте".
Он явно является первичным для операции чтения "Получить точки", а также единственным ресурсом операции "Создать точку".
Объединяем их в третий кластер.</p><p>Далее у нас снова схожая пара ресурсов "Услуги" и "Тэги".
Оба ресурса связаны своим единственным эффектом чтения с операцией "Получить точки", которая уже входит в третий кластер - отложим их до шага расширения кластеров.</p><p>Теперь переходим к подграфу уведомлений.</p><p>Тут у нас есть ресурс "Сервис отправки Push-уведомлений" с которым связаны операции "Создать новостное уведомление" и "Создать персональные уведомления", у которых по два эффекта записи, поэтому пока их все отложим.</p><p>Зато в четвёртый кластер мы можем объединить ресурс "Уведомления" с операциями "Удалить уведомление", "Получить список новостных уведомлений" (это их единственный ресурс) и "Получить список персональных уведомлений" (для этой операции чтения он является первичным).</p><p>Наконец, в пятый кластер можно объединить последний ресурс "Прочитанные уведомления" и операцию "Прочитать уведомление", для которой он является единственным ресурсом.</p><p>На этом шаг генерации кластеров заканчивается и у нас получается такая промежуточная кластеризация:</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-1.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-1.drawio.svg alt="camp effects step 1.drawio"></a></div></section><section class="doc-section level-4"><h5 id=_итерация_1_шаг_расширения_кластеров><a class=link href=#_итерация_1_шаг_расширения_кластеров>Итерация 1, шаг расширения кластеров</a></h5><p>Далее идёт этап расширения кластеров, на котором все некластеризованные элементы, связанные только с одним кластером, надо поместить в этот кластер.
У нас сейчас таких элементов два - ресурсы "Услуги" и "Тэги" связаны только с третьим кластером - затягиваем их в него (изменённый кластер обозначен пунктирной линией):</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-2.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-2.drawio.svg alt="camp effects step 2.drawio"></a></div></section><section class="doc-section level-4"><h5 id=_итерация_1_шаг_агрегации_ресурсов><a class=link href=#_итерация_1_шаг_агрегации_ресурсов>Итерация 1, шаг агрегации ресурсов</a></h5><p>Теперь переходим к следующему шагу — агрегации ресурсов.
Для этого перебираем оставшиеся некластеризованные ресурсы и смотрим, есть ли для них "разумная" пара, с которой они связаны общей операцией.
Перебор снова будем делать в "естественном" порядке.</p><p>Поэтому начинаем с ресурса "Сервис отправки СМС".
Он через операцию "Запросить OTP" связан с ресурсом "OTP".
Начнём с <a href=#_агрегация_ресурсов>эмпирического критерия разумности</a> - теряет ли смысл существования один из ресурсов при удалении другого из системы.
На данный момент - да.
Сервис отправки СМС используется только для отправки одноразовых паролей, поэтому если удалить ресурс "OTP", то сохранять ресурс "Сервис отправки СМС" сохранять смысла не будет.
Поэтому объединяем их в одну группу.</p><p>Затем идёт пара ресурсов "Типы машин" и "Размер колёс".
И снова начинаем с эмпирического критерия разумности.
На этот раз каждый из ресурсов есть смысл сохранить даже при удалении другого.
Кроме того, группировка этих ресурсов никак не продвинет нас в кластеризации, поэтому эти два ресурса оставляем как есть.</p><p>Далее переходим к ресурсу "Топик 'Точка промодерирована'".
Он через операции "Удалить точку" и "Изменить точку" связан с ресурсом "Точки на карте" и является механизмом оповещения об изменениях в последнем.
Эти два ресурса мы группируем на основе эмпирического критерия разумности - если удалить коллекцию точек, то и оповещать будет не о чем.</p><p>Наконец, ресурсы "Сервис отправки Push-уведомлений" и "Уведомления".
По эмпирическому критерию их не надо группировать - я могу засылать пуши напрямую и не хранить, или перейти к "пулл" уведомлениям.
Однако на мой экспертный взгляд ни того ни другого не случится, а группировка этих ресурсов поможет мне продвинуть кластеризацию, поэтому эту пару я решаю агрегировать.</p><p>После выполнения всех этих агрегаций у нас получается следующий этап кластеризации (здесь агрегированные ресурсы обозначены штриховкой):</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-3.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-3.drawio.svg alt="camp effects step 3.drawio"></a></div><p>Теперь заходим на вторую итерацию и возвращаемся к шагу генерации кластеров.</p></section><section class="doc-section level-4"><h5 id=_итерация_2_шаг_генерации_кластеров><a class=link href=#_итерация_2_шаг_генерации_кластеров>Итерация 2, шаг генерации кластеров</a></h5><p>На второй итерации генерации кластеров мы также проходимся по некластеризованным ресурсам, но теперь агрегированные ресурсы рассматриваем как одно целое.
После агрегации ресурсов операция "Запросить OTP" стала связана одним эффектом записи с группой ресурсов "Сервис отправки СМС" и "ОТП" и теперь можно их кластеризовать:</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-4.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-4.drawio.svg alt="camp effects step 4.drawio"></a></div><p>После этого некластеризованными остались только ресурсы "Типы машин" и "Размер колёс", в отношении которых ничего не поменялось, поэтому переходим на следующий шаг.</p></section><section class="doc-section level-4"><h5 id=_итерация_2_шаг_расширения_кластеров><a class=link href=#_итерация_2_шаг_расширения_кластеров>Итерация 2, шаг расширения кластеров</a></h5><p>После первой итерации шага агрегации ресурсов операции "Удалить точку" и "Изменить точку", а также "Создать новостное уведомление" и "Создать персональное уведомление" стали связаны только с элементами третьего и четвёртого кластера соответственно, поэтому теперь их можно затянуть в эти кластеры:</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-5.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-5.drawio.svg alt="camp effects step 5.drawio"></a></div><p>На этом алгоритм первичной кластеризации зашёл в тупик — операция "Получить токен из отп" связана двумя эффектами записи с разными кластерами, а ресурсы "Типы машин" и "Размеры колёс" связаны с разными кластерами двумя равноценными эффектами чтения.
Пришло время расчехлить свой большой мозолистый мозг.</p></section></section><section class="doc-section level-3"><h4 id=_этап_ручного_завершения_кластеризации><a class=link href=#_этап_ручного_завершения_кластеризации>Этап ручного завершения кластеризации</a></h4><p>Начнём с операции "Получить токен из отп".
Как я писал в <a href="#С сохранением базовой диаграммы">теоретической части</a>, в этом случае у нас есть три варианта действий с сохранением изначальной структуры:</p><div class="olist arabic"><ol class=arabic><li>Поместить в собственный кластер;</li><li>Внести в шестой (первый) кластер;</li><li>Объединить первый и шестой кластер и внести туда;</li></ol></div><p>Визуально эти варианты выглядят так:</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-6-variants.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-6-variants.drawio.svg alt="camp effects step 6 variants.drawio" height=500></a></div><p>В целом, все эти варианты не выглядят очевидно бессмысленными и могут быть обоснованы.
Но давайте рассмотрим их с точки зрения "тяжести" графа - пусть связь между кластерами синей стрелкой будет стоить одну единицу, а красной - две.
В этом случае вес вариантов выше будет следующий:</p><div class="olist arabic"><ol class=arabic><li>6</li><li>4 (4)</li><li>2</li></ol></div><p>Вполне предсказуемо, выигрывает вариант 3, который исключает все эффекты между рассматриваемыми кластерами.
Теперь надо проверить связанность этого кластера, с помощью именования.
На мой взгляд, выбор имени для этого кластера не составляет труда - всё что попало внутрь касается авторизации и только авторизации, поэтому кластеру отлично подходит имя "Авторизация".</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>При желании тут можно разглядеть ещё одну возможность к перепроектированию системы и ещё большему снижению её сцепленности.
В частности, операции получения токенов обращаются к коллекции "Пользователи" только за аутентификационными данными - телефоном/логином (ещё один спорный момент) и ролями пользователя.
И если эту информацию вынести в отдельные ресурсы (которые внутри будут таблицами с внешним ключём на таблицу пользователей), то от связи на уровне кода между модулями авторизации и пользователей можно будет избавиться полностью.
Но дальнейший разбор этого направления я оставлю за скобками и без того огромного поста.</p></aside><p>Теперь у нас осталось только два некластеризованных элемента - ресурсы "Типы машин" и "Размеры колёс".</p><p>Для них три базовых варианта будут выглядеть так:</p><div class="olist arabic"><ol class=arabic><li>Объединить их в собственный кластер;</li><li>Внести во второй (третий) кластер;</li><li>Объединить второй и третий кластер и внести туда;</li></ol></div><p>Вес графов этих вариантов будет следующий:</p><div class="olist arabic"><ol class=arabic><li>4</li><li>2 (2)</li><li>0</li></ol></div><p>Тут снова предсказуемо побеждает третий (объединить кластер с пользователями и точками в один мегакластер) вариант.
Но этот вариант - просто сразу нет.
Не думаю, что здесь надо что-то пояснять.</p><p>Далее по сцепленности идёт вариант с помещением этих ресурсов в один из существующих кластеров, но в обоих случаях эти ресурсы создадут проблемы с именованием итоговых кластеров.</p><p>Поэтому я выбираю третий вариант и помещаю их в собственный кластер.
Пусть это будет вариант с наибольшей сцепленностью, зато - и с наибольшей функциональной связанностью всех трёх получившихся кластеров.
А сцепленность, хоть и наибольшая - но на чтение, и на неё можно посмотреть сквозь пальцы.
Наконец, у нас вся система про то, чтобы матчить пользователей с точками, на основании характеристик машин - об этом стоит явно сказать на верхнеуровневой структуре модулей.</p><p>В итоге я получаю следующую первичную кластеризацию:</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-6.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-6.drawio.svg alt="camp effects step 6.drawio"></a></div><p>И теперь мы можем переходить к этапу её оптимизации.</p></section><section class="doc-section level-3"><h4 id=_этап_именования_кластеров><a class=link href=#_этап_именования_кластеров>Этап именования кластеров</a></h4><p>На этом этапе мы по очереди рассматриваем кластеры и даём им имена, отражающие их содержимое.</p><p>Так, для кластера с элементами "Запросить OTP", "Сервис отправки СМС", "OTP", "Получить токен из отп", "Токены" и "Получить токен из логина/пароля" на мой взгляд отлично подходит имя <strong>"Авторизация"</strong>.</p><p>Для кластера с элементами "Пользователи", "Изменить пользователя", "Удалить пользователя" и "Получить пользователя" - подходит имя <strong>"Пользователи"</strong>.</p><p>Кластер с элементами "Типы машин" и "Размер колёс" можно назвать <strong>"Характеристики машин"</strong>.</p><p>Самому большому кластеру с элементами "Точки на карте", "Топик результатов модерации", "Создать точку", "Удалить точку", "Изменить точку", "Получить точки", "Услуги", "Тэги" можно дать имя <strong>"Точки"</strong>.</p><p>Затем кластеру с элементами "Уведомления", "Сервис отправки Push-уведомлений", "Создать новостное уведомление", "Создать персональное уведомление", "Удалить уведомление", "Получить список новостных уведомлений", "Получить список персональных уведомлений" подходит имя <strong>"Уведомления"</strong>.</p><p>А вот для последнего кластера с элементами "Прочитанные уведомления" и "Прочитать уведомление" имя "Прочитанные уведомления" хоть и подходит, но меня заставляет поморщиться.
Это слишком низкоуровневая штука, для верхнеуровневой структуры модулей.</p><p>Быстрым решением будет объединить этот кластер с кластером <strong>"Уведомления"</strong>.
Однако меня эта нестыковка вывела на другое решение.</p><p>Напомню, что в системе есть два вида уведомлений - персональные и новостные.
На данный момент они хранятся в общем ресурсе - "Уведомления".
И я задумался - а что общего у персональных и новостных уведомлений?</p><p>На самом деле - практически ничего.</p><p>Флаг прочтения есть только у персональных уведомлений.
Уведомления отправляются разными экторами в разное время - персональные отправляются системой автоматически, а новостные - по запросу администратора.
Они отправляются разным людям - персональные отправляются водителю, создавшему точку, а новостные - всем водителям.
Даже методы API для отправки используются разные.</p><p>И так я пришёл к тому, что у меня была ошибка в изначальном дизайне - ресурсы "Уведомления" и "Сервис отправки Push-уведомлений" надо было разделить на два - для персональных и новостных уведомлений.
И если это сделать, то всё сразу встаёт на свои места - этим двум новым кластерам легко дать имена <strong>"Новостные уведомления"</strong> и <strong>"Персональные уведомления"</strong> и они будут уже не так сильно выбиваться по уровню абстракции:</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-7.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-7.drawio.svg alt="camp effects step 7.drawio"></a></div><p>Теперь мы можем переходить к шагу анализа графа кластеров.</p></section><section class="doc-section level-3"><h4 id=_этап_анализа_графа_кластеров><a class=link href=#_этап_анализа_графа_кластеров>Этап анализа графа кластеров</a></h4><p>На этом этапе первым делом необходимо этот граф визуализировать.
Это та самая "верхнеуровневая структура модулей", на которой сразу видно элементы, выпадающие по уровню абстракции.</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-8.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-8.drawio.svg alt="camp effects step 8.drawio"></a></div><p>При анализе я в первую очередь смотрю на зависимости.</p><p>Разумно ли, что авторизация зависит от пользователей?
Мне кажется разумно - мы же пользователей авторизуем.</p><p>Разумно ли, что пользователи и точки зависят от характеристик машин?
Мне кажется разумно - характеристики машин являются абстрактными понятиями, характеризующими машины конкретных пользователей и конкретные точки.</p><p>Затем я проверяю, что все элементы графа имеют один уровень абстракции.
И на мой взгляд "Новостные уведомления" и "Персональные уведомления" выпадают по уровню абстракции.
А вот если их спрятать в более абстрактном модуле "Уведомления" - всё встанет на свои места.</p><p>И это даёт нам итоговую декомпозицию системы на пять верхнеуровневых модулей:</p><div class=image-block><a class="image bare" href=/posts/23/04/images/camp/camp-effects-step-9.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/04/images/camp/camp-effects-step-9.drawio.svg alt="camp effects step 9.drawio"></a></div><p>На этом декомпозиция системы завершена - можно создавать проект, там заводить по пакету (или модулю) на каждый кластер, в каждом пакете создавать класс сервиса, для каждой операции кластера в соответствующем классе определять метод и вперёд, можно кодировать.</p></section></section></section><section class="doc-section level-1"><h2 id=_подход_проверен_и_обоснован_научно><a class=link href=#_подход_проверен_и_обоснован_научно>Подход проверен и обоснован научно</a></h2><p>Всё, что я описал выше - и саму концепцию декомпозиции на базе эффектов, и диаграмму эффектов и методику декомпозиции - я придумал сам долгими вечерами и ночами.
А потом нашёл три научных статьи, описывающих такой же по сути подход:</p><div class=ulist><ul><li><a href=https://www.researchgate.net/publication/283566310_Improving_Design_Decomposition>Improving Design Decomposition</a>;</li><li><a href=https://www.researchgate.net/publication/326260296_Functional_Decomposition_for_Software_Architecture_Evolution>Functional Decomposition for Software Architecture Evolution</a>;</li><li><a href=https://www.researchgate.net/publication/327229270_Identifying_Microservices_Using_Functional_Decomposition_4th_International_Symposium_SETTA_2018_Beijing_China_September_4-6_2018_Proceedings>Identifying Microservices Using Functional Decomposition</a>.</li></ul></div><p>Я не буду здесь подробно останавливаться на этих статьях - они в открытом доступе и заинтересованный читатель может изучить их самостоятельно - приведу лишь главный, с моей точки зрения, тезис:</p><div class=quote-block><blockquote><p>The evaluation results give us reasons to believe that our approach identifies microservices in a quality that is comparable to a design done by human software designers.
Our approach, however, achieved the microservices identification much faster and with less effort compared to human developers.
While identifying the microservices was a matter of days for the students at KIT and SWU-RISE, by employing our approach it was a matter of hours.</p><p>Результаты оценки дают нам основания полагать, что наш подход выявляет микросервисы, качество которых сравнимо с дизайном, выполненным людьми.
При этом наш подход позволяет выявлять микросервисы гораздо быстрее и с меньшими усилиями по сравнению с выполнением этой работы вручную.
В то время как у студентов KIT и SWU-RISE выявление микросервисов потребовало несколько дней, с использованием нашего подхода это заняло несколько часов.</p><footer>— <cite>Shmuel Tyszberowicz, Robert Heinrich, Bo Liu and Zhiming Liu, Identifying Microservices Using Functional Decomposition</cite></footer></blockquote></div></section><section class="doc-section level-1"><h2 id=_ограничения_подхода_к_декомпозиции_на_базе_эффектов><a class=link href=#_ограничения_подхода_к_декомпозиции_на_базе_эффектов>Ограничения подхода к декомпозиции на базе эффектов</a></h2><p>Но серебряных пуль не бывает и декомпозиция на базе эффектов также не является таковой и имеет свои ограничения.</p><p>Чтобы выполнить декомпозицию на базе эффектов, необходимо построить диаграмму эффектов.
А для этого надо весьма подробно понимать, что и как надо сделать.
А для этого надо техзадание.
Соответственно, если у вас нет ТЗ - выполнить декомпозицию на базе эффектов не получится.</p><p>Но в этом случае можно сделать финт ушами.
Начать программировать с любой декомпозицией - хоть по слоям.
А потом, когда станет понятно <strong>что</strong> вы делаете и у вас накопится какой-то объём кода, выполнить обратный процесс - построить диаграмму эффектов по коду.
Её уже декомпозировать и потом отрефакторить код в соответствии с результатом декомпозиции.</p><p>Также стоит иметь в виду, что этот подход всё ещё находится на стадии опытной эксплуатации, и максимальный размер проекта, который я по нему декомпозировал, составляет один человеко-год.
Но с другой стороны, я не могу представить, чтобы кто-то в 2023 году сразу проектировал систему на десять человеко-лет вперёд.
Скорее всего, вы и так пойдёте небольшими итерациями в год максимум, и на таком масштабе декомпозиция на базе эффектов отлично работает.</p><p>Наконец, с точки зрения типа и характера задач, подход на базе эффектов хорошо подходит для декомпозиции систем с богатым состоянием и правилами его изменения.
Если же в системе состояния как такого немного — такую систему декомпозировать на базе эффектов уже не получится.
В компиляторах, например, из ресурсов будет только коллекция исходников, из операций - "Скомплировать" и всё, декомпозировать нечего.</p></section><section class="doc-section level-1"><h2 id=_характеристики_подхода_к_декомпозиции_на_базе_эффектов><a class=link href=#_характеристики_подхода_к_декомпозиции_на_базе_эффектов>Характеристики подхода к декомпозиции на базе эффектов</a></h2><p>Итак, для того чтобы максимизировать количество дофамина и минимизировать количество кортизола в команде, нам нужен подход к декомпозиции, который обладает следующими характеристиками:</p><div class="olist arabic"><ol class=arabic><li>Вообще есть;</li><li>Прост в изучении;</li><li>Прост в исполнении;</li><li>Даёт хорошие результаты вне зависимости от исполнителя;</li></ol></div><p>Обладает ли подход к декомпозиции на базе эффектов этими характеристиками?</p><p>Во-первых, он безусловно есть.</p><p>Во-вторых и третьих, для меня он существенно проще в изучении и исполнении чем DDD.
Является ли он таковым для вас - судить вам.
Вы можете попробовать его применить в своём проекте или его небольшой части - это займёт немного времени, и вне зависимости от результатов поможет вам лучше понять свою систему.
По моему опыту трудозатраты на декомпозицию на базе эффектов идут в соотношении 1-2 человеко/часа проектирования к 1 человеко-месяцу разработки.
Соответственно, со скидкой на отсутствие опыта, на декомпозицию проекта на 2 человеко-месяца вам должно хватить одного человеко-дня.</p><p>Наконец, результаты декомпозиции на базе эффектов всё-таки зависят от исполнителя, но в меньшей степени, чем интуитивная декомпозиция или декомпозиция на базе границ в языке предметной области.</p><p>В итоге по своему опыту могу сказать, что подход к декомпоизиции на базе эффектов действительно помогает максимизировать количество дофамина (и минимизировать количество кортизола) от разработки и для команды и для бизнеса.</p></section></article><br></section></div></main><script src=/js/app.js></script></body></html>