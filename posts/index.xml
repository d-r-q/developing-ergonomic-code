<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Алексей Жидков</title><link>https://azhidkov.pro/posts/</link><description>Recent content in Posts on Алексей Жидков</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Tue, 31 Oct 2023 08:25:37 +0700</lastBuildDate><atom:link href="https://azhidkov.pro/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>ФП виновно в снижении стоимости программ. Вот мои доказательства, господа присяжные заседатели</title><link>https://azhidkov.pro/posts/23/10/why-fp/</link><pubDate>Tue, 31 Oct 2023 08:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/23/10/why-fp/</guid><description>ВведениеСреди особенностей Эргономичного подхода у моих заказчиков, коллег и студентов наибольшее сопротивление вызывает использование Spring Data JDBC, а не [Spring Data] JPA (де-факто стандарта работы с БД на платформе Java).
Изначально я собирался писать пост &amp;#34;Почему не JPA&amp;#34;, но немного подумав понял, что ответ умещается в одно предложение: потому что JPA по своей природе (persistence context и dirty checking) не поддерживает неизменяемую модель данных - неотъемлемую часть функционального стиля программирования, который, в свою очередь, является неотъемлемой частью Эргономичного подхода.</description></item><item><title>Как я превратил легаси-проект в конфетку за полгода. Том 2</title><link>https://azhidkov.pro/posts/23/10/project-e-part2/</link><pubDate>Tue, 26 Sep 2023 01:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/23/10/project-e-part2/</guid><description>ВведениеЭто второй том эпопеи, о том как, я превратил легаси-систему в конфетку за полгода:
Том первый. &amp;#34;Пациент скорее мёртв, чем жив&amp;#34; - описание проекта, история получения разрешения на реинжиниринг и планирование работТом второй. &amp;#34;Доктор сказал в морг, значит в морг&amp;#34; - описание процесса работы, что пошло не по плану, как факапились в проде и чем всё закончилосьТом третий. &amp;#34;Анатомический атлас конфетки&amp;#34; - детали реализации &amp;#34;конфетки&amp;#34;Том четвёртый. &amp;#34;Это наследственное&amp;#34; - какие проблемы были вызваны сменой архитектуры и стека, а также необходимостью параллельной работы со старым бэком Первая часть закончилась на том, что я составил план, которого мне оставалось придерживаться.</description></item><item><title>Как я превратил легаси-проект в конфетку за полгода. Том 1</title><link>https://azhidkov.pro/posts/23/09/project-e-part1/</link><pubDate>Wed, 13 Sep 2023 01:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/23/09/project-e-part1/</guid><description>ВведениеНедавно мне удалось за шесть месяцев превратить полный боли, багов и сорванных дедлайнов легаси-проект на микросервисной архитектуре в полный фана проект на монолите, в котором мы стабильно попадаем в дедлайны, а существенные баги в коде бэка доходят до команды QA пару раз в квартал.
Эта эпопея не сильно уступает по объёму &amp;#34;Войне и Миру&amp;#34;, поэтому я разбил её на четыре тома:
Том первый. &amp;#34;Пациент скорее мёртв, чем жив&amp;#34; - описание проекта, история получения разрешения на реинжиниринг и планирование работТом второй.</description></item><item><title>Сравнение эффективности работы команд Проекта Э до и после реинжинирига</title><link>https://azhidkov.pro/posts/23/07/project-e-results/</link><pubDate>Fri, 14 Jul 2023 08:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/23/07/project-e-results/</guid><description>ВведениеМы закончили реинжиниринг Проекта Э, поработали три месяца только с новой кодовой базой и пришло время подводить итоги.
В изначальных критериях успеха реинжиниринга Проекта Э я целился в то, чтобы как минимум удвоить скорость разработки - лучше и объективно, и субъективно по мнению РП и заказчика. Но субъективные ощущения РП и заказчика не совпадают - РП видит увеличение скорости разработки, а заказчик - нет. Поэтому я перелопатил 517 задач в Jira, чтобы понять объективное состояние дел.</description></item><item><title>Рациональный подход к декомпозиции систем на модули или микросервисы</title><link>https://azhidkov.pro/posts/23/04/ergonomic-decomposition/</link><pubDate>Sat, 15 Apr 2023 01:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/23/04/ergonomic-decomposition/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Note: Данный пост является базовым материалом для моего доклада на JPoint 2023
Чего от разработки ПО хотят разработчики, продакты и владельцы бизнеса?Одного и того же - побольше дофаминчика (гормон счастья), поменьше кортизольчика (гормон стресса). Притом источники и дофамина, и кортизола у них одни и те же. Дофамин вырабатывается, когда фичи выпускаются в срок и без багов, а кортизол - когда сроки срываются и вылазят баги и регрессии.</description></item><item><title>Что почитать разработчику?</title><link>https://azhidkov.pro/posts/22/09/ergo-reading-list/</link><pubDate>Thu, 25 Aug 2022 12:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/22/09/ergo-reading-list/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Этот пост содержит подборки книг, которые на мой взгляд стоит прочитать профессиональному разработчику. Большинство книг я рекомендую читать на английском, так как русские переводы зачастую фатально искажают смысл.
Одна лучшая книга в области программирования за всю историю по версии меняЕстественно, лучшая книга по программированию - книга об Эргономичном подходе:) К сожалению, она ещё не написана.
Но у меня уже есть ряд постов (~80-100 страниц), которые можно почитать:</description></item><item><title>Подходы к декомпозиции бэкендов информационных систем</title><link>https://azhidkov.pro/posts/22/08/ergonomic-decomposition/</link><pubDate>Tue, 09 Aug 2022 08:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/22/08/ergonomic-decomposition/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
a class is a necessary but insufficient vehicle for decomposition
Класс - это необходимое, но недостаточное средство декомпозиции
— Grady Booch, Object-Oriented Analysis and Design with Applications Количество классов в реализации даже небольшой программы на один человеко-месяц исчисляется десятками. В средних программах на несколько человеко-лет счёт идёт уже на тысячи. А человек может одновременно оперировать 7-ю +/- 2 объектами.</description></item><item><title>Абстрактные войны: public interface IAbstraction против абстракции</title><link>https://azhidkov.pro/posts/22/07/abstraction-wars/</link><pubDate>Wed, 06 Jul 2022 05:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/22/07/abstraction-wars/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
ВведениеПочти 30 лет назад в классической книге по шаблонам проектирования Design Patterns: Elements of Reusable Object-Oriented Software, авторы сформулировали один из самых известных, но недопонятых принципов в истории программирования:
Program to an interface, not an implementation.
— Erich Gamma et. al, Design Patterns: Elements of Reusable Object-Oriented Software Зачем &amp;#34;программировать в интерфейсы&amp;#34;? Для того чтобы реализацию этого интерфейса можно было менять без изменений клиентского кода.</description></item><item><title>Диаграмма эффектов: пример построения</title><link>https://azhidkov.pro/posts/22/06/220611-true-story-project/</link><pubDate>Sat, 11 Jun 2022 08:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/22/06/220611-true-story-project/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Это второй пост в серии, посвящённый диаграмме эффектов:
&amp;#34;Спецификация&amp;#34; - назначение диаграммы, основные концептуальные элементы и их визуальное представление&amp;#34;Пример построения, проект True Story Project (TSP)&amp;#34; - процесс построения диаграммы эффектов реального проекта&amp;#34;Декомпозиция системы на модули на базе диаграммы эффектов&amp;#34; - рациональный подход к разбиению системы на модули с помощью диаграммы эффектов и его применение для декомпозиции проекта TSP&amp;#34;Перевод диаграммы в код&amp;#34; - процесс трансляции диаграммы в исходный код на примере проекта TSP ВведениеВедущие разработчики (ака техлиды, тимлиды, архитекторы) встречаются с целым рядом нетривиальных вопросов:</description></item><item><title>Диаграмма Эффектов: Спецификация v0.0.2</title><link>https://azhidkov.pro/posts/22/05/220519-effects-diagram-intro/</link><pubDate>Thu, 19 May 2022 01:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/22/05/220519-effects-diagram-intro/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Note: Этот пост является первой попыткой описать диаграмму формально, поэтому в описании возможны неточности и пробелы, а детали и нотация наверняка изменятся в будущем.
Это первый пост в серии, посвящённый диаграмме эффектов:
&amp;#34;Спецификация&amp;#34;: назначение диаграммы, основные концептуальные элементы и их визуальное представление&amp;#34;Пример построения диаграммы, проект True Story Project (TSP)&amp;#34; - процесс построения диаграммы эффектов реального проекта&amp;#34;Методика объектно-ориентированной декомпозиции&amp;#34; - рациональный подход к разбиению системы на модули с помощью диаграммы эффектов и его применение для декомпозиции проекта TSP&amp;#34;Методика перевода диаграммы в код&amp;#34; - процесс трансляции диаграммы в исходный код на примере проекта TSP ВведениеИдентичность информационной системы определяется тем, как она взаимодействует с внешним миром.</description></item><item><title>Эргономичный подход v1.0M1</title><link>https://azhidkov.pro/posts/22/04/220409-ergo-approach-v10m1/</link><pubDate>Sat, 09 Apr 2022 08:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/22/04/220409-ergo-approach-v10m1/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
ПредисловиеЯ рад сообщить о завершении этапа прототипирования и проверки гипотезы Эргономичного подхода и переходе к стабилизации и продуктизации.
Работу над Эргономичным подходом я начал весной 2020 года. Причиной тому стал возврат к работе над стандартными для экосистемы Spring-а проектами после четырёхлетнего перерыва.
На контрасте с работой над своими проектами, я особенно остро ощутил уже забытые чувства раздражения от избыточной трудоёмкости решения задач и страха внести регрессию.</description></item><item><title>Агрегаты</title><link>https://azhidkov.pro/posts/22/04/220401-aggregates/</link><pubDate>Fri, 01 Apr 2022 08:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/22/04/220401-aggregates/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
ВведениеNote: В процессе написания этого поста, стало очевидно, что ему нужны подводки в виде того, чем агрегаты лучше связного графа сущностей и что такое диаграмма эффектов. Но так как я этот пост мурыжу уже два месяца, я решил последовать примеру Джорджа Лукаса и начать с конца:)
В предыдущем посте (Черновик поста) я рассмотрел подходы к проектированию модели информации системы и пришёл к выводу, что наилучшим подходом является подход на базе агрегатов.</description></item><item><title>Структура эргономичных программ</title><link>https://azhidkov.pro/posts/21/10/211018-ergo-approach-post/</link><pubDate>Mon, 29 Nov 2021 12:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/10/211018-ergo-approach-post/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
В этом посте мы рассмотрим основные структуры кодовой базы, свойственные лёгким в поддержке информационным системам (ИС). Я буду постепенно приближаться от максимально абстрактного взгляда на ИС до структуры реализации отдельных функций ИС.
Абстракция информационной системыNote: Здесь я рассматриваю только разработку бэкендов информационных систем на базе Spring Framework, но этот материал применим к разработке информационных систем на базе других технологий.</description></item><item><title>Что я делаю не так</title><link>https://azhidkov.pro/posts/21/11/211107-what-is-the-difference/</link><pubDate>Sat, 06 Nov 2021 12:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/11/211107-what-is-the-difference/</guid><description>&amp;#34;Алексей - один из лучших разработчиков, с которыми я работал. Работой с ним я удовлетворён на 10 баллов из 10, потому что он практически всегда попадает в озвученные сроки, и в работе с ним не приходится накидывать 50% на всякий пожарный&amp;#34;.
— Денис Исаев, руководитель проектов Привет! Алексей - это я. В этом посте я расскажу, что я делаю не так, как принято, чтобы получать такие отзывы.
Свой подход к разработке я называю Эргономичным и от общепринятого он отличается следующим:</description></item><item><title>Архитектура ориентированная на трансформацию</title><link>https://azhidkov.pro/posts/21/09/210925-maintanable-arch/</link><pubDate>Sat, 25 Sep 2021 11:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/09/210925-maintanable-arch/</guid><description>Note: Это пост в формате &amp;#34;мысли в слух&amp;#34; - без редактуры и проверки фактов, написанный для того чтобы перестать мусолить его в голове и наконец уснуть.
Последние несколько лет я активно топил за чистую архитектуру анкл Боба и даже сделал два с половиной проекта в соответсвии с ней:
И эти проекты показали, что следование чистой архтиектуре генеряет кучу геммороя.
Транзакции в слое интеракторов нельзя обозначать обычной @Transactional - приходится писать кастомный Transactor.</description></item><item><title>Многоликий принцип единственности ответственности</title><link>https://azhidkov.pro/posts/21/06/210626-srp-interpretations/</link><pubDate>Mon, 21 Jun 2021 11:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/06/210626-srp-interpretations/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Кажется, любой &amp;#34;солидный&amp;#34; программист знает что такое SOLID вообще и принцип единственности ответственности (SRP) в частности.
Спойлер, если вдруг не знаетеSOLID - это название принципов объектно-ориентированного дизайна, сформулированных Робертом Мартином, так же известным как анкл Боб. Принципы звучат следующим образом:
Single Responsibility Principle: A module should have one, and only one, reason to change.Open/Closed Principle:: A software artifact should be open for extension but closed for modification.</description></item><item><title>Анкл Боб не всегда прав</title><link>https://azhidkov.pro/posts/21/04/srp-ocp-conflict/</link><pubDate>Wed, 28 Apr 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/04/srp-ocp-conflict/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Свежий пост Анкл БобаПрочитал свежий пост Анкл Боба и я с ним категорически не согласен.
Краткое содержание поста:
Где-то в интернете спросили как зарефакторить код:
Анкл Боб сказал, что правильно инкапсулировать этот иф в фабрику:
И далее он пишет:
Every business rule that would once have depended on an if/else/switch statement now has its own particular method to call in the base class</description></item><item><title>Почему следует избегать использования JPA/Hibernate в продакшене</title><link>https://azhidkov.pro/posts/21/04/why-jpa-should-be-avoided/</link><pubDate>Sat, 03 Apr 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/04/why-jpa-should-be-avoided/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Обновление от 19.11.21:
Добавил ссылок на книги в Весь код становится кодом с побочными эффектами Обновление от 22.08.21:
Раздел Плохой процедурный стиль программированияРаздел Что делать, если JPA невозможно избежатьРаздел Ссылки Дисклеймер - я люто ненавижу JPA/HibernateМои отношения с Hibernate (JPA тогда ещё не было) не сложились с самого начала - в далёком то ли 2005, то ли 2007, на собеседовании у меня спросили как замапить отношение 1-N в Hibernate.</description></item><item><title>О декомпозиции систем</title><link>https://azhidkov.pro/posts/21/03/250326-project-decomposiotion/</link><pubDate>Wed, 24 Mar 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/03/250326-project-decomposiotion/</guid><description>Дисклаймер: это небольшой линко-пост на тему, достойную главы книги
Наконец-то свершилась ваша мечта и вам досталось сделать проект с чистого листа. Наконец-то вы можете сделать всё правильно, а не воевать с легаси написанным сто лет назад людьми, которых вы никогда не видели.
Но как это сделать? Как сделать систему, за которую вас не будут проклинать ваши последователи?
Половину ответа я уже в каком-то виде описал в книге - это таблица эффектов приложения и компоненты.</description></item><item><title>Тесты, которым можно доверять</title><link>https://azhidkov.pro/posts/21/03/210321-project-l-testing/</link><pubDate>Sat, 13 Mar 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/03/210321-project-l-testing/</guid><description>Я сейчас делаю проект с чистого листа, в котором я основой и ведущий бакэндер. И, естественно, я его делаю в соответствии с Эргономичным Подходом.
Главным условием для того, чтобы кодовая база была эргономичной является набор тестов, которым можно доверять. Если тесты прошли - можно релизать. И никак иначе.
В этом посте я расскажу, как я организовал тестирование &amp;#34;Проекта Л&amp;#34;.
Проект ЛПроект под NDA, поэтому в подробностях я его описать не могу, но могу привести ряд ключевых характеристик:</description></item><item><title>Неэргономичный Jackson</title><link>https://azhidkov.pro/posts/21/02/210212-jackson-write-object-as-string/</link><pubDate>Tue, 23 Feb 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/02/210212-jackson-write-object-as-string/</guid><description>В последнее вермя несколько раз писал примерно такой код для сериализации объекта в json Jackson-ом:
public String renderToJson(Object dto) { try { return objectMapper.writeValueAsString(dto); } catch (IOException e) { throw new AssertionError(&amp;#34;Unexpected IOException converting object to json&amp;#34;); } } И мне это глаз резало - я генерирую строку в памяти, какой нафик IO??? Но задуматься времени не было.
А тут за чтением The modern way to perform error handling из глубин подсознания внезапно всплыл ответ:) И знаете что я вам скажу?</description></item><item><title>Типы функций: функции-мошенники</title><link>https://azhidkov.pro/posts/21/01/210126-fraud-functions/</link><pubDate>Tue, 26 Jan 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210126-fraud-functions/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Начало темы здесь, здесь и здесь.
С второго взгляда терминология оказалась не такой уж чудесной, как показалась на первый взгляд, но я на этом посте засиделся, так что публикую как есть. В посте с итогами ещё раз попробую составить приличную терминологию.
Как я уже писал в прошлой статье, эффекты - это то ради чего пишутся программы, и тот критерий, по которому программы оцениваются.</description></item><item><title>Красная или синяя?</title><link>https://azhidkov.pro/posts/21/01/210122-pp-vs-fp/</link><pubDate>Fri, 22 Jan 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210122-pp-vs-fp/</guid><description>Статья не отредактирована после переезда с телеграфа. Оригинал
Привет! Чёт ~эта неделька опять выдалась сложная~ я прокрастинирую пост о грязных функциях и сайд эффектах, потому что там кой-чего не схоидтся. Поэтому сёня пост в бок с хейтом мейнстримного ``ООП&amp;#39;&amp;#39; - почитывал на досуге код на кложуре, и меня опять малёха бомбануло.
Меня тут осенило. Возьмём вот такой кусочек кода на кложуре (чисто функциональном языке): (my-app.users/reset-passworduser) Здесь вызываюется функция reset-password из неймспейса my-app.</description></item><item><title>Чистые и эффективные функции: Эффекты</title><link>https://azhidkov.pro/posts/21/01/210119-effects/</link><pubDate>Tue, 19 Jan 2021 09:19:22 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210119-effects/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Начало темы здесь и здесь.
Сегодня расскажу о том, что я понимаю под эффектами и обработкой сигналов.
Что я понимаю под эффектами и сигналамиОбработка сигнала - акт чтения глобальной изменяемой памяти.
Отправка сигнала - акт записи глобальной изменяемой памяти.
Глобальная изменяемая память - область памяти, на которую в момент чтения/записи замаплено изменяемое поле объекта или структуры, достижимого из GC root.</description></item><item><title>Чистые и грязные функции, эффекты и обработка сигналов, сайдэффекты: чистые функции</title><link>https://azhidkov.pro/posts/21/01/210112-pure-functions/</link><pubDate>Tue, 12 Jan 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210112-pure-functions/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Начало темы здесь
Обращаю ваше внимание, что топик расширился - помимо анонсированных вчера грязных функций, вчера же я ещё &amp;#34;открыл&amp;#34; сигналы. Заголовок конечно длинноват, но пока так:) Но обо всём по порядку и сегодня у нас чистые функции.
Чистая функция - это функция без эффектов и сайдэффектов:) Или функция в математическом смысле - её результат определяется исключительно параметрами и у неё только один результат - возвращаемое значение.</description></item><item><title>Single Responsibility Principle considered harmful</title><link>https://azhidkov.pro/posts/21/01/210107-srp/</link><pubDate>Thu, 07 Jan 2021 07:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210107-srp/</guid><description>Наткнулся тут на эту статью и чёт меня малёха бомбануло.
Теоретически, принцип (Single Responsibility Principle ) возможно хороший и правильный, ток с ним есть одна проблема - анкл Боб 20 (двадцать) лет его объясняет и ни как объяснить не может.
Мне удалось отследить следующую историю формулировок этого принципа самим Мартином:
2003: &amp;#34;A class should have only one reason to change&amp;#34; - Agile Software Development, Principles, Patterns, and Practices2008: &amp;#34;The Single Responsibility Principle (SRP) states that a class or module should have one, and only one, reason to change&amp;#34; - Clean Code2014: &amp;#34;Gather together the things that change for the same reasons.</description></item><item><title>Чистые и эффективные функции: Введение</title><link>https://azhidkov.pro/posts/21/01/210105-pure-functions-and-effects-intro/</link><pubDate>Tue, 05 Jan 2021 09:19:22 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210105-pure-functions-and-effects-intro/</guid><description>В этом блоге и своей книге я постоянно повторяю мантру о &amp;#34;разделении эффектов и логики&amp;#34; и поэтому мне необходимо, чтобы читатели однозначно меня понимали. Однако когда я начал разбирать существующую терминологию, с удивлением обнаружил, что общепринятой вообще нет, а те варианты что есть не отражают важных мне нюансов. Поэтому я решил написать цикл статей об используемой мной терминологии.
С чистыми функциями всё более-менее просто, у них на вики есть внятное определение:</description></item></channel></rss>