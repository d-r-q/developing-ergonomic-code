<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Абстрактные войны: public interface IAbstraction против абстракции - Алексей Жидков"><meta property="og:description" content="Почти 30 лет назад в классической книге , авторы сформулировали один из недопонятых принципов в истории программирования: Program to an interface, not an implementation. Разбираемся почему для следования этому принципу недостаточно просто добавлять интерфейсы."><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/22/07/abstraction-wars/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/22/07/abstraction-wars/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/22/07/abstraction-wars/><title>Абстрактные войны: public interface IAbstraction против абстракции - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/22/07/abstraction-wars/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Абстрактные войны: public interface IAbstraction против абстракции</h1><h2 class=date>July 6, 2022</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><section class="doc-section level-1"><h2 id=_введение><a class=link href=#_введение>Введение</a></h2><p>Почти 30 лет назад в классической книге по шаблонам проектирования Design Patterns: Elements of Reusable Object-Oriented Software, авторы сформулировали один из самых известных, но недопонятых принципов в истории программирования:</p><div class=quote-block><blockquote><p>Program to an interface, not an implementation.</p><footer>— <cite>Erich Gamma et. al, Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></div><p>Зачем "программировать в интерфейсы"? Для того чтобы реализацию этого интерфейса можно было менять без изменений клиентского кода.</p><p>Далее авторы объясняют как следовать этому совету:</p><div class=quote-block><blockquote><p>Don’t declare variables to be instances of particular concrete classes. Instead, commit only to an interface defined by an abstract class.</p><footer>— <cite>Erich Gamma et. al, Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></div><p>Многие воспринимают это буквально и просто вносят в программу дополнительную сущность (интерфейс или абстрактный класс), которая дублирует список и сигнатуры методов одного конкретного класса.</p><p>Проблема в том, что использование ключевого слова abstract или interface само по себе не создаёт абстракцию и не защищает клиента от изменения реализации.
Зато эти "заголовочные интерфейсы" по капельке, но каждый день подъедают человеческие, машинные и временные ресурсы.</p><p>Поэтому в <a href=https://azhidkov.pro/posts/22/04/220409-ergo-approach-v10m1/#_эргономичный_подход_v1_0m1>Эргономичном подходе</a> я отказался от повсеместного использования интерфейсов и применения принципа инверсии зависимостей по умолчанию.</p><p>Давайте рассмотрим на примере вымышленной истории, почему использование ключевого слова interface не является ни достаточным, ни необходимым для защиты клиентского кода от смены реализации интерфейса.</p><p>А потом увидим, насколько легко превратить конкретный класс в интерфейс и добавить новую реализацию, если он описывает абстракцию.</p><p>Наконец, рассмотрим несколько эвристик, которые помогают создавать классы описывающие абстракции, а не реализации.</p></section><section class="doc-section level-1"><h2 id=_эпизод_первый_скрытая_угроза_интерфейсы><a class=link href=#_эпизод_первый_скрытая_угроза_интерфейсы>Эпизод первый: Скрытая угроза. Интерфейсы.</a></h2><p>Представим, что некий молодой архитектор Артемий начинает новый проект.
Так как бизнес требует от него минимизировать "time to market", он решает, что собрать на коленке прототип будет быстрее всего на базе Spring Data JPA.
Но он будет "программировать в интерфейсы", чтобы быстро всё переписать на более поддерживаемую технологию, если проект стрельнет.</p><p>Артемий пишет примерно такой код:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=k>package</span> <span class=nn>pro.azhidkov.programtointerfaces.v1</span>

<span class=k>import</span> <span class=nn>org.springframework.data.repository.CrudRepository</span>
<span class=k>import</span> <span class=nn>javax.persistence.Entity</span>
<span class=c1>// ...</span>

<span class=nd>@Entity</span>
<span class=kd>class</span> <span class=nc>User</span><span class=p>(</span>
    <span class=nd>@Id</span> <span class=kd>var</span> <span class=py>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>login</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>password</span><span class=p>:</span> <span class=nc>String</span>
<span class=p>)</span>

<span class=nd>@Repository</span>
<span class=kd>interface</span> <span class=nc>UsersRepo</span> <span class=p>:</span> <span class=nc>CrudRepository</span><span class=p>&lt;</span><span class=nc>User</span><span class=p>,</span> <span class=nc>Long</span><span class=p>&gt;</span>

<span class=nd>@Service</span>
<span class=kd>class</span> <span class=nc>UsersService</span><span class=p>(</span> <span class=c1>// тут по идее тоже должен быть интерфейс, но сократим его ради экономии места</span>
    <span class=k>private</span> <span class=kd>val</span> <span class=py>usersRepo</span><span class=p>:</span> <span class=nc>UsersRepo</span>
<span class=p>)</span> <span class=p>{</span>

    <span class=nd>@Transactional</span>
    <span class=k>fun</span> <span class=nf>updatePassword</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span> <span class=n>newPass</span><span class=p>:</span> <span class=nc>String</span><span class=p>)</span> <span class=p>{</span>
        <span class=kd>val</span> <span class=py>user</span> <span class=p>=</span> <span class=n>usersRepo</span><span class=p>.</span><span class=nf>findByIdOrNull</span><span class=p>(</span><span class=n>id</span><span class=p>)</span>
        <span class=n>user</span><span class=p>.</span><span class=n>password</span> <span class=p>=</span> <span class=n>newPass</span>
    <span class=p>}</span>

<span class=p>}</span></code></pre></div><p>Казалось бы, всё восхитительно - мы не завязываемся ни на какие детали реализации и в любой момент сможем сменить технологию работы с БД, да и сам тип БД.</p><p>И когда приложение перерастает штанишки прототипа, Артемий, решив перейти на Spring Data JDBC, просто меняет зависимость в скрипте сборки, делает замену по проекту "@Entity" на "@Table@" и…​ О чудо! Всё собирается!</p><p>Однако, после поспешного релиза в прод выясняется, что ничего не работает.
Точнее в режиме чтения приложение работает, а вот никакие модификации не сохраняются.
После судорожного отката релиза и суток дебага, Артемий в документации к Spring Data JDBC выясняет, что она не реализует такую "небольшую деталь" как Dirty Checking и автомагически ничего не сохраняет.
Тогда Артемий везде добавляет *Repo.save() и всё, кризис преодолён.</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=k>package</span> <span class=nn>pro.azhidkov.programtointerfaces.v2</span>

<span class=k>import</span> <span class=nn>org.springframework.data.relational.core.mapping.Table</span>
<span class=k>import</span> <span class=nn>org.springframework.data.repository.CrudRepository</span>
<span class=c1>// ...</span>


<span class=nd>@Table</span>
<span class=kd>class</span> <span class=nc>User</span><span class=p>(</span>
    <span class=kd>var</span> <span class=py>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>login</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>password</span><span class=p>:</span> <span class=nc>String</span>
<span class=p>)</span>

<span class=nd>@Repository</span>
<span class=kd>interface</span> <span class=nc>UsersRepo</span> <span class=p>:</span> <span class=nc>CrudRepository</span><span class=p>&lt;</span><span class=nc>User</span><span class=p>,</span> <span class=nc>Long</span><span class=p>&gt;</span>

<span class=nd>@Service</span>
<span class=kd>class</span> <span class=nc>UsersService</span><span class=p>(</span>
    <span class=k>private</span> <span class=kd>val</span> <span class=py>usersRepo</span><span class=p>:</span> <span class=nc>UsersRepo</span>
<span class=p>)</span> <span class=p>{</span>

    <span class=nd>@Transactional</span>
    <span class=k>fun</span> <span class=nf>updatePassword</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span> <span class=n>newPass</span><span class=p>:</span> <span class=nc>String</span><span class=p>)</span> <span class=p>{</span>
        <span class=kd>val</span> <span class=py>user</span> <span class=p>=</span> <span class=n>usersRepo</span><span class=p>.</span><span class=nf>findByIdOrNull</span><span class=p>(</span><span class=n>id</span><span class=p>)</span>
        <span class=n>user</span><span class=p>.</span><span class=n>password</span> <span class=p>=</span> <span class=n>newPass</span>
        <span class=n>usersRepo</span><span class=p>.</span><span class=nf>save</span><span class=p>(</span><span class=n>user</span><span class=p>)</span>
    <span class=p>}</span>

<span class=p>}</span></code></pre></div><p>Правда эта правка превратит код Артемия в <a href=https://vladmihalcea.com/best-spring-data-jparepository/>анти-паттерн с точки зрения JPA</a>🤦.</p><p>Так на своём горьком опыте Артемий узнал, что одно только использование интерфейсов не гарантирует изменение реализации, без изменения клиентов.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>На самом деле в этой истории есть пара нестыковок, но они лишь подтверждают основной тезис поста.</p><p>Артемий вряд ли смог бы скомпилировать и запустить проект, просто заменив аннотации.
Наверняка ему пришлось бы нарезать модель на <a href=https://azhidkov.pro/posts/22/04/220401-aggregates/>агрегаты</a> и что-то сделать с двунаправленными связями.</p><p>Это обусловлено второй нестыковкой - пруф сейчас найти не могу, но уверен, что где-то читал, как сами пацаны из Spring Data писали, что интерфейсы репозиториев не являются абстракциями.</p></aside><p>Когда проект ещё подрос, и возникла потребность в реактивном подходе, Артемий уже понимал, что переход на Spring Data R2DBC будет долгим и тяжёлым.
Осознав, насколько кодовая база заточена на синхронную работу, вместо миграции проекта на Spring Data R2DBC, Артемий решил сам мигрировать на новый проект.</p></section><section class="doc-section level-1"><h2 id=_эпизод_второй_пробуждение_силы_абстракции><a class=link href=#_эпизод_второй_пробуждение_силы_абстракции>Эпизод второй: Пробуждение силы. Абстракции.</a></h2><p>Наученный горьким опытом, Артемий понял, что "программирование в интерфейсы" само по себе ничего не даёт с точки зрения гибкости.
Зато интерфейсы занимают место на экране, диске и в голове Артемия.
А также увеличивают время компиляции проекта.
И усложняют навигацию по коду и его рефакторинг.</p><p>Поэтому в новом проекте Артемий решил программировать без лишних церемоний, зато с учётом всего своего опыта.
На этот раз Артемий отложил выбор технологии для работы с БД и начал с тривиальных suspend-репозиториев неизменяемых сущностей на базе ассоциативных массивов:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=k>package</span> <span class=nn>pro.azhidkov.programtointerfaces.v3</span>

<span class=k>import</span> <span class=nn>org.springframework.stereotype.Repository</span>
<span class=k>import</span> <span class=nn>org.springframework.stereotype.Service</span>
<span class=k>import</span> <span class=nn>org.springframework.transaction.annotation.Transactional</span>


<span class=kd>class</span> <span class=nc>User</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>login</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>password</span><span class=p>:</span> <span class=nc>String</span>
<span class=p>)</span>

<span class=nd>@Repository</span>
<span class=kd>class</span> <span class=nc>UsersRepo</span> <span class=p>{</span>

    <span class=k>private</span> <span class=kd>val</span> <span class=py>data</span> <span class=p>=</span> <span class=nc>HashMap</span><span class=p>&lt;</span><span class=nc>Long</span><span class=p>,</span> <span class=nc>User</span><span class=p>&gt;()</span>

    <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>findByIdOrNull</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>):</span> <span class=nc>User</span><span class=p>?</span> <span class=p>=</span> <span class=n>data</span><span class=p>[</span><span class=n>id</span><span class=p>]</span>

    <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>save</span><span class=p>(</span><span class=n>user</span><span class=p>:</span> <span class=nc>User</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>data</span><span class=p>[</span><span class=n>user</span><span class=p>.</span><span class=n>id</span><span class=p>]</span> <span class=p>=</span> <span class=n>user</span>
    <span class=p>}</span>

<span class=p>}</span>

<span class=nd>@Service</span>
<span class=kd>class</span> <span class=nc>UsersService</span><span class=p>(</span>
    <span class=k>private</span> <span class=kd>val</span> <span class=py>usersRepo</span><span class=p>:</span> <span class=nc>UsersRepo</span>
<span class=p>)</span> <span class=p>{</span>

    <span class=nd>@Transactional</span>
    <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>updatePassword</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span> <span class=n>newPass</span><span class=p>:</span> <span class=nc>String</span><span class=p>)</span> <span class=p>{</span>
        <span class=kd>val</span> <span class=py>user</span> <span class=p>=</span> <span class=n>usersRepo</span><span class=p>.</span><span class=nf>findByIdOrNull</span><span class=p>(</span><span class=n>id</span><span class=p>)</span>
        <span class=kd>val</span> <span class=py>updatedUser</span> <span class=p>=</span> <span class=n>user</span><span class=p>.</span><span class=nf>copy</span><span class=p>(</span><span class=n>password</span> <span class=p>=</span> <span class=n>newPass</span><span class=p>)</span>
        <span class=n>usersRepo</span><span class=p>.</span><span class=nf>save</span><span class=p>(</span><span class=n>updatedUser</span><span class=p>)</span>
    <span class=p>}</span>

<span class=p>}</span></code></pre></div><p>Начав работать в таком стиле, Артемий каждый день радовался как ребёнок тому, что теперь не приходится постоянно возиться с чёртовыми прицепами в виде интерфейсов.</p><p>Однако, когда пришёл день Д - день выбора технологии работы с БД - Артемий по старой памяти напрягся.
У нового проекта не ожидалось большого количества пользователей, поэтому Артемий снова решил использовать Spring Data JDBC.
Кроме того, имеющиеся in-memory репозитории решили сохранить для использования в демо-версии продукта.</p><p>"Вот бы у нас сервисы зависели от интерфейсов репозиториев, чтобы мы могли во время исполнения выбирать реализацию" - злорадно говорили адепты карго культа "program to interface" из команды Артемия.</p><p>Однако, Артемий хорошо владел своими инструментами и знал, что класс, описывающий хорошую абстракцию, с помощью рефакторинга extract interface превращается в тот самый интерфейс лёгким движением руки.</p><p>Правда для Kotlin, в отличие от Java, у этого рефакторинга ещё нет галки "use interface where possible"🤦‍♂️.
Но всё равно можно вытащить интерфейс, а потом без рефакторинга просто поменять местами имена интерфейса и класса:</p><div class="olist arabic"><ol class=arabic><li>С помощью рефакторинга из класса UsersRepo вытащить интерфейс IUsersRepo</li><li>Без рефакторинга в файле IUsersRepo.kt заменить текст "IUsersRepo" на "UsersRepo"</li><li>Без рефакторинга в файле UsersRepo.kt заменить текст "UsersRepo" на "InMemUsersRepo"</li><li>Без рефакторинга переименовать файл UsersRepo.kt в InMemUsersRepo.kt</li><li>Без рефакторинга переименовать файл IUsersRepo.kt в UsersRepo.kt</li></ol></div><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Тут опытный читатель может сказать "А если я программирую библиотеку или фреймворк и не могу зарефакторить код 100500 неизвестных клиентов?".
На что я ему отвечу: "Вот тогда вам нужны интерфейсы сразу".
Но это должны быть тщательно спроектированные интерфейсы, а клиенты этих интерфейсов должны изо всех сил стараться не завязываться на реализацию по умолчанию.</p></aside><p>Следующая проблема.
Артемий перестраховался и везде добавил suspend, который стал лишним, т.к. Spring Data JDBC работает в блокирующем режиме.
Хорошо, что ломать не строить.
Можно воспользоваться структурной заменой для того, чтобы найти и удалить все модификаторы suspend у методов классов заканчивающихся на "Repo":</p><div class=image-block><img src=/posts/22/07/images/abstraction-wars-5ea24.png alt="abstraction wars 5ea24"></div><p>Потом то же самое надо проделать для интерфейсов.
Поэтому лучше загодя подумать об этом и сначала убрать suspend, а потом выделить интерфейс.
В итоге у Артемия получился такой код:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=k>package</span> <span class=nn>pro.azhidkov.programtointerfaces.v4</span>

<span class=k>import</span> <span class=nn>org.springframework.stereotype.Repository</span>
<span class=k>import</span> <span class=nn>org.springframework.stereotype.Service</span>
<span class=k>import</span> <span class=nn>org.springframework.transaction.annotation.Transactional</span>


<span class=kd>class</span> <span class=nc>User</span><span class=p>(</span>
    <span class=kd>var</span> <span class=py>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>login</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>password</span><span class=p>:</span> <span class=nc>String</span>
<span class=p>)</span>

<span class=kd>interface</span> <span class=nc>UsersRepo</span> <span class=p>{</span>
    <span class=k>fun</span> <span class=nf>findByIdOrNull</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>):</span> <span class=nc>User</span><span class=p>?</span>

    <span class=k>fun</span> <span class=nf>save</span><span class=p>(</span><span class=n>user</span><span class=p>:</span> <span class=nc>User</span><span class=p>)</span>
<span class=p>}</span>

<span class=nd>@Repository</span>
<span class=kd>class</span> <span class=nc>InMemUsersRepo</span> <span class=p>:</span> <span class=nc>UsersRepo</span> <span class=p>{</span>

    <span class=k>private</span> <span class=kd>val</span> <span class=py>data</span> <span class=p>=</span> <span class=nc>HashMap</span><span class=p>&lt;</span><span class=nc>Long</span><span class=p>,</span> <span class=nc>User</span><span class=p>&gt;()</span>

    <span class=k>override</span> <span class=k>fun</span> <span class=nf>findByIdOrNull</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>):</span> <span class=nc>User</span><span class=p>?</span> <span class=p>=</span> <span class=n>data</span><span class=p>[</span><span class=n>id</span><span class=p>]</span>

    <span class=k>override</span> <span class=k>fun</span> <span class=nf>save</span><span class=p>(</span><span class=n>user</span><span class=p>:</span> <span class=nc>User</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>data</span><span class=p>[</span><span class=n>user</span><span class=p>.</span><span class=n>id</span><span class=p>]</span> <span class=p>=</span> <span class=n>user</span>
    <span class=p>}</span>

<span class=p>}</span>

<span class=nd>@Service</span>
<span class=kd>class</span> <span class=nc>UsersService</span><span class=p>(</span>
    <span class=k>private</span> <span class=kd>val</span> <span class=py>usersRepo</span><span class=p>:</span> <span class=nc>UsersRepo</span>
<span class=p>)</span> <span class=p>{</span>

    <span class=nd>@Transactional</span>
    <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>updatePassword</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span> <span class=n>newPass</span><span class=p>:</span> <span class=nc>String</span><span class=p>)</span> <span class=p>{</span>
        <span class=kd>val</span> <span class=py>user</span> <span class=p>=</span> <span class=n>usersRepo</span><span class=p>.</span><span class=nf>findByIdOrNull</span><span class=p>(</span><span class=n>id</span><span class=p>)</span>
        <span class=kd>val</span> <span class=py>updatedUser</span> <span class=p>=</span> <span class=n>user</span><span class=p>.</span><span class=nf>copy</span><span class=p>(</span><span class=n>password</span> <span class=p>=</span> <span class=n>newPass</span><span class=p>)</span>
        <span class=n>usersRepo</span><span class=p>.</span><span class=nf>save</span><span class=p>(</span><span class=n>updatedUser</span><span class=p>)</span>
    <span class=p>}</span>

<span class=p>}</span></code></pre></div><p>Теперь Артемий может спокойно добавить "реализации" с помощью Spring Data JDBC и у него всё будет работать.</p><p>На этом история Артемия благополучно заканчивается.
А нам ещё надо сделать орг. выводы.</p></section><section class="doc-section level-1"><h2 id=_эпизод_третий_последние_джедаи_эргономичный_подход_к_абстракции><a class=link href=#_эпизод_третий_последние_джедаи_эргономичный_подход_к_абстракции>Эпизод третий: Последние джедаи. Эргономичный подход к абстракции.</a></h2><p>Именно потому что сами по себе интерфейсы ничего не гарантируют, а тщательно спроектированные классы превращаются в интерфейсы одним движением руки, в Эргономичном подходе я отказался от повсеместной инверсии зависимостей и внедрения интерфейсов.</p><p>Вместо этого я слежу за утечками абстракций в интерфейсах классов (имени класса и сигнатурах методов) и применяю функциональную архитектуру.</p><p>Отслеживания требуют два основных вида утечек - явные и неявные.</p><section class="doc-section level-2"><h3 id=_явные_утечки><a class=link href=#_явные_утечки>Явные утечки</a></h3><p>Явные утечки в свою очередь тоже бывают двух типов - в именовании и типах параметров.</p><p>Для того чтобы класс описывал абстракцию, внезапно надо, чтобы имена самого класса, методов и параметров были максимально абстрактными.
Например, в <a href=https://azhidkov.pro/posts/22/06/220611-true-story-project/>True Story Project</a> за отправку фида в 2Гис по Email у меня отвечает такой класс:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=kd>class</span> <span class=nc>DGisFeedSender</span> <span class=p>{</span>

    <span class=c1>// Поля и конструктор</span>

    <span class=k>public</span> <span class=n>void</span> <span class=nf>sendFeedTo2Gis</span><span class=p>(</span><span class=nc>String</span> <span class=n>recipient</span><span class=p>,</span> <span class=nc>String</span> <span class=n>subject</span><span class=p>,</span> <span class=nc>InputStreamSource</span> <span class=n>inputStreamSource</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// ..</span>
    <span class=p>}</span>

<span class=p>}</span></code></pre></div><p>Как видно, в этом коде никак не упоминается Email, и я могу переделать его на отправку в телеграм, например, не трогая интерфейс или его клиентов.
Или лёгким движением руки (и т.к. в этом проекте у меня Java - это будет действительное лёгкое движение) выделить интерфейс и сделать механизм отправки конфигурируемым.</p><p>Бывают ситуации, когда я предвижу смену или появление новой реализации и сразу завожу интерфейс.
Например, я бы так поступил на месте Артемия во втором проекте.</p><p>В этом случае повысить качество абстракции мне помогает другое правило - я не пользуюсь префиксами/суффиксами I/Impl/Abstract/Default и им подобным.
Интерфейсы я называю абстрактно, а в классы реализации добавляю что-то (прилагательное, название технологии и т.п.), характеризующее суть реализации.
Так в примере Артемия у меня был бы интерфейс UsersRepo, который реализуется (в кавычках для Spring Data) интерфейсом SpringDataUsersRepo и классом InMemUsersRepo.</p><p>И если у меня появляются проблемы с выбором имени класса или интерфейса - для меня это красный флаг, указывающий на проблемы в дизайне.</p><p>Что касается типов - я слежу за тем, чтобы через параметры и результаты методов не утекали типы, использованные в реализации.
Например, в <a href=/posts/21/03/210321-project-l-testing/>Проекте Л</a> мне среди прочего надо было реализовать "подглядывающие" проксирование HTTP-запросов.
Метод проксирования у меня очевидным образом получал HTTP-запрос и возвращал HTTP-ответ.
И хотя я мог взять эти классы из библиотеки реализации (ktor) я их обернул в собственные типы:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=kd>data class</span> <span class=nc>HttpRequest</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>method</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>path</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>query</span><span class=p>:</span> <span class=nc>Map</span><span class=p>&lt;</span><span class=nc>String</span><span class=p>,</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>String</span><span class=p>&gt;&gt;,</span>
    <span class=kd>val</span> <span class=py>headers</span><span class=p>:</span> <span class=nc>Map</span><span class=p>&lt;</span><span class=nc>String</span><span class=p>,</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>String</span><span class=p>&gt;&gt;,</span>
    <span class=kd>val</span> <span class=py>body</span><span class=p>:</span> <span class=nc>String</span><span class=p>?</span>
<span class=p>)</span>

<span class=kd>data class</span> <span class=nc>HttpResponse</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>status</span><span class=p>:</span> <span class=nc>Int</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>headers</span><span class=p>:</span> <span class=nc>Map</span><span class=p>&lt;</span><span class=nc>String</span><span class=p>,</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>String</span><span class=p>&gt;&gt;,</span>
    <span class=kd>val</span> <span class=py>bodyBytes</span><span class=p>:</span> <span class=nc>ByteArray</span>
<span class=p>)</span>

<span class=k>suspend</span> <span class=k>fun</span> <span class=nc>ApiClient</span><span class=p>.</span><span class=nf>proxy</span><span class=p>(</span><span class=n>token</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span> <span class=n>request</span><span class=p>:</span> <span class=nc>HttpRequest</span><span class=p>):</span> <span class=nc>HttpResponse</span> <span class=p>{</span>
    <span class=c1>// ...</span>
<span class=p>}</span></code></pre></div><p>При разборе одной из ошибок, это позволило мне быстро попробовать подменить реализацию на Spring WebClient, чтобы попытаться её обойти (в итоге остался на ktor).
Если бы я завёл для класса заголовочный интерфейс, но вытащил туда типы из ktor-а - этот фокус у меня не удался.
Поэтому между генераций "лишних" интерфейсов и "лишних" типов я голосую за вторые.</p><p>Тут важно не перегнуть палку.
Например, Spring Data даёт много чудесной автомагии, если использовать класс Pageable.
Если же вместо него использовать собственный класс, то придётся написать гору ручного кода для реализации пагинации.
А миграцию своих проектов со Spring на что-то другое я считаю практически невероятной, поэтому использую Pageable в интерфейсах классов без зазрения совести.</p></section><section class="doc-section level-2"><h3 id=_неявные_утечки><a class=link href=#_неявные_утечки>Неявные утечки</a></h3><p>По моему опыту, наиболее проблемные неявные утечки связаны с одним предположением, проявляющемся в двух аспектах.
Само предположение - "сервер" (реализация зависимости) находится в одном адресном пространстве/процессе с "клиентом".</p><p>С одним из аспектов этого предположения - достаточностью простого присвоения нового значения полю изменяемого объекта в клиенте для того, чтобы оно изменилось на сервере - мы уже столкнулись в истории Артемия.
Ровно ту же проблему Артемий бы получил, если бы по каким-то причинам решил заменить реализацию репозиториев на работу через REST API, например.</p><p>С этим аспектом отлично борются неизменяемые структуры данных, которые вообще несут много светлого и доброго в дизайн.
Поэтому я сам повсеместно и по умолчанию использую неизменяемые структуры данных, требую этого от своей команды и всячески продвигаю их в интернете.</p><p>Ко второму аспекту Артемий тоже подошёл, но решил его избежать.
Суть этого аспекта, заключается в полагании на простоту внутрипроцессного взаимодействия.
Внутрипроцессное взаимодействие является моментальным (на фоне межпроцессного) и сам вызов наверняка дойдёт до адресата, а ответ наверняка вернётся.
Если же адресат окажется в другом процессе (или того хуже на другой машине), то у нас тут же возникают все проблемы, свойственные распределённому программированию, которые никак не отражаются в упрощённом интерфейсе.</p><p>Для того чтобы обеспечить себе возможность безболезненного перехода с внутрипроцессного на межпроцессное взаимодействие, интерфейс надо существенно усложнить.
Как минимум стоит рассмотреть вариант suspend/reactive интерфейса.
В зависимости от контекста может быть смысл вытащить в интерфейс и потенциальные инфраструктурные ошибки.</p><p>Это всё довольно сильно усложняет код, поэтому к абстрагированию от местонахождения зависимости я прибегаю только в том случае, если считаю вероятность отъезда зависимости в другой процесс "достаточно высокой".</p><p>Вообще, самое лучшее практическое руководство по созданию нетекущих абстракций, которое я читал, содержится в книге <a href=https://www.amazon.com/Practical-API-Design-Confessions-Framework/dp/1430209739>Practical API Design: Confessions of a Java Framework Architect</a>.
Это 400 страниц квинтэссенции боли и страданий от последствий ошибок, допущенных её автором (главным архитектором NetBeans) при проектировании "ядерных" абстракций IDE.</p></section><section class="doc-section level-2"><h3 id=_функциональная_архитектура><a class=link href=#_функциональная_архитектура>Функциональная архитектура</a></h3><p>Проектирование хороших абстракций решает проблему гибкости системы, однако остаётся проблема статической привязки домена к инфраструктуре.
Для решения этой проблемы Эргономичный подход полагается на <a href="https://www.youtube.com/watch?v=yTkzNHF6rMs">функциональную архитектуру</a> - выделение домена в чистое ядро, которое на <strong>самом деле</strong> не зависит ни от чего ни во время компиляции, ни во время исполнения.</p><p>В качестве иллюстрации возьму пример из <a href=/posts/22/04/220401-aggregates/#_анемичная_доменная_модель>проекта хранения информации о торговле на бирже крипто-валют</a>.</p><p>Там был такой пример плохой реализации (немного подправил под контекст этого поста):</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=k>fun</span> <span class=nf>updateCustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span> <span class=n>activeSymbols</span><span class=p>:</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>ActiveSymbol</span><span class=p>&gt;)</span> <span class=p>{</span>
    <span class=kd>val</span> <span class=py>customerSymbols</span> <span class=p>=</span> <span class=n>customerSymbolsRepo</span><span class=p>.</span><span class=nf>fetchCustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>)</span>

    <span class=c1>// Доменная логика суть которой не так важна в этом посте и описана в посте про агрегаты</span>
    <span class=n>activeSymbols</span><span class=p>.</span><span class=nf>map</span> <span class=p>{</span> <span class=n>activeSymbol</span> <span class=p>-&gt;</span>
        <span class=kd>val</span> <span class=py>trading</span> <span class=p>=</span> <span class=n>customerSymbols</span><span class=p>.</span><span class=n>tradings</span><span class=p>.</span><span class=nf>find</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>symbol</span> <span class=p>==</span> <span class=n>activeSymbol</span><span class=p>.</span><span class=n>symbol</span> <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>trading</span> <span class=p>!=</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>trading</span><span class=p>.</span><span class=n>activeGrid</span> <span class=p>=</span> <span class=n>trading</span><span class=p>.</span><span class=n>grids</span><span class=p>.</span><span class=nf>find</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>name</span> <span class=p>==</span> <span class=n>activeSymbol</span><span class=p>.</span><span class=n>gridName</span> <span class=p>}</span> <span class=o>?:</span> <span class=nc>Grid</span><span class=p>(</span><span class=n>activeSymbol</span><span class=p>.</span><span class=n>gridName</span><span class=p>,</span> <span class=nc>BigDecimal</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=kd>val</span> <span class=py>activeGrid</span> <span class=p>=</span> <span class=nc>Grid</span><span class=p>(</span><span class=n>activeSymbol</span><span class=p>.</span><span class=n>gridName</span><span class=p>,</span> <span class=nc>BigDecimal</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
            <span class=n>customerSymbols</span><span class=p>.</span><span class=n>tradings</span><span class=p>.</span><span class=nf>add</span><span class=p>(</span>
                <span class=nc>SymbolTrading</span><span class=p>(</span><span class=n>activeSymbol</span><span class=p>.</span><span class=n>symbol</span><span class=p>,</span> <span class=nf>mutableListOf</span><span class=p>(</span><span class=n>activeGrid</span><span class=p>),</span> <span class=n>activeGrid</span><span class=p>)</span>
            <span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=n>customerSymbolsRepo</span><span class=p>.</span><span class=nf>save</span><span class=p>(</span><span class=n>customerSymbols</span><span class=p>)</span>
<span class=p>}</span></code></pre></div><p>Даже если customerSymbolsRepo - интерфейс, доменная логика всё равно сильно сцеплена с вводом-выводом и её сложно переиспользовать в другом контексте.
Примером "другого контекста", который всегда актуален для доменной логики, являются тесты.</p><p>И хотя интерфейс существенно упрощает тестирование бизнес-логики, за счёт того, что позволяет в тестах использовать фейковый репозиторий, мы можем намного лучше.</p><p>Если вынести логику в отдельные чистые функции:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=kd>data class</span> <span class=nc>SymbolTrading</span> <span class=k>private</span> <span class=k>constructor</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>symbol</span><span class=p>:</span> <span class=nc>Symbol</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>grids</span><span class=p>:</span> <span class=nc>Map</span><span class=p>&lt;</span><span class=nc>GridName</span><span class=p>,</span> <span class=nc>Grid</span><span class=p>&gt;,</span>
    <span class=kd>val</span> <span class=py>activeGrid</span><span class=p>:</span> <span class=nc>GridName</span>
<span class=p>)</span> <span class=p>{</span>

    <span class=k>fun</span> <span class=nf>activateGrid</span><span class=p>(</span><span class=n>gridName</span><span class=p>:</span> <span class=nc>String</span><span class=p>):</span> <span class=nc>SymbolTrading</span> <span class=p>=</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>gridName</span> <span class=k>in</span> <span class=n>grids</span><span class=p>)</span> <span class=nc>SymbolTrading</span><span class=p>(</span><span class=n>symbol</span><span class=p>,</span> <span class=n>grids</span><span class=p>,</span> <span class=n>gridName</span><span class=p>)</span>
        <span class=k>else</span> <span class=nc>SymbolTrading</span><span class=p>(</span><span class=n>symbol</span><span class=p>,</span> <span class=n>grids</span> <span class=p>+</span> <span class=p>(</span><span class=n>gridName</span> <span class=n>to</span> <span class=nc>Grid</span><span class=p>(</span><span class=n>gridName</span><span class=p>)),</span> <span class=n>gridName</span><span class=p>)</span>

<span class=p>}</span>

<span class=kd>data class</span> <span class=nc>CustomerSymbols</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>customerId</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>tradings</span><span class=p>:</span> <span class=nc>Map</span><span class=p>&lt;</span><span class=nc>Symbol</span><span class=p>,</span> <span class=nc>SymbolTrading</span><span class=p>&gt;</span>
<span class=p>)</span> <span class=p>{</span>

    <span class=k>fun</span> <span class=nf>activateSymbols</span><span class=p>(</span><span class=n>activeSymbols</span><span class=p>:</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>ActiveSymbol</span><span class=p>&gt;):</span> <span class=nc>CustomerSymbols</span> <span class=p>{</span>
        <span class=kd>val</span> <span class=py>updatedTradings</span> <span class=p>=</span> <span class=n>activeSymbols</span><span class=p>.</span><span class=nf>map</span> <span class=p>{</span>
            <span class=n>tradings</span><span class=p>[</span><span class=n>it</span><span class=p>.</span><span class=n>symbol</span><span class=p>]</span><span class=o>?.</span><span class=nf>activateGrid</span><span class=p>(</span><span class=n>it</span><span class=p>.</span><span class=n>gridName</span><span class=p>)</span>
                <span class=o>?:</span> <span class=nc>SymbolTrading</span><span class=p>.</span><span class=nf>new</span><span class=p>(</span><span class=n>it</span><span class=p>.</span><span class=n>symbol</span><span class=p>,</span> <span class=n>it</span><span class=p>.</span><span class=n>gridName</span><span class=p>)</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=nc>CustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>,</span> <span class=n>tradings</span> <span class=p>+</span> <span class=n>updatedTradings</span><span class=p>.</span><span class=nf>associateBy</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>symbol</span> <span class=p>})</span>
    <span class=p>}</span>

<span class=p>}</span>

<span class=k>fun</span> <span class=nf>updateCustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span> <span class=n>activeSymbols</span><span class=p>:</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>ActiveSymbol</span><span class=p>&gt;)</span> <span class=p>{</span>
    <span class=kd>val</span> <span class=py>customerSymbols</span> <span class=p>=</span> <span class=n>customerSymbolsRepo</span><span class=p>.</span><span class=nf>fetchCustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>)</span>
    <span class=kd>val</span> <span class=py>updatedCustomerSymbols</span> <span class=p>=</span> <span class=n>customerSymbols</span><span class=p>.</span><span class=nf>activateSymbols</span><span class=p>(</span><span class=n>activeSymbols</span><span class=p>)</span>
    <span class=n>customerSymbolsRepo</span><span class=p>.</span><span class=nf>save</span><span class=p>(</span><span class=n>updatedCustomerSymbols</span><span class=p>)</span>
<span class=p>}</span></code></pre></div><p>то тестирование бизнес-логики становится просто вызовом функции и проверкой результата.
А изолированно тестировать оркестрацию (метод updateCustomerSymbols) особого смысла нет - ошибки в нём могут быть только на границах модулей, он будет исчерпывающе протестирован любым сценарным тестом, а любой юнит-тест с моками будет тавтологией.</p><p>Функциональная архитектура помогает расцепить только бизнес-логику и инфраструктуру, и если не предпринимать дополнительных усилий, то слой приложения останется сцепленным с инфраструктурой.
Однако, я считаю, очень часто этого вполне достаточно.
А решение расцепить слой приложения и инфраструктуру должно быть обоснованным требованиями конкретного приложения, а не способом реализации по умолчанию.</p></section></section><section class="doc-section level-1"><h2 id=_заключение><a class=link href=#_заключение>Заключение</a></h2><p>"Program to interface" - хороший совет, за которым скрывается огромный опыт банды четырёх.
Однако, если интерпретировать его буквально, то следование ему повысит сложность и стоимость поддержки кодовой базы, ничего не дав взамен.
Кроме того, этот совет наиболее актуален при разработке библиотек, фреймворков и платформ с динамической загрузкой кода (плагинами).</p><p>При разработке же прикладных программ, намного более простой и поддерживаемый код дают усилия по минимизации протечек абстракций и применение функциональной архитектуры.</p></section><section class="doc-section level-1"><h2 id=_ссылки_по_теме><a class=link href=#_ссылки_по_теме>Ссылки по теме</a></h2><div class=ulist><ul><li><a href=https://blog.ttulka.com/too-many-interfaces>Too Many Interfaces</a></li><li><a href=https://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/>Interfaces are not abstractions</a></li><li><a href=https://ardalis.com/what-are-abstractions-in-software-development/>What are Abstractions in Software Development</a></li></ul></div></section></article><br></section></div></main><script src=/js/app.js></script></body></html>