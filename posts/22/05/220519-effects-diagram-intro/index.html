<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Диаграмма Эффектов: Спецификация v0.0.2 - Алексей Жидков"><meta property="og:description" content="Душой информационной системы являются её эффекты. Именно на основании эффектов конечные пользователи выносят суждения о корректности работы системы. И при столь большой важности эффектов, в мире не существовало инструмента для их визуализации и проектирования. Поэтому я придумал свой - диаграмму эффектов."><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/22/05/220519-effects-diagram-intro/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/22/05/220519-effects-diagram-intro/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/22/05/220519-effects-diagram-intro/><title>Диаграмма Эффектов: Спецификация v0.0.2 - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/22/05/220519-effects-diagram-intro/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Диаграмма Эффектов: Спецификация v0.0.2</h1><h2 class=date>May 19, 2022</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Этот пост является первой попыткой описать диаграмму формально, поэтому в описании возможны неточности и пробелы, а детали и нотация наверняка изменятся в будущем.</p></aside><p>Это первый пост в серии, посвящённый диаграмме эффектов:</p><div class="olist arabic"><ol class=arabic><li>"Спецификация": назначение диаграммы, основные концептуальные элементы и их визуальное представление</li><li><a href=https://azhidkov.pro/posts/22/06/220611-true-story-project/>"Пример построения диаграммы, проект True Story Project (TSP)"</a> - процесс построения диаграммы эффектов реального проекта</li><li>"Методика объектно-ориентированной декомпозиции" - рациональный подход к разбиению системы на модули с помощью диаграммы эффектов и его применение для декомпозиции проекта TSP</li><li>"Методика перевода диаграммы в код" - процесс трансляции диаграммы в исходный код на примере проекта TSP</li></ol></div><section class="doc-section level-1"><h2 id=_введение><a class=link href=#_введение>Введение</a></h2><p>Идентичность информационной системы определяется тем, как она взаимодействует с внешним миром.
Что, где и когда она сохраняет и запрашивает; что, куда и когда отправляет.
Это я называю наблюдаемым поведением.</p><p>Можно переписать приложение с Java на Haskell, сменить слоёную архитектуру на шестиугольную, реляционную базу данных заменить документной, а пользовательский интерфейс перевести с серверной генерации HTML на React Native - если наблюдаемое поведение системы останется неизменным, то это будет просто очередная версия всё той же системы.
Если же кардинально изменить её взаимодействие с внешним миром, то это будет уже другая система.</p><p>Именно на основании наблюдаемого поведения конечные пользователи выносят суждения о корректности работы программы.
Даже для того, чтобы оценить корректность результата сложного вычисления, пользователю в первую очередь надо, чтобы правильно сработал механизм отображения этого результата.</p><p>При всей значимости наблюдаемого поведения я не знаю ни одного общепринятого инструмента для его проектирования и визуализации.
Поэтому изобрёл свой - диаграмму эффектов.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>При чём здесь эффекты?
При том, что наблюдаемое поведение состоит из эффектов.
И так короче.</p></aside></section><section class="doc-section level-1"><h2 id=_концептуальная_модель><a class=link href=#_концептуальная_модель>Концептуальная модель</a></h2><p>В основе концептуальной модели диаграммы поведения лежат <strong>операции</strong> - атомарные единицы поведения системы.
Операции характеризуются в первую очередь своими <strong>эффектами</strong> - взаимодействием с окружающим миром.
Значимые элементы окружающего мира, с которыми могут взаимодействовать операции, представлены внутри системы <strong>ресурсами</strong>.
Наконец, выполнение операций инициируется <strong>событиями</strong>.
Рассмотрим эти элементы подробнее.</p><section class="doc-section level-2"><h3 id=_операция><a class=link href=#_операция>Операция</a></h3><p>Как правило, для реализации функции системы требуется несколько эффектов.
Как минимум что-то считать и потом записать обратно.
Группы эффектов, реализующих одну функцию системы, образуют операции системы.
Система может реагировать как несколькими операциями (выполнять несколько функций) в ответ на одно событие, так и одной операцией в ответ на несколько событий разных типов.</p></section><section class="doc-section level-2"><h3 id=_эффект><a class=link href=#_эффект>Эффект</a></h3><p>Если не вдаваться в философию программирования, то эффект - это ввод-вывод.
Включая запись и чтение глобальных переменных (кучи).</p><p>Очевидно, эффекты бывают двух видов - чтения и записи.
Первые изменяют состояние программы, вторые - состояние окружающего мира.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Впереди - моя личная и не до конца оформленная философия программирования.
Её можно смело пропустить, без ущерба для основной части поста.</p><p>Так вот если всё-таки немного углубиться в философию, то в программировании эффект - это всегда <strong>действие</strong> по изменению состояния какого-то транзистора.
В эффекте чтения состояние транзистора памяти внешнего устройства через несколько промежуточных этапов попадает в регистр процессора (который является группой транзисторов).</p><p>В эффекте записи, наоборот, состояние регистра процессора переносится в транзистор внешнего устройства.
На этом эффект может быть завершён, в случае жёсткого диска, либо это состояние может быть "аналогизировано" - превращено в физический процесс (например, световую волну или движение ноги робота).
Так эффект работы программы становится наблюдаемым поведением.</p><p>Вообще "неэффектов" не существует - любое действие в программе выражается в изменении состояния транзисторов.
В <a href=https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0>фон Нейманавской архитектуре</a>, по крайней мере.</p><p>При этом существует функциональная парадигма программирования, которая характеризуется акцентом на функциях без эффектов.
Но в современном компьютере даже идеально чистая вызывающая функция записывает данные в память, выделенную для стэка, и ожидает, что идеально чистая вызываемая функция их считает, а потом запишет свой результат.</p><p>Я ни разу не встречал формального определения того, что считается эффектом, а что "неэффектом".
Но, по-видимому, общепринятое мнение таково, что изменение регистра процессора и стэка программы эффектами не считается, а любые изменения начиная с кучи программы и далее - считаются.
То есть разница между эффектом и "неэффектом" в области видимости.
Или, другими словами, в количестве наблюдателей поведения.</p><p>Высокоуровневый эффект может проходить через несколько этапов переноса, посредством чтения и записи.
Например, эффект "Отправить пуш уведомление" пройдёт такой путь: сначала информация переносится через кэши из процессора в память программы, потом в память ОС, потом в память сетевой карты, потом через память нескольких роутеров и серверов в память сетевой карты другого компьютера (смартфона), там обратно в память программы, а оттуда, опять же через несколько слоёв, в память экрана, где состояние транзистора "аналогизиурется" в свечение пикселя.
И где-то попутно этот эффект заодно осядет на транзисторах диска БД пуш-сервиса.</p><p>Но возвращаемся на привычный уровень абстракции: эффект - это ввод-вывод плюс чтение-запись глобальных переменных.</p></aside></section><section class="doc-section level-2"><h3 id=_ресурс><a class=link href=#_ресурс>Ресурс</a></h3><p>У эффектов, которые являются действиями, есть объект - целевое состояние.
Это какая-то часть физического мира, с которой будет взаимодействовать устройство ввода-вывода в процессе реализации эффекта.
Чаще всего целевым состоянием выступают биты на носителях информации, но это могут быть и пиксели экрана, и динамик колонки и нога робота.
Эти кусочки физического мира представлены в системе ресурсами.</p></section><section class="doc-section level-2"><h3 id=_событие><a class=link href=#_событие>Событие</a></h3><p>Наконец, программы (особенно интерактивные) редко выполняют эффекты сплошным потоком - обычно программа выполняет набор эффектов в ответ на какое-то событие и засыпает до следующего события.
Таким событием может быть получение вызова удалённой процедуры в любом виде, появление нового сообщения в некоторой очереди, наступление определённого момента времени или истечение определённого периода времени.</p><hr><p>Чёткое понимание операций системы (когда они выполняются и к каким эффектам приводят) является критически важным на всех этапах жизненного цикла разработки системы.</p><p>На этапе оценки это помогает понять что необходимо сделать (список операций) и насколько сложно это сделать (список событий, требуемых эффектов и целевых ресурсов).</p><p>На этапе проектирования операции и ресурсы становятся ключевыми блоками, правильная декомпозиция которых создаст основу для системы с низкой сцепленностью.</p><p>На этапе реализации сложность операций (определяемая количеством и типом обеспечивающих её ресурсов) и их зависимость через ресурсы помогают определить порядок выполнения работ и те работы, которые могут быть выполнены параллельно.</p><p>Наконец, на этапе поддержки сцепленность операций через ресурсы помогает спрогнозировать последствия планируемого изменения и предотвратить внесение регрессий.</p></section></section><section class="doc-section level-1"><h2 id=_реализация_концептуальной_модели_в_коде><a class=link href=#_реализация_концептуальной_модели_в_коде>Реализация концептуальной модели в коде</a></h2><p>Все описанные выше элементы транслируются непосредственно в код: события и операции - в методы, ресурсы - в классы, эффекты - в вызовы методов.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Тут есть небольшая шероховатость.
События на самом деле транслируются в метод, передаваемый фреймворку (см. ниже), и вызов из него метода операции.
По крайней мере, если следовать принципам единственности ответственности и/или разделения аспектов (separation of concerns).
Но пока что я не вижу ни потребности, ни возможности отразить это в концептуальной модели.
Возможно, я найду какую-то другую абстракцию для события, так как технически ничего не мешает передать метод операции напрямую фреймворку.</p></aside><p>Операции всегда транслируются в методы классов слоя сервисов приложения - методы, определяющие публичный интерфейс модуля.
При реализации этих методов желательно сохранить очевидность эффектов выполнения операции, присущую диаграмме.</p><p>Ресурсы превращаются в структуру данных и коллекцию методов работы с ней - классы Spring Data агрегата и репозитория, классы события и ApplicationEventPublisher-а (или обёртки вокруг него), классы REST API модели и клиента и т.п.
В контексте бэкэндов информационных систем, самыми распространёнными видами ресурсов являются:</p><div class="olist arabic"><ol class=arabic><li>любые постоянные коллекции данных - таблицы в реляционной СУБД, коллекции в документной СУБД и т.д.</li><li>REST API внешних сервисов</li><li>любые очереди сообщений/шины событий</li><li>изменяемые структуры данных, доступные через глобальные переменные</li></ol></div><p>События превращаются в методы, передаваемые фреймворку для последующего вызова - метод Spring-ового RestController-а, Swing-овый EventListener, реализация Runnable для таймера и т.д.
Если говорить о бакэндах информационных систем, то самыми распространёнными видами событий являются:</p><div class="olist arabic"><ol class=arabic><li>Получение запроса по сети (@RestController + @*Mapping в случае разработки на Spring).
Сейчас популярностью пользуется протокол запросов в REST-стиле, но SOAP, gRPC, CORBA и т.п. так же попадают в эту категорию.</li><li>Появление сообщения в очереди (@JmsListener).</li><li>Доменное событие или событие приложения (@EventListener)</li><li>Наступление определённого момента времени (@Scheduled).
Два основных типа таких событий:<ol class=loweralpha type=a><li>наступление заранее известного момента времени (например, полуночи вторника)</li><li>истечение определённого времени с момента в прошлом (например, истечение суток с момента создания предыдущего бэкапа).</li></ol></li></ol></div></section><section class="doc-section level-1"><h2 id=_нотация><a class=link href=#_нотация>Нотация</a></h2><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Нотация с большой вероятностью претерпит косметические изменения в процессе бета-теста, а также в связи с привлечением профессионального дизайнера к полировке визуального языка перед релизом 1.0.</p></aside><p>Основу визуального языка диаграммы эффектов я позаимствовал в <a href=https://c4model.com/>модели C4</a>.
Во-первых, мне нравится сам язык модели C4.
А во-вторых, диаграмму эффектов можно встроить в модель C4 на четвёртом уровне - вместо кода.
Кроме того, диаграмму третьего уровня (компонентов) я строю как раз на базе диаграммы эффектов.</p><p>Диаграмма эффектов бывает двух типов - краткая и полная.
Краткая содержит только обозначение эффектов и связанных ими операций и ресурсов.
Полная нотация дополнительно включает события и их источники, внешние системы, обеспечивающие реализацию ресурсов и более полное описание всех элементов.</p><p>Рассмотрим нотации с помощью минимального примера визуализации функциональности регистрации и аутентификации пользователей в произвольной системе.
После успешной регистрации пользователям необходимо отправлять приветственное письмо.
Начнём с краткой нотации.</p><section class="doc-section level-2"><h3 id=_краткая_нотация><a class=link href=#_краткая_нотация>Краткая нотация</a></h3><p>В краткой нотации диаграмма выглядит следующим образом (картинка кликабельна):</p><div class=image-block><a class="image bare" href=/posts/22/05/images/short-notation-example.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/22/05/images/short-notation-example.svg alt="short notation example"></a></div><p>Теперь рассмотрим отдельные элементы</p><section class="doc-section level-3"><h4 id=_операции><a class=link href=#_операции>Операции</a></h4><p>Операции обозначаются прямоугольником с именем операции:</p><div class=image-block><img src=/posts/22/05/images/operation.svg alt=operation></div></section><section class="doc-section level-3"><h4 id=_ресурсы><a class=link href=#_ресурсы>Ресурсы</a></h4><p>Ресурсы обозначаются прямоугольником с именем ресурса и цветом, отличным от цвета операции:</p><div class=image-block><img src=/posts/22/05/images/resource.svg alt=resource></div></section><section class="doc-section level-3"><h4 id=_эффекты><a class=link href=#_эффекты>Эффекты</a></h4><p>Эффект модификации ресурса обозначается "сильной" (более заметной) стрелкой от операции к ресурсу, с кратким описанием эффекта:</p><div class=image-block><img src=/posts/22/05/images/operation-resource-rw.svg alt="operation resource rw"></div><p>Эффект чтения ресурса обозначается стрелкой от ресурса к операции, с кратким описанием считываемых данных:</p><div class=image-block><img src=/posts/22/05/images/operation-resource-ro.svg alt="operation resource ro"></div></section><section class="doc-section level-3"><h4 id=_эффекты_вызова_операций><a class=link href=#_эффекты_вызова_операций>Эффекты вызова операций</a></h4><p>Есть особый вид стрелок для эффектов вызова операций вследствие взаимодействия с ресурсами.
Как правило, это ресурсы всевозможных шин событий и связанные с ними операции-обработчики.
Такие связи отображаются прерывистой стрелкой того же стиля, что и стрелка эффекта записи с кратким описанием связи:</p><div class=image-block><img src=/posts/22/05/images/resource-operation-rw.svg alt="resource operation rw"></div></section><section class="doc-section level-3"><h4 id=_примечания><a class=link href=#_примечания>Примечания</a></h4><p>Также на диаграмму можно помещать заметки и примечания, используя любую удобную нотацию.
Я предпочитаю нотацию UML - "лист" с загнутым углом, связанный прерывистой линией с комментируемым элементом.</p><div class=image-block><img src=/posts/22/05/images/note.svg alt=note></div><p>Это все элементы, составляющие ядро диаграммы эффектов.</p></section></section><section class="doc-section level-2"><h3 id=_полная_нотация><a class=link href=#_полная_нотация>Полная нотация</a></h3><p>Теперь рассмотрим ту же функциональность, описанную в полной нотации:</p><div class=image-block><a class="image bare" href=/posts/22/05/images/full-notation-example.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/22/05/images/full-notation-example.svg alt="full notation example"></a></div><p>В полной нотации появляются:</p><div class="olist arabic"><ol class=arabic><li>события</li><li>описание операций и ресурсов в формате модели C4</li><li>границы контейнера из C4.
Обозначает границы процесса - всё, что находится внутри этих границ выполняется в памяти визуализируемого приложения</li><li>внешние системы, базы данных и компоненты из C4.
Внешние системы могут быть как источником события, так и средством реализации ресурса</li></ol></div><p>Расширять состав диаграммы можно постепенно, добавляя только те элементы, которые помогают в решении текущей задачи.</p><section class="doc-section level-3"><h4 id=_события><a class=link href=#_события>События</a></h4><p>На мой взгляд, из дополнительных элементов наибольшую ценность имеют события.
В полной нотации они обозначаются стрелкой от внешней системы к операции с кругом на стартовом конце и описанием в формате C4.
Но в промежуточной версии, внешнюю систему можно опустить и "подвесить" стрелку:</p><div class=image-block><img src=/posts/22/05/images/event-operation.svg alt="event operation"></div></section><section class="doc-section level-3"><h4 id=_описания><a class=link href=#_описания>Описания</a></h4><p>Затем блоки операций и ресурсов можно дополнить типом, способом реализации и описанием:</p><div class=image-block><img src=/posts/22/05/images/descriptions.svg alt=descriptions></div></section><section class="doc-section level-3"><h4 id=_внешние_системы><a class=link href=#_внешние_системы>Внешние системы</a></h4><p>Элементы, обозначающие границы системы и внешние системы полностью соответствуют нотации C4:</p><div class="olist arabic"><ol class=arabic><li>Границы системы отображаются прерывистым прямоугольником приглушённого цвета и подписью с именем контейнера</li><li>Управляемые внешние системы и базы данных обозначаются прямоугольником и символом "База Данных"</li><li>Неуправляемые внешние системы и компоненты обозначаются приглушёнными прямоугольниками</li><li>Неуправляемые базы данных обозначаются приглушённым символом "База Данных"</li></ol></div><p>Внешние системы связываются с операциями посредством событий:</p><div class=image-block><img src=/posts/22/05/images/event-sources.svg alt="event sources"></div><p>А ресурсы связываются с внешними системами посредством стрелок с описанием:</p><div class=image-block><img src=/posts/22/05/images/resource-impls.svg alt="resource impls"></div><p>Ресурс может быть связан со сторонним компонентом, работающем в том же процессе:</p><div class=image-block><img src=/posts/22/05/images/resource-component.svg alt="resource component"></div><p>Здесь приведена связь ресурса с эффектом вызова операции системы.
В случае же если ресурс не обладает таким эффектом, то он соединяется со сторонним компонентом обычной стрелкой.</p><hr><p>Выбор нотации зависит от решаемой задачи.
Если надо быстро разбить систему на модули, или спланировать модификацию сложной или незнакомой операции - можно обойтись краткой нотацией.
Если надо оценить проект для работы за фиксированную цену - лучше взять полную нотацию, чтобы минимизировать вероятность "потери" существенных деталей.</p><p>Ещё два критерия выбора нотации - срок жизни диаграммы и размер целевой аудитории диаграммы.
Если планируете выкинуть диаграмму после анализа и никому не будете её показывать - можно обойтись краткой нотацией.
Если же вы планируете возвращаться сами к диаграмме через длительный срок или публиковать её для ознакомления без вашего руководства - стоит как минимум добавить события и описания ресурсов и операций.</p><p>Я сам обычно начинаю с промежуточной нотации - краткой с событиями, и дополняю её по мере необходимости.</p></section></section></section><section class="doc-section level-1"><h2 id=_инструментарий><a class=link href=#_инструментарий>Инструментарий</a></h2><p>Одним из плюсов базирования на визуальном языке модели C4 является то, что для диаграммы эффектов можно использовать <a href=https://c4model.com/#Tooling>любой инструмент с поддержкой C4</a>.
А в силу простоты C4, таким инструментом может быть хоть графический редактор.
Тем не менее поддержка привязки элементов сильно помогает, поэтому я сам сейчас использую <a href=https://www.diagrams.net/>десктопную версию draw.io</a>.</p></section><section class="doc-section level-1"><h2 id=_заключение><a class=link href=#_заключение>Заключение</a></h2><p>Сущность информационной системы заключена в её поведении - эффектах, которые она оказывает на окружающий мир.</p><p>Самым удобным способом отразить суть поведения системы является связка События-Эффекты - какими эффектами на какие ресурсы в ответ на какие события система реагирует.</p><p>Для визуализации, анализа и проектирования этой связки я разработал диаграмму эффектов.
Предлагаю и вам взять её на вооружение и, надеюсь, что она поможет вам лучше понять душу ваших программ и точнее отразить её в <a href=https://azhidkov.pro/posts/22/04/220409-ergo-approach-v10m1/>эргономичном коде</a>.</p><p>Но прежде чем приступить к визуализации поведения, его надо понять.
В следующем посте я опишу процесс построения диаграммы эффектов (читай - понимания сути задачи) реального проекта.</p></section></article><br></section></div></main><script src=/js/app.js></script></body></html>