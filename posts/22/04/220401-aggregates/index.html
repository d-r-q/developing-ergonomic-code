<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Агрегаты - Алексей Жидков"><meta property="og:description" content="В основе поддерживаемых информационных систем лежат агрегаты. В этом посте я расскажу что такое агрегат, как его проектировать и какие ошибки проектирования агрегатов встречаются чаще всего"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/posts/22/04/220401-aggregates/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/posts/22/04/220401-aggregates/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/posts/22/04/220401-aggregates/><title>Агрегаты - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/posts/22/04/220401-aggregates/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container post"><article><header><h1 class=title>Агрегаты</h1><h2 class=date>April 1, 2022</h2></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><section class="doc-section level-1"><h2 id=_введение><a class=link href=#_введение>Введение</a></h2><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>В процессе написания этого поста, стало очевидно, что ему нужны подводки в виде того, чем агрегаты лучше связного графа сущностей и что такое диаграмма эффектов.
Но так как я этот пост мурыжу уже два месяца, я решил последовать примеру Джорджа Лукаса и начать с конца:)</p></aside><p>В предыдущем посте (<a href=https://azhidkov.pro/drafts/aggregates/information-modeling/>Черновик поста</a>) я рассмотрел подходы к проектированию модели информации системы и пришёл к выводу, что наилучшим подходом является подход на базе агрегатов.
А в этом посте я подробно рассмотрю что такое агрегаты и как их проектировать.</p></section><section class="doc-section level-1"><h2 id=_что_такое_агрегат_tldr><a class=link href=#_что_такое_агрегат_tldr>Что такое агрегат? (TLDR)</a></h2><p>Агрегат - это кластер сущностей и объектов-значений, объединённых общими инвариантами.
Любое взаимодействие с агрегатом осуществляется через одну и только одну из его сущностей, называемую корнем агрегата.</p><p>Для того чтобы обеспечить соблюдение инвариантов, агрегат должен удовлетворять следующим требованиям:</p><div class="olist arabic"><ol class=arabic><li>Выступать единицей персистанса (все сущности всегда загружаются и сохраняются вместе).
"Точкой входа" персистанса (загружаемым и сохраняемым объектом) является корень агрегата</li><li>Все модификации состояния агрегата должны осуществляться через корень</li><li>Все сущности должны входить только в один агрегат</li></ol></div><p>В объектно-ориентированном коде агрегат всегда материализуется минимум в два класса - корень агрегата и репозиторий агрегата.
Внутри агрегата связи реализуются ссылками непосредственно на объекты.
Между агрегатами связи реализуются через идентификаторы корней агрегатов.</p><p>Например, отчёт с непересекающимися отчётными периодами и составителем моделируется двумя агрегатами, которые на Котлине будут выглядеть так:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=c1>// Агрегат составителя отчёта</span>

<span class=kd>data class</span> <span class=nc>Author</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>name</span><span class=p>:</span> <span class=nc>String</span>
<span class=p>)</span>

<span class=kd>interface</span> <span class=nc>AuthorsRepo</span> <span class=p>{</span>
    <span class=k>fun</span> <span class=nf>save</span><span class=p>(</span><span class=n>user</span><span class=p>:</span> <span class=nc>Author</span><span class=p>):</span> <span class=nc>Author</span>
    <span class=k>fun</span> <span class=nf>findById</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>):</span> <span class=nc>Author</span><span class=p>?</span>
<span class=p>}</span>

<span class=c1>// Агрегат отчёта</span>

<span class=kd>data class</span> <span class=nc>ReportingPeriod</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>from</span><span class=p>:</span> <span class=nc>LocalDate</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>to</span><span class=p>:</span> <span class=nc>LocalDate</span>
<span class=p>)</span> <span class=p>{</span>
    <span class=nf>init</span> <span class=p>{</span>
        <span class=nf>require</span><span class=p>(</span><span class=n>from</span> <span class=p>&lt;=</span> <span class=n>to</span><span class=p>)</span> <span class=p>{</span> <span class=s>&#34;$from &gt; $to&#34;</span> <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kd>data class</span> <span class=nc>Report</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>reportingPeriods</span><span class=p>:</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>ReportingPeriod</span><span class=p>&gt;,</span>
    <span class=kd>val</span> <span class=py>authorId</span><span class=p>:</span> <span class=nc>Long</span>
<span class=p>)</span> <span class=p>{</span>
    <span class=nf>init</span> <span class=p>{</span>
        <span class=n>reportingPeriods</span><span class=p>.</span><span class=nf>sortedBy</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>from</span> <span class=p>}</span>
            <span class=p>.</span><span class=nf>windowed</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>partialWindows</span> <span class=p>=</span> <span class=k>false</span><span class=p>)</span>
            <span class=p>.</span><span class=nf>find</span> <span class=p>{</span> <span class=n>it</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>to</span> <span class=p>&gt;=</span> <span class=n>it</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>from</span> <span class=p>}</span>
            <span class=o>?.</span><span class=nf>let</span> <span class=p>{</span> <span class=k>throw</span> <span class=nc>IllegalArgumentException</span><span class=p>(</span><span class=s>&#34;Report cannot have intersecting intervals: ${it[0]} and ${it[1]}&#34;</span><span class=p>)</span> <span class=p>}</span>

    <span class=p>}</span>
<span class=p>}</span>

<span class=kd>interface</span> <span class=nc>ReportsRepo</span> <span class=p>{</span>
    <span class=k>fun</span> <span class=nf>save</span><span class=p>(</span><span class=n>user</span><span class=p>:</span> <span class=nc>Report</span><span class=p>):</span> <span class=nc>Report</span>
    <span class=k>fun</span> <span class=nf>findById</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>):</span> <span class=nc>Report</span><span class=p>?</span>
<span class=p>}</span></code></pre></div><p>Почему агрегата именно два, а не один или три?
Ответ на этот вопрос лежит в принципах декомпозиции модели информации системы.</p></section><section class="doc-section level-1"><h2 id=_принципы_декомпозиции_модели_информации_на_агрегаты><a class=link href=#_принципы_декомпозиции_модели_информации_на_агрегаты>Принципы декомпозиции модели информации на агрегаты</a></h2><p>При проектировании агрегатов (как и всех других элементов ПО) следует руководствоваться принципом высокой связности/низкой связанности.
В случае агрегатов этот принцип выражается в соблюдении следующих ограничений:</p><div class="olist arabic"><ol class=arabic><li>Агрегаты не должны иметь циклических связей</li><li>Агрегаты должны определять область жизни всех сущностей, в них входящих.
Эта область определяется областью жизни корня агрегата.
Некорневые сущности не могут появляться раньше корня и продолжать существовать после его удаления.</li><li>Агрегаты должны обеспечивать соблюдение инвариантов.
Агрегаты предоставляют такое API, которое не позволит клиенту перевести модель в невалидное состояние.</li><li>Агрегаты должны обеспечивать возможность реализовать все операции системы так, чтобы в одной транзакции менялся (или удалялся) один агрегат.
Притом речь идёт именно об изменении (в том числе в виде удаления) существующих агрегатов - создавать и читать можно сколько угодно агрегатов.</li><li>Агрегаты должны быть минимального необходимого размера.
Имеется в виду и количество типов сущностей в агрегате, и количество экземпляров сущностей и их размер в байтах.</li><li>Агрегаты должны храниться целиком в одной системе хранения данных на одном узле.
Разные агрегаты одной системы могут храниться на разных узлах или в разных хранилищах.</li><li>Агрегаты могут ссылаться на другие агрегаты только через идентификаторы корней.
Внутри агрегата сущности могут свободно ссылаться друг на друга.</li></ol></div><p>Так вот, почему агрегатов всё-таки именно два?
Потому что отчёты и составители ценны сами по себе и имеют независимые жизненные циклы.
А периоды не имеют смысла без отчёта и инвариант отсутствия пересечения определяется на кластере объектов отчёта и его отчётных периодов.</p></section><section class="doc-section level-1"><h2 id=_методика_декомпозиции_модели_информации_на_агрегаты><a class=link href=#_методика_декомпозиции_модели_информации_на_агрегаты>Методика декомпозиции модели информации на агрегаты</a></h2><p>Я предпочитаю идти от обратного и на первом этапе считать каждую сущность отдельным агрегатом, а потом искать причины для объединения сущностей в агрегаты.
Поэтому первой версией разбиения информации на агрегаты является сама ER-диаграмма.</p><p>Затем я ищу инварианты системы.
Самый простой и часто встречаемый инвариант - область жизни одной сущности (А) не должна выходить за пределы области жизни другой сущности (Б).
В этом случае сущности А и Б нужно объединить в агрегат с Б в качестве корня.</p><p>Но самые важные инварианты определяются конкретными людьми в конкретном контексте и для их выявления не существует универсального алгоритма на базе технических вводных.
Чтобы выявить самые важные инварианты я обращаюсь к экспертам - заказчикам, пользователям, владельцам продукта, руководителям проектов, аналитикам и т.д.
Зачастую эксперты самостоятельно не могут сформулировать инварианты, и им необходимо помочь, предлагая свои версии и задавая наводящие вопросы (например, могут ли пересекаться отчётные периоды).
Конкретные техники и способы помощи экспертам подробно расписаны в <a href=#_дальнейшее_чтение_по_теме>книгах по DDD</a>.</p><p>Действительно важные инварианты бизнес так или иначе озвучит - важно их услышать.
Если не услышите в процессе разработки, то точно услышите, когда инвариант будет нарушен в промышленной эксплуатации с последствиями для бизнеса:)</p><p>Получив список инвариантов, я выбираю те, что затрагивают несколько типов или экземпляров сущностей.
Сущности, которые участвуют в обеспечении одного инварианта, объединяю в агрегаты.
Если речь идёт о разных типах, то в агрегат я объеднияю сами эти сущности.
Если речь идёт о разных экземплярах одной сущности, то я присоединяю их списком к одной из существующих или специально созданной для этого сущности.</p><p>Затем я проверяю получившиеся агрегаты на соответствие принципам.</p><p><strong>Принцип акцикличных агрегатов</strong> я сейчас нарушаю крайне редко, а нарушения сразу же видны на ER-диаграмме.
При разбиении циклов я пользуюсь принципом стабильных зависимостей и удаляю ссылку из более "стабильного" агрегата.
Стабильность определяется по значимости для бизнеса, вероятности изменений в будущем и количеству входящих связей.
Значимость для бизнеса и вероятность изменений определяются посредством гадания на кофейной гуще.</p><p>Чтобы проверить <strong>принцип изменения одного агрегата в одной транзакции</strong>, я строю <a href=https://azhidkov.pro/posts/22/05/220519-effects-diagram-intro/>диаграмму эффектов</a>.
Диаграмма помогает мне увидеть операции, которые меняют несколько агрегатов.
С такими агрегатами можно поступить по-разному:</p><div class="olist arabic"><ol class=arabic><li>Если агрегаты всегда меняются вместе и размер позволяет - объединить их в один</li><li>Если в одной операции смешались разные ответственности и есть возможность - разбить операцию на две</li><li>Если в одной операции смешались разные ответственности, но разбиение операции невозможно или ухудшает дизайн - разбить изменения агрегатов на разные транзакции<ol class=loweralpha type=a><li>В первую очередь стоит посмотреть на вариант с использованием шины событий.
В этом случае в первой транзакции остаётся изменение первого агрегата и генерация события, а в изменения остальных агрегатов уходят в транзакции обработчиков события.</li><li>Если разбиение через события приводит к появлению каскада событий, то можно просто разбить операцию на несколько транзакций</li></ol></li><li>Если я уверен, что операция имеет высокую связность, а конкуренция за агрегат низкая (он меняется редко или только одним пользователем) - оставить всё как есть.</li></ol></div><p>Если выполнять декомпозицию по описанной выше методики, то агрегаты с большим количеством видов сущностей у меня ни разу не появлялись.
Поэтому для проверки <strong>принципа малых агрегатов</strong> остаётся удостоверится в отсутствии "больших" атрибутов и связей "один к действительно многому".</p><p>"Большие" тексты и массивы байт (картинки) я всегда выношу в отдельные агрегаты, даже когда это приводит к нарушениям принципов общей области жизни и изменения одного агрегата в одной транзакции.
"Большой" - понятие относительное, и я выделяю атрибуты, если математическое ожидание их размера превышает ~4 килобайта.</p><p>"Действительно многие" связи я также всегда выношу в отдельные агрегаты вопреки остальным принципам.
"Действительно многие" - тоже понятие относительное, и я выношу связи, когда математическое ожидание количества связанных объектов превышает ~20 штук.</p><p>Для проверки всех остальных принципов у меня нет устоявшихся инструментария и эвристик и их нарушение я ищу "методом вдумчивого взгляда".</p><p>Процесс "проверить-подрихтовать-обновить диаграммы" я повторяю до тех пор, пока не получу результат, проходящий проверку.</p></section><section class="doc-section level-1"><h2 id=_частые_ошибки_проектирования_агрегатов><a class=link href=#_частые_ошибки_проектирования_агрегатов>Частые ошибки проектирования агрегатов</a></h2><section class="doc-section level-2"><h3 id=_моделирование_лишних_связей><a class=link href=#_моделирование_лишних_связей>Моделирование лишних связей</a></h3><p>Самой распространённой ошибкой является добавление лишних ссылок между объектами.
Предельный случай этой ошибки - модель связного графа объектов.</p><p>Но и в контексте проектирования агрегатов можно внести в модель лишние связи.
Чаще всего причинами внесения лишних связей являются:</p><div class="olist arabic"><ol class=arabic><li>удобство навигации - связь добавляется, чтобы была возможность добраться до объекта А, имея на руках объект Б</li><li>отражение реальности - связь добавляется потому, что "в реальности" сущности связаны</li><li>отражение модели данных - связь добавляется потому, что в логической схеме реляционной БД есть соответствующий атрибут и внешний ключ</li><li>отражение пользовательского интерфейса - связь добавляется потому, что в UI в форме ввода или вывода данных, участвуют данные разных сущностей</li></ol></div><p>Но напомню, что единственной причиной добавления ссылки на объект является вхождение объекта в агрегат, а единственной причиной включения объекта в агрегат является его участие в обеспечении инварианта.
Поэтому если связь не требуется для обеспечения инварианта, то её включение необходимо дважды обдумать.
Потому что, как я уже говорил, лишние связи ведут к повышению …​кхм…​ связанности дизайна и как следствие усложнению системы и деградации производительности.</p></section><section class="doc-section level-2"><h3 id=_анемичная_доменная_модель><a class=link href=#_анемичная_доменная_модель>Анемичная доменная модель</a></h3><p>Ещё одной распространённой ошибкой является анемичная доменная модель.
Анемичная доменная модель характеризуется в первую очередь сущностями, у которых все свойства доступны для чтения и записи через геттеры и сеттеры.
При этом всё поведение сущности ограничивается геттерами и сеттерами.
Эта ошибка ведёт к утери возможности обеспечить соблюдение инвариантов.</p><p>Кроме того, последствием анемичной модели становится погребение существенных для агрегата трансформаций в методах сервисов приложения.
Что влечёт за собой жёсткую сцепку трансформаций и ввода-вывода.
Из-за чего:</p><div class="olist arabic"><ol class=arabic><li>Усложняется задача тестирования трансформаций</li><li>Снижается переиспользуемость трансформаций</li><li>Усложняется задача понимания кода из-за смешения разных уровней абстракции в сервисе приложения</li></ol></div><p>Давайте сравним решения одной и той же задачи с помощью анемичной и "полнокровной" доменных моделей.</p><p>В качестве задачи возьмём систему хранения информации о торговле на бирже крипто-валют.
В центре этой системы находятся "торги по символу" - торги между парой крипто-валют.</p><p>Требования к системе следующие:</p><div class="olist arabic"><ol class=arabic><li>Каждый пользователь по каждой паре может вести торги с использованием "грида" - по сути, набора значений параметров алгоритма торговли.</li><li>В каждый момент времени для каждого символа пользователя может быть активен только один из гридов символа.</li><li>Гриды уникально идентифицируются своим именем.</li><li>Для каждого грида хранится статистика по торгам с его участием (в примере - только доход).</li><li>Статистика может меняться только у активного грида.</li><li>Каждый пользователь может вести торги одновременно по нулю и более символов.</li></ol></div><p>Так же есть ограничение на API системы: обновление информации осуществляется посредством отправки клиентом списка активных в данный момент пар и их гридов.</p><p>Реализация этой задачи с анемичной доменной моделью будет выглядеть примерно так:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=kd>data class</span> <span class=nc>Grid</span><span class=p>(</span>
    <span class=kd>var</span> <span class=py>name</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>profit</span><span class=p>:</span> <span class=nc>BigDecimal</span>
<span class=p>)</span>

<span class=kd>data class</span> <span class=nc>SymbolTrading</span><span class=p>(</span>
    <span class=kd>var</span> <span class=py>symbol</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>grids</span><span class=p>:</span> <span class=nc>MutableList</span><span class=p>&lt;</span><span class=nc>Grid</span><span class=p>&gt;,</span>
    <span class=kd>var</span> <span class=py>activeGrid</span><span class=p>:</span> <span class=nc>Grid</span><span class=p>?</span>
<span class=p>)</span>

<span class=kd>data class</span> <span class=nc>CustomerTradings</span><span class=p>(</span>
    <span class=kd>var</span> <span class=py>customerId</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>tradings</span><span class=p>:</span> <span class=nc>MutableList</span><span class=p>&lt;</span><span class=nc>SymbolTrading</span><span class=p>&gt;</span>
<span class=p>)</span>

<span class=kd>data class</span> <span class=nc>ActiveSymbol</span><span class=p>(</span>
    <span class=kd>var</span> <span class=py>symbol</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>var</span> <span class=py>gridName</span><span class=p>:</span> <span class=nc>String</span>
<span class=p>)</span>

<span class=k>fun</span> <span class=nf>fetchCustomerSymbols</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>):</span> <span class=nc>CustomerTradings</span> <span class=p>=</span> <span class=nc>TODO</span><span class=p>()</span>

<span class=k>fun</span> <span class=nf>saveCustomerSymbols</span><span class=p>(</span><span class=n>customerSymbols</span><span class=p>:</span> <span class=nc>CustomerTradings</span><span class=p>):</span> <span class=nc>Unit</span> <span class=p>=</span> <span class=nc>TODO</span><span class=p>()</span>

<span class=k>fun</span> <span class=nf>updateCustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span> <span class=n>activeSymbols</span><span class=p>:</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>ActiveSymbol</span><span class=p>&gt;)</span> <span class=p>{</span>
    <span class=kd>val</span> <span class=py>customerSymbols</span> <span class=p>=</span> <span class=nf>fetchCustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>)</span> <span class=c1>// (1)</span>

    <span class=n>activeSymbols</span><span class=p>.</span><span class=nf>map</span> <span class=p>{</span> <span class=n>activeSymbol</span> <span class=p>-&gt;</span>
        <span class=kd>val</span> <span class=py>trading</span> <span class=p>=</span> <span class=n>customerSymbols</span><span class=p>.</span><span class=n>tradings</span><span class=p>.</span><span class=nf>find</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>symbol</span> <span class=p>==</span> <span class=n>activeSymbol</span><span class=p>.</span><span class=n>symbol</span> <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>trading</span> <span class=p>!=</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// (2)</span>
            <span class=n>trading</span><span class=p>.</span><span class=n>activeGrid</span> <span class=p>=</span> <span class=n>trading</span><span class=p>.</span><span class=n>grids</span><span class=p>.</span><span class=nf>find</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>name</span> <span class=p>==</span> <span class=n>activeSymbol</span><span class=p>.</span><span class=n>gridName</span> <span class=p>}</span> <span class=o>?:</span> <span class=nc>Grid</span><span class=p>(</span><span class=n>activeSymbol</span><span class=p>.</span><span class=n>gridName</span><span class=p>,</span> <span class=nc>BigDecimal</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=kd>val</span> <span class=py>activeGrid</span> <span class=p>=</span> <span class=nc>Grid</span><span class=p>(</span><span class=n>activeSymbol</span><span class=p>.</span><span class=n>gridName</span><span class=p>,</span> <span class=nc>BigDecimal</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
            <span class=n>customerSymbols</span><span class=p>.</span><span class=n>tradings</span><span class=p>.</span><span class=nf>add</span><span class=p>(</span>
                <span class=nc>SymbolTrading</span><span class=p>(</span><span class=n>activeSymbol</span><span class=p>.</span><span class=n>symbol</span><span class=p>,</span> <span class=nf>mutableListOf</span><span class=p>(</span><span class=n>activeGrid</span><span class=p>),</span> <span class=n>activeGrid</span><span class=p>)</span>
            <span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=nf>saveCustomerSymbols</span><span class=p>(</span><span class=n>customerSymbols</span><span class=p>)</span> <span class=c1>// (1)</span>
<span class=p>}</span></code></pre></div><p>Такую реализацию будет относительно сложно протестировать - надо будет либо сетапить и проверять состояние БД, либо использовать моки и делать тесты хрупким и зависящим от деталей реализации.</p><p>Также здесь в одном методе смешаны и работа с БД (1) и бизнес-правила (2).</p><p>Эти две проблемы можно решить посредством вынесения бизнес-правил в утилитарный метод.
Однако это не решит основную проблему - с таким подходом невозможно защитить инварианты.
Ничего не остановит клиентский код от удаления активного грида из <code>trading.grids</code>.
Как и от изменения статистики по неактивному гриду.</p><p>Для того чтобы защитить инварианты, необходимо большую часть логики перенести в доменную модель.
Также необходимо исключить возможность неконтролируемых операций записи.</p><p>Если оставаться в парадигме изменяемой модели данных, то это можно сделать путём сокращения области видимости сеттеров до внутренней в случае Котлина.
Но тогда придётся выделять агрегаты в разные модули, что очень не удобно.</p><p>В том числе (но не только) по этому, я рекомендую пойти простым путём: сделать сущности неизменяемыми, с закрытым конструктором и опубликованным фабричным методом вместо него, который будет гарантировать соблюдение инвариантов.</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=k>typealias</span> <span class=nc>Symbol</span> <span class=p>=</span> <span class=nc>String</span>

<span class=k>typealias</span> <span class=nc>GridName</span> <span class=p>=</span> <span class=nc>String</span>

<span class=kd>data class</span> <span class=nc>Grid</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>name</span><span class=p>:</span> <span class=nc>GridName</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>profit</span><span class=p>:</span> <span class=nc>BigDecimal</span> <span class=p>=</span> <span class=nc>BigDecimal</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
<span class=p>)</span>

<span class=kd>data class</span> <span class=nc>SymbolTrading</span> <span class=k>private</span> <span class=k>constructor</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>symbol</span><span class=p>:</span> <span class=nc>Symbol</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>grids</span><span class=p>:</span> <span class=nc>Map</span><span class=p>&lt;</span><span class=nc>GridName</span><span class=p>,</span> <span class=nc>Grid</span><span class=p>&gt;,</span>
    <span class=kd>val</span> <span class=py>activeGrid</span><span class=p>:</span> <span class=nc>GridName</span>
<span class=p>)</span> <span class=p>{</span>
    <span class=nf>init</span> <span class=p>{</span>
        <span class=nf>require</span><span class=p>(</span><span class=n>activeGrid</span> <span class=k>in</span> <span class=n>grids</span><span class=p>)</span> <span class=p>{</span> <span class=s>&#34;Active grid ($activeGrid) should be within symbol&#39;s grids ($grids)&#34;</span> <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>companion</span> <span class=k>object</span> <span class=p>{</span>
        <span class=k>fun</span> <span class=nf>new</span><span class=p>(</span><span class=n>symbol</span><span class=p>:</span> <span class=nc>Symbol</span><span class=p>,</span> <span class=n>gridName</span><span class=p>:</span> <span class=nc>GridName</span><span class=p>)</span> <span class=p>=</span>
            <span class=nc>SymbolTrading</span><span class=p>(</span><span class=n>symbol</span><span class=p>,</span> <span class=nf>mapOf</span><span class=p>(</span><span class=n>gridName</span> <span class=n>to</span> <span class=nc>Grid</span><span class=p>(</span><span class=n>gridName</span><span class=p>)),</span> <span class=n>gridName</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=k>fun</span> <span class=nf>activateGrid</span><span class=p>(</span><span class=n>gridName</span><span class=p>:</span> <span class=nc>String</span><span class=p>):</span> <span class=nc>SymbolTrading</span> <span class=p>=</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>gridName</span> <span class=k>in</span> <span class=n>grids</span><span class=p>)</span> <span class=nc>SymbolTrading</span><span class=p>(</span><span class=n>symbol</span><span class=p>,</span> <span class=n>grids</span><span class=p>,</span> <span class=n>gridName</span><span class=p>)</span>
        <span class=k>else</span> <span class=nc>SymbolTrading</span><span class=p>(</span><span class=n>symbol</span><span class=p>,</span> <span class=n>grids</span> <span class=p>+</span> <span class=p>(</span><span class=n>gridName</span> <span class=n>to</span> <span class=nc>Grid</span><span class=p>(</span><span class=n>gridName</span><span class=p>)),</span> <span class=n>gridName</span><span class=p>)</span>

<span class=p>}</span>

<span class=kd>data class</span> <span class=nc>CustomerSymbols</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>customerId</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>tradings</span><span class=p>:</span> <span class=nc>Map</span><span class=p>&lt;</span><span class=nc>Symbol</span><span class=p>,</span> <span class=nc>SymbolTrading</span><span class=p>&gt;</span>
<span class=p>)</span> <span class=p>{</span>

    <span class=k>fun</span> <span class=nf>activateSymbols</span><span class=p>(</span><span class=n>activeSymbols</span><span class=p>:</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>ActiveSymbol</span><span class=p>&gt;):</span> <span class=nc>CustomerSymbols</span> <span class=p>{</span>
        <span class=kd>val</span> <span class=py>updatedTradings</span> <span class=p>=</span> <span class=n>activeSymbols</span><span class=p>.</span><span class=nf>map</span> <span class=p>{</span>
            <span class=n>tradings</span><span class=p>[</span><span class=n>it</span><span class=p>.</span><span class=n>symbol</span><span class=p>]</span><span class=o>?.</span><span class=nf>activateGrid</span><span class=p>(</span><span class=n>it</span><span class=p>.</span><span class=n>gridName</span><span class=p>)</span>
                <span class=o>?:</span> <span class=nc>SymbolTrading</span><span class=p>.</span><span class=nf>new</span><span class=p>(</span><span class=n>it</span><span class=p>.</span><span class=n>symbol</span><span class=p>,</span> <span class=n>it</span><span class=p>.</span><span class=n>gridName</span><span class=p>)</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=nc>CustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>,</span> <span class=n>tradings</span> <span class=p>+</span> <span class=n>updatedTradings</span><span class=p>.</span><span class=nf>associateBy</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>symbol</span> <span class=p>})</span>
    <span class=p>}</span>

<span class=p>}</span>

<span class=kd>data class</span> <span class=nc>ActiveSymbol</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>symbol</span><span class=p>:</span> <span class=nc>String</span><span class=p>,</span>
    <span class=kd>val</span> <span class=py>gridName</span><span class=p>:</span> <span class=nc>String</span>
<span class=p>)</span>

<span class=k>fun</span> <span class=nf>fetchCustomerSymbols</span><span class=p>(</span><span class=n>id</span><span class=p>:</span> <span class=nc>Long</span><span class=p>):</span> <span class=nc>CustomerSymbols</span> <span class=p>=</span> <span class=nc>TODO</span><span class=p>()</span>

<span class=k>fun</span> <span class=nf>saveCustomerSymbols</span><span class=p>(</span><span class=n>customerSymbols</span><span class=p>:</span> <span class=nc>CustomerSymbols</span><span class=p>):</span> <span class=nc>Unit</span> <span class=p>=</span> <span class=nc>TODO</span><span class=p>()</span>

<span class=k>fun</span> <span class=nf>updateCustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>:</span> <span class=nc>Long</span><span class=p>,</span> <span class=n>activeSymbols</span><span class=p>:</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>ActiveSymbol</span><span class=p>&gt;)</span> <span class=p>{</span>
    <span class=kd>val</span> <span class=py>customerSymbols</span> <span class=p>=</span> <span class=nf>fetchCustomerSymbols</span><span class=p>(</span><span class=n>customerId</span><span class=p>)</span>
    <span class=kd>val</span> <span class=py>updatedCustomerSymbols</span> <span class=p>=</span> <span class=n>customerSymbols</span><span class=p>.</span><span class=nf>activateSymbols</span><span class=p>(</span><span class=n>activeSymbols</span><span class=p>)</span>
    <span class=nf>saveCustomerSymbols</span><span class=p>(</span><span class=n>updatedCustomerSymbols</span><span class=p>)</span>
<span class=p>}</span></code></pre></div><p>Такая реализация гарантирует, что любые модификации в данных должны будут пройти через <code>CustomerSymbols</code>.
А так как <code>CustomerSymbols</code> является единицей работы с БД, это гарантирует, что в БД не попадут никакие данные в обход кода контроля инвариантов в модели.</p><p>"Полнокровная" модель явно очерчивает список доступных операций и повышает их видимость - все операции над агрегатом находится рядом с агрегатом, а не разбросаны по сервисам и утилитарным методам.</p><p>Наконец, вся бизнес логика, которую надо покрыть полноценным набором тестов, ушла в чистую доменную модель которую очень легко тестировать.
А код с эффектами - <code>updateCustomerSymbols</code> - стал тривиальным и его достаточно протестировать одним интеграционным, е2е или сценарным тестом.</p><p>Всё вместе - гарантия соблюдения инвариантов, упрощение анализа операций записи и упрощение тестирования - позволяет существенно уменьшить количество ошибок и регрессий и, как следствие, сократить стоимость разработки в длительной перспективе.</p></section></section><section class="doc-section level-1"><h2 id=_faq><a class=link href=#_faq>FAQ</a></h2><section class="doc-section level-2"><h3 id=_как_программировать_связи><a class=link href=#_как_программировать_связи>Как программировать связи?</a></h3><p>Связи внутри агрегата программируются свойствами со ссылками на объекты (a), а между агрегатами - свойствами с идентификаторами корней агрегатов (b):</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=kd>data class</span> <span class=nc>Report</span><span class=p>(</span>
    <span class=kd>val</span> <span class=py>reportingPeriods</span><span class=p>:</span> <span class=nc>List</span><span class=p>&lt;</span><span class=nc>ReportingPeriod</span><span class=p>&gt;,</span> <span class=c1>// (a)</span>
    <span class=kd>val</span> <span class=py>authorId</span><span class=p>:</span> <span class=nc>Long</span> <span class=c1>// (b)</span>
<span class=p>)</span></code></pre></div></section><section class="doc-section level-2"><h3 id=_как_защитить_инварианты><a class=link href=#_как_защитить_инварианты>Как защитить инварианты?</a></h3><p>Для того чтобы гарантировать сохранность своих инвариантов, агрегат должен не позволять внешним клиентам менять состояние напрямую.
Для достижения этого необходимо следовать принципу "Tell Don’t Ask".
В случае агрегатов это означает предоставление корнем агрегата API внесения изменений вместо API получения изменяемых объектов внутренних сущностей.</p><p>При этом для получения информации об агрегате есть несколько подходов:</p><div class="olist arabic"><ol class=arabic><li>Использовать неизменяемые классы для моделирования сущностей агрегатов.
Объекты таких классов можно безопасно передавать клиентам, поэтому агрегат может предоставить прямой доступ к своим частям.<ol class=loweralpha type=a><li>Плюсы: минимум дополнительного кода, хорошо масштабируется по количеству методов запроса информации</li><li>Минусы: повышает связанность между клиентами и агрегатом.</li></ol></li><li>Предоставлять API в том числе для получения информации только на уровне корня агрегата.
В этом случае внутренние сущности вообще не попадают в публичное API агрегата.<ol class=loweralpha type=a><li>Плюсы: полностью скрывает устройство агрегата и минимизирует связанность между клиентами и агрегатом</li><li>Минусы: плохо масштабируется по количеству методов запроса информации</li></ol></li><li>Использовать копии изменяемых объектов.
Этот подход похож на первый, тем что даёт клиентам доступ к частям агрегата, но клиентам выдаются не сами объекты частей, а их копии<ol class=loweralpha type=a><li>Плюсы: может быть использован в случае, когда нет возможности сделать объекты неизменяемыми</li><li>Минусы: те же, что и у первого подхода, и необходимость в дополнительном коде копирования объектов в каждом геттере и, как следствие, большей нагрузки на сборщика мусора</li></ol></li><li>Использовать "read-only" представления.
Похож на третий подход, но вместо копий предполагается возвращать "read-only" представления изменяемых сущностей.<ol class=loweralpha type=a><li>Плюсы: нет необходимости в коде копирования объектов и снижение нагрузки на сборщика мусора</li><li>Минусы: требует описания дополнительных интерфейсов для представлений и не очень надёжен - никто не запретит клиенту привести объект к изменяемому типу или поменять его через механизм рефлексии.</li></ol></li></ol></div><p>Я сам использую преимущественно первый подход, подключая второй в случаях, когда вижу необходимость в сокрытии структуры агрегата.</p></section><section class="doc-section level-2"><h3 id=_как_реализовать_выборку_данных_для_ui><a class=link href=#_как_реализовать_выборку_данных_для_ui>Как реализовать выборку данных для UI?</a></h3><p>Существует несколько походов, и у каждого из них свои плюсы и минусы.</p><div class="olist arabic"><ol class=arabic><li>Сборка DTO из агрегатов.
Заключается в том, чтобы вытащить нужные агрегаты из репозиториев и собрать из них DTO.<ol class=loweralpha type=a><li>Плюсы - минимальная сцепленность модулей, минимум дополнительного кода</li><li>Минусы - потенциальные проблемы с производительностью из-за нескольких запросов в БД и больше ручной работы по добавлению зависимостей на репозитории и чтению данных из них.</li></ol></li><li>Сборка DPO из агрегатов.
По сути то же, что и первый вариант, только клиенту выдаётся Data Payload Object (DPO), вместо DTO.
DPO - это набор агрегатов, из которого клиент сам строит нужные ему структуры.<ol class=loweralpha type=a><li>Плюсы - минимальная сцепленность модулей, не нужен код для маппинга агрегатов в клиентские структуры.</li><li>Минусы - клиенту будут возвращаться лишние данные, что может плохо сказаться на эффективности и безопасности системы.</li></ol></li><li>Отдельные модели для записи и чтения.
В дополнение к модели для записи (агрегаты), создаётся дополнительная денормализованная модель для чтения.<ol class=loweralpha type=a><li>Плюсы - эффективная работа с БД и создание DTO средствами ORM.</li><li>Минусы - неявная сцепка модуля генерации DTO с деталями реализации всех модулей агрегатов, в два раза больше кода для описания модели данных.</li></ol></li><li>Сборка DTO в СУБД.
Современные СУБД (PostgreSQL, в частности) имеют встроенные средства для формирования JSON и позволяют собрать финальную DTO непосредственно SQL-запросом.<ol class=loweralpha type=a><li>Плюсы - самая эффективная работа с БД.</li><li>Минусы - завязка на диалект определённой СУБД, менее удобный инструментарий для работы с SQL-запросами (чем с кодом на Kotlin, например), примитивные средства переиспользования кода и создания абстракций в самом SQL.</li></ol></li></ol></div><p>Варианты 1-3 подробно рассмотрены в <a href=#_дальнейшее_чтение_по_теме>книгах по DDD</a>, вариант 4 хорошо описан в посте Лукаса Едера <a href=https://blog.jooq.org/stop-mapping-stuff-in-your-middleware-use-sqls-xml-or-json-operators-instead/>Stop Mapping Stuff in Your Middleware. Use SQL’s XML or JSON Operators Instead</a></p><p>Я сейчас в качестве варианта по умолчанию использую первый, а третий или четвёртый задействую в "горячем" коде.
Второй вариант я пока что ни разу не использовал.</p></section><section class="doc-section level-2"><h3 id=_зачем_объединять_сущности_в_агрегаты><a class=link href=#_зачем_объединять_сущности_в_агрегаты>Зачем объединять сущности в агрегаты?</a></h3><p>Для того чтобы обеспечить выполнение инварианта, затрагивающего несколько сущностей.
Частым примером такого инварианта являются слабые сущности - сущности область жизни которых ограничена областью жизни другой сущности.</p></section><section class="doc-section level-2"><h3 id=_почему_агрегаты_должны_быть_маленькими><a class=link href=#_почему_агрегаты_должны_быть_маленькими>Почему агрегаты должны быть маленькими?</a></h3><p>Из соображений производительности.
Так как агрегаты являются единицей персистанса, большие агрегаты приведут к передаче больших объёмов данных по сети.
И так как агрегаты являются единицей согласованности, большие агрегаты приведут к "большим" транзакциям (по количеству затронутых объектов и длительности), что повлечёт за собой большое количество конфликтующих транзакций.
Это, в свою очередь, станет причиной либо ошибкам согласованности, либо большим накладным расходам на синхронизацию транзакций.</p></section><section class="doc-section level-2"><h3 id=_когда_не_стоит_объединять_сущности_в_агрегаты><a class=link href=#_когда_не_стоит_объединять_сущности_в_агрегаты>Когда не стоит объединять сущности в агрегаты?</a></h3><p>Тогда, когда это приведёт к большим агрегатам.
Например, пользователя, его фото и его комментарии лучше разделить по разным агрегатам, не смотря на то, что фото и комментарии являются слабыми сущностями.
Фото - просто в силу большого размера.
Комментарии - в силу их неограниченного роста.</p></section><section class="doc-section level-2"><h3 id=_когда_можно_включать_в_агрегат_много_видов_сущностей><a class=link href=#_когда_можно_включать_в_агрегат_много_видов_сущностей>Когда можно включать в агрегат много видов сущностей?</a></h3><p>Агрегат может включать много видов сущностей, при соблюдении двух условий:</p><div class="olist arabic"><ol class=arabic><li>Агрегат преимущественно изменяется одним пользователем - исключает проблемы с синхронизацией</li><li>Агрегат остаётся ограниченным по размеру в байтах - исключает проблемы с производительностью</li></ol></div></section><section class="doc-section level-2"><h3 id=_почему_в_транзакции_можно_менять_только_один_агрегат><a class=link href=#_почему_в_транзакции_можно_менять_только_один_агрегат>Почему в транзакции можно менять только один агрегат?</a></h3><p>Во-первых - по определению.
Агрегат определяет границы согласованности.</p><p>Во-вторых, потому что много маленьких агрегатов - это де-факто один большой агрегат со всеми вытекающими проблемами с синхронизацией и производительностью.</p><p>В-третьих, агрегаты могут храниться на разных машинах.
А по определению агрегата это значит, что придётся иметь дело с распределёнными транзакциями.
С которыми я бы предпочёл иметь дело в последнюю очередь.</p></section><section class="doc-section level-2"><h3 id=_как_обеспечить_выполнение_принципа_модификация_одного_агрегата_в_одной_транзакции><a class=link href=#_как_обеспечить_выполнение_принципа_модификация_одного_агрегата_в_одной_транзакции>Как обеспечить выполнение принципа "модификация одного агрегата в одной транзакции"?</a></h3><p>В первую очередь, необходимо понять действительно ли эти модификации должны быть строго согласованы, или можно обойтись согласованностью в конечном итоге.
Для этого автор <a href=#iddd>одной из основных книг по ДДД</a> предлагает следующий алгоритм:</p><div class="olist arabic"><ol class=arabic><li>если обеспечение согласованности изменений является ответственностью пользователя, инициировавшего выполнение операции - то модификации должны быть строго согласованы</li><li>иначе - можно обойтись согласованностью в конечном итоге</li></ol></div><p>Если получилось что, модификации должны быть строго согласованы, то это значит, что вы "открыли" новый инвариант, и новый агрегат для его обеспечения.
Если при этом агрегат становится большим - надо взвешивать плюсы и минусы и либо оставлять большой агрегат, либо возвращаться на этап проектирования агрегатов и операций системы и искать новое решение.
Возможно несколько потенциальных решений:</p><div class="olist arabic"><ol class=arabic><li>"Закрыть" этот неудобный инвариант и перейти к согласованности в конечном итоге</li><li>Убрать из агрегата "лишние" сущности, которые были включены в него по причинам отличным от обеспечения инварианта</li><li>Разбить большой агрегат, новым способом, который обеспечит соблюдение всех инвариантов.
Возможно для этого придётся отказаться от некоторых инвариантов</li></ol></div><p>Если же модификации могут быть согласованными в конечном итоге, то операцию необходимо разбить на две.
Для этого надо разбить код на два транзакционных метода в слое сервисов приложения.
Затем либо оба этих метода публикуются для клиентов, либо они связываются через публикацию доменного события первым методом и его обработку вторым.</p></section></section><section class="doc-section level-1"><h2 id=_заключение><a class=link href=#_заключение>Заключение</a></h2><p>Агрегаты - действительно сложная тема:</p><div class=quote-block><blockquote><p>Clustering Entities (5) and Value Objects (6) into an Aggregate with a carefully crafted consistency boundary may at first seem like quick work, but among all DDD tactical guidance, this pattern is one of the least well understood.</p><footer>— <cite>Vaughn Vernon, Implementing Domain-Driven Design</cite></footer></blockquote></div><p>и её невозможно полностью понять, прочитав один пост.</p><p>Но я постарался собрать в этом посте необходимый минимум информации для того, чтобы спроектировать первый агрегат.</p></section><section class="doc-section level-1"><h2 id=_дальнейшее_чтение_по_теме><a class=link href=#_дальнейшее_чтение_по_теме>Дальнейшее чтение по теме</a></h2><div class="ulist bibliography"><ul class=bibliography><li><a id=idddd aria-hidden=true></a>[idddd] <a href=https://www.alibabacloud.com/blog/an-in-depth-understanding-of-aggregation-in-domain-driven-design_598034>An In-Depth Understanding of Aggregation in Domain-Driven Design</a></li><li><a id=ddd aria-hidden=true></a>[ddd] <a href=https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215>Domain-Driven Design: Tackling Complexity in the Heart of Software</a></li><li><a id=dddmf aria-hidden=true></a>[dddmf] <a href=https://pragprog.com/titles/swdddf/domain-modeling-made-functional/>Domain Modeling Made Functional: Tackle Software Complexity with Domain-Driven Design and F#</a></li><li><a id=dddd aria-hidden=true></a>[dddd] <a href=https://www.oreilly.com/library/view/domain-driven-design-distilled/9780134434964/>Domain-Driven Design Distilled</a></li><li><a id=pppofddd aria-hidden=true></a>[pppofddd] <a href=https://www.oreilly.com/library/view/patterns-principles-and/9781118714706/>Patterns, Principles, and Practises of Domain-Driven Design</a></li><li><a id=iddd aria-hidden=true></a>[iddd] <a href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/ref=pd_sbs_1/141-8150406-3569707?pd_rd_w=esaTU&pf_rd_p=3676f086-9496-4fd7-8490-77cf7f43f846&pf_rd_r=C3ZFNR15H4FV4HF5NM1B&pd_rd_r=15e71ee5-1ea0-496e-baee-6e3137eba574&pd_rd_wg=49plh&pd_rd_i=0321834577&psc=1">Implementing Domain-Driven Design</a></li></ul></div></section></article><br></section></div></main><script src=/js/app.js></script></body></html>