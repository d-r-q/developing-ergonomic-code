<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Ретро реинжиниринга Проекта Э - организация - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/drafts/project-e-retro/project-e-v2/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/drafts/project-e-retro/project-e-v2/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/drafts/project-e-retro/project-e-v2/><title>Ретро реинжиниринга Проекта Э - организация - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/drafts/project-e-retro/project-e-v2/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Ретро реинжиниринга Проекта Э - организация</h1></header><section class="doc-section level-1"><h2 id=_введение><a class=link href=#_введение>Введение</a></h2><p>Представьте ситуацию.
На дворе 2022 год, вы - техлид/архитектор с 17 годами опыта разработки бакэндов под JVM.
Вас просят взять и довести до прода проект на 9 человеко/месяцев оригинальной разработки, на 30 таблиц и ~100 эндпоинтов REST API.
Проект - готов на 90%, но есть нюансы:</p><div class="olist arabic"><ol class=arabic><li>Проект на .net, на стеке 2019 года;</li><li>В проекте нет ни одного теста;</li><li>Связи с изначальными авторами проекта нет от слова совсем, технической документации к проекту - тоже.</li></ol></div><p>Ваши действия?</p><p>Я, оказавшись в этой ситуации, решил переписать всё к едрене фене.
Силами команды из двух юниоров и одного стажра.
Официально я это назвал полным реинжинирингом проекта.</p><p>В этом посте я расскажу почему я решил всё переписать, как продавал эту идею и организовывал процесс и что из этого всего получилось.
Забегая вперёд, скажу что это история с хэппи эндом - я уложился в исходную оценку и вдвое сократил средние трудозатраты и количество багов на фичу.</p></section><section class="doc-section level-1"><h2 id=_проект_э><a class=link href=#_проект_э>Проект Э</a></h2><p>В начале января 2019 года один из аутсорсеров на бескрайнем пространстве СНГ начал работы над проектом по заказу российского разработчика медоборудования.
Далее я буду называть этот проект Проектом Э.</p><p>Очень упрощённо проект можно считать медицинским дневником.
Пользователи (пациенты) собирают с помощью устройства заказчика определённые показатели организма, которые сохраняются в БД.
Кроме того, пользователи вносят в систему дополнительную информацию, такую как приём лекарств, пищи, занятия спортом и т.п.
А врачи, по приглашению пациентов, получают доступ к их дневникам.</p><p>Так выглядела диаграмма контекста <a href=https://c4model.com/>модели C4</a> Проекта Э в конце 2019 года (картинка кликабельна):</p><div class=image-block><a class="image bare" href=/drafts/project-e-retro/images/project-e-context.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/project-e-retro/images/project-e-context.drawio.svg alt="Диаграмма контекста Проекта Э"></a></div><p>Изначальная команда реализовала 90% проекта к октябрю 2019 года и заказчик ушёл на сертификацию своего устройства, заморозив разработку.</p><p>Но потом в марте 2020 года что-то пошло не так (возможно вы уже забыли, что у нас была такая штука как пандемия) и сертификация затянулась до 2022 года.</p><p>А в феврале 2022 года что-то пошло совсем не так (уверен, что тут вы ещё ничего не забыли) и изначальная команда перекинула репозитори проекта через забор с запиской, что они отказываются продолжать работы.</p><p>После этого заказчик начал искать нового подрядчика и в апреле 2022 года выбрал компанию Сибериан.Про.</p><p>В апреле-мае были преимущественно организационные работы и работы по подготовке мобильных приложений к публикации в сторы, а я подключился к проекту в июне в качестве техлида проекта.
И сразу понял, что вляпался я неподецки.</p></section><section class="doc-section level-1"><h2 id=_проблемы_проекта><a class=link href=#_проблемы_проекта>Проблемы проекта</a></h2><p>На второй день ознакомления с кодовой базой я в Slack-канал проекта написал такое сообщение:</p><div class=quote-block><blockquote><p>Я нашёл. оно никогда не перестанет быть смешным и не потеряет актуальность
<a class=bare href=https://thecodinglove.com/content/039/gez23qJ.webm>https://thecodinglove.com/content/039/gez23qJ.webm</a></p></blockquote></div><p>Вот сразу мемасик из ссылки:</p><video controls autoplay>
<source src=https://thecodinglove.com/content/039/gez23qJ.webm type=video/webm>Your browser does not support the video tag.</video><p>В тот же день я завёл в слаке канал project-e-wtf - куда сливал свой яд от всевозможных находок в коде.</p><p>Находок было очень много, но наибольший WTF у меня вызывали три штуки:</p><div class="olist arabic"><ol class=arabic><li>Полное отсутствие каких бы то ни было тестов;</li><li>Неуместное применение микросервисной архитектуры и её плохая реализация;</li><li>Использование вертикальной архитектуры на базе MediatR.</li></ol></div><p>Разберу их чуть подробнее.</p><section class="doc-section level-2"><h3 id=_отсутствие_тестов><a class=link href=#_отсутствие_тестов>Отсутствие тестов</a></h3><p>В кодовой базе не было ни одного теста.
И если отсутствие функциональных и интеграционных тестов можно объяснить сложностью тестирования микросервисной архитектуры, то отсутствие даже юнит тестов на моках - для меня загадка, проектов без тестов я не видел с 2014 года.</p><p>В итоге, как только мы начали пытаться вносить изменения в систему - на нас тут же широкой рекой хлынули баги.</p></section><section class="doc-section level-2"><h3 id=_микросервисы><a class=link href=#_микросервисы>Микросервисы</a></h3><p>Изначально диаграмма контейнеров бэка проекта в нотации C4 выглядела так:</p><div class=image-block><a class="image bare" href=/drafts/project-e-retro/images/project-e-retro-backend.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/project-e-retro/images/project-e-retro-backend.drawio.svg alt="Диаграмма контейнеров бакэнда Проекта Э"></a></div><p>При том в проекте не было ни одной объективной причины, которая бы оправдывала сложности в разработке, привносимые микросервисной архитектурой.</p><p>Изначальная бек-команда состояла из одного бэк-разработчика, соотвественно банально не было людей, между которыми надо было минимизировать коммуникации и конфликты.</p><p>Различных требований к масштабированию частей системы тоже не было и не предвидится.
На тот момент, когда я принял проект, он ещё не был зарелизан, и соответственно нагрузка на него была 0 rps, и все сервисы деплоились в единственном экземпляре.
Сейчас, спустя 8 месяцев опытной эксплуатации, у нас пиковая нагрузка составляет 0.5 rps.
А после выхода на расчётное количество пользователей, планируемая средняя нагрузка будет порядка 10-20 rps, а пиковая не превысит 100 rps.
Соотвественно, никаких проблем с масштабированием не предвиделось и не предвидится - пара инстансов, созданных из соображений высокой доступности с лёгкостью будет закрывать весь входящий поток запросов.</p><p>Единственное место, где ожидается сильный перекос - это база данных дневников.
Там мы ожидаем сотни миллионов-миллиарды строк, против десятков-сотен тысяч строк в остальных БД.
Но это будет в далёком и прекрасном будущем, а пока что их 300К с ростом на 3К в день.</p><p>Инфраструктура тоже были типовая и общая для большинства сервисов - PostgreSQL, RabbitMQ и всё.
Только у модуля email-нотификаций была уникальная зависимость на smtp-транспорт.</p><p>Никаких других факторов, требующих такого уровня изоляции частей системы, тоже не было.</p><p>Но неуместное использование микросервисов - было только половиной беды.
Исполнение также хромало на обе ноги.</p><p>Во-первых, в проекте использовался разделяемый модуль shared - антипаттерн разработки МСов.
Который среди прочего включал ДТОшки АПИ сервисов.
Соответственно разработка фичи которая затрагивала несколько сервисов (а таких фич было большинство) зачастую состояла из следующих шагов:</p><div class="olist arabic"><ol class=arabic><li>Обновить модуль shared;</li><li>Собрать и опубликовать его;</li><li>Попытаться обновить сервер, обнаружить проблему в интерфейсе и вернуться на шаг 1;</li><li>Попытаться обновить клиент, обнаружить проблему в интерфейсе и вернуться на шаг 1;</li><li>Задеплоить сервер;</li><li>Задеплоить клиент.</li></ol></div><p>Отдельную пикантность ситуации придавало наличие сервиса share, который отвечал за представление доступа к данным пациентов - я не сразу заучил кто из них кто.</p><p>Во-вторых, микросервисы, опять же вопреки основополагающему принципу их дизайна, обладали высокой степенью сцепленности - практически каждая операция включала в себя синхронные обращения к другим микросервисам, которые, в процессе обработки запросов снова шли в следующие микросервисы.</p><p>Например, вот так выглядит граф вызовов в юзкейсе предпросмотра группы пациентов:</p><div class=image-block><a class="image bare" href=/drafts/project-e-retro/images/project-e-retro-create-group.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/project-e-retro/images/project-e-retro-create-group.drawio.svg alt="Диаграмма контекста Проекта Э"></a></div><p>Юзкейс заключается в том, что администраторы могут создавать группы из пациентов, наблюдаемых определёнными врачами.
При создании новой группы на первом этапе (синие стрелки) выполняется выбор врачей с поиском по емейлу, а потом отображается состав группы для предпросмотра (зелёные стрелки).</p><p>А так выглядела генерация PDF-отчёта по наблюдаемому:</p><div class=image-block><a class="image bare" href=/drafts/project-e-retro/images/project-e-retro-generate-pdf-report.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/project-e-retro/images/project-e-retro-generate-pdf-report.drawio.svg alt="Диаграмма контекста Проекта Э"></a></div><p>Знаю, что некоторые эксперты по МСА считают такие графы сетевых вызовов нормой, но на мой взгляд это совершенно не эргономично и соотвественно не должно быть нормой.</p><p>В результате, у команды были все сложности, свойственные микросервисной архитектуре, но она не нуждалась ни в одном из преимуществ, которые даёт МСА.</p></section><section class="doc-section level-2"><h3 id=_вертикальная_архитектура_на_базе_mediatr><a class=link href=#_вертикальная_архитектура_на_базе_mediatr>Вертикальная архитектура на базе MediatR</a></h3><p>Это спорная тема и знаю, что такой подход популярен в .net-сообществе, однако мне он не нравится.
Для вертикальной архитектуры не существует единого определения и можно нагуглить множество разных вариаций её реализации.
Вариант, который был использован в Проекте Э, довольно подробно описан в <a href=https://medium.com/@yurexus/mediatr-outside-vertical-slice-architecture-and-why-you-are-probably-using-it-wrong-3bfd45b0fe0e>этом посте</a>.</p><p>Если вкратце, то использованный подход можно охарактеризовать так:</p><div class="olist arabic"><ol class=arabic><li>На каждую операцию в слое сервисов заводится отдельный класс-обработчик;</li><li>Доступ к данным размазан между репозиториями (модификация через EntityFramework) и обработчиками (чтение через строковые константы с SQL);</li><li>Контроллеры вместо прямого вызова сервисов отправляют команду в MediatR и он сам как-то определяет в какой класс-обработчик её передать.</li></ol></div><p>В итоге типичный обработчик выглядел так:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=csharp><span class=k>namespace</span> <span class=nn>ProjectE.Share.Api.Controllers.Queries.GetObservables</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>class</span> <span class=nc>GetObservablesQueryHandler</span> <span class=p>:</span> <span class=n>IRequestHandler</span><span class=p>&lt;</span><span class=n>GetObservablesQuery</span><span class=p>,</span> <span class=n>GetObservablesQueryResult</span><span class=p>&gt;</span>
    <span class=p>{</span>

        <span class=c1>// Поля и конструктор</span>

        <span class=k>public</span> <span class=k>async</span> <span class=n>Task</span><span class=p>&lt;</span><span class=n>GetObservablesQueryResult</span><span class=p>&gt;</span> <span class=nf>Handle</span><span class=p>(</span><span class=n>GetObservablesQuery</span> <span class=n>request</span><span class=p>,</span> <span class=n>CancellationToken</span> <span class=n>cancellationToken</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=kt>var</span> <span class=n>startIndex</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>PageSize</span> <span class=p>*</span> <span class=p>(</span><span class=n>request</span><span class=p>.</span><span class=n>PageIndex</span> <span class=p>-</span> <span class=m>1</span><span class=p>);</span>
            <span class=k>const</span> <span class=kt>string</span> <span class=n>sql</span> <span class=p>=</span> <span class=s>@&#34;select count(*)
                                  from observers o
                                 where o.user_id = @userId and not o.is_deleted;
                                 select o.observable_id, obs.user_id
                                  from observers o
                                 inner join observables obs on obs.id = o.observable_id
                                 where o.user_id = @userId and not o.is_deleted
                                 limit @pageSize offset @startIndex&#34;</span><span class=p>;</span>

            <span class=kt>var</span> <span class=n>result</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ObservablesQueryResultDto</span> <span class=p>{</span><span class=n>Meta</span> <span class=p>=</span> <span class=k>new</span> <span class=n>MetaDataDto</span> <span class=p>{</span><span class=n>CurrentPage</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>PageIndex</span><span class=p>,</span> <span class=n>PageSize</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>PageSize</span><span class=p>}};</span>
            <span class=k>using</span> <span class=p>(</span><span class=kt>var</span> <span class=n>connection</span> <span class=p>=</span> <span class=k>new</span> <span class=nf>NpgsqlConnection</span><span class=p>(</span><span class=n>_options</span><span class=p>.</span><span class=n>Value</span><span class=p>.</span><span class=n>ConnectionString</span><span class=p>))</span>
            <span class=p>{</span>
                <span class=k>await</span> <span class=n>connection</span><span class=p>.</span><span class=nf>OpenAsync</span><span class=p>(</span><span class=n>cancellationToken</span><span class=p>);</span>
                <span class=k>using</span> <span class=p>(</span><span class=kt>var</span> <span class=n>multi</span> <span class=p>=</span> <span class=k>await</span> <span class=n>connection</span><span class=p>.</span><span class=nf>QueryMultipleAsync</span><span class=p>(</span><span class=n>sql</span><span class=p>,</span>
                           <span class=k>new</span>
                           <span class=p>{</span>
                               <span class=n>userId</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>UserId</span><span class=p>,</span>
                               <span class=n>pageSize</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>PageSize</span><span class=p>,</span>
                               <span class=n>startIndex</span>
                           <span class=p>}))</span>
                <span class=p>{</span>
                    <span class=n>result</span><span class=p>.</span><span class=n>Meta</span><span class=p>.</span><span class=n>TotalItems</span> <span class=p>=</span> <span class=k>await</span> <span class=n>multi</span><span class=p>.</span><span class=n>ReadFirstAsync</span><span class=p>&lt;</span><span class=kt>long</span><span class=p>&gt;();</span>
                    <span class=n>result</span><span class=p>.</span><span class=n>Items</span> <span class=p>=</span> <span class=k>await</span> <span class=nf>ParseObservables</span><span class=p>(</span><span class=k>await</span> <span class=n>multi</span><span class=p>.</span><span class=n>ReadAsync</span><span class=p>&lt;</span><span class=kt>dynamic</span><span class=p>&gt;());</span>
                <span class=p>}</span>
            <span class=p>}</span>

            <span class=k>return</span> <span class=k>new</span> <span class=nf>GetObservablesQueryResult</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=c1>// Вспомогательные методы маппинга данных</span>

    <span class=p>}</span>
<span class=p>}</span></code></pre></div><p>А а в соседней директории был какой-нибудь такой код:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=csharp><span class=c1>// Аналогичный &#34;заголовок&#34;</span>

<span class=k>public</span> <span class=k>async</span> <span class=n>Task</span><span class=p>&lt;</span><span class=n>GetObservablesBySearchQueryResult</span><span class=p>&gt;</span> <span class=nf>Handle</span><span class=p>(</span><span class=n>GetObservablesBySearchQuery</span> <span class=n>request</span><span class=p>,</span>
    <span class=n>CancellationToken</span> <span class=n>cancellationToken</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>var</span> <span class=n>startIndex</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>PageSize</span> <span class=p>*</span> <span class=p>(</span><span class=n>request</span><span class=p>.</span><span class=n>PageIndex</span> <span class=p>-</span> <span class=m>1</span><span class=p>);</span>
    <span class=k>const</span> <span class=kt>string</span> <span class=n>sql</span> <span class=p>=</span> <span class=s>@&#34;select o.observable_id, obs.user_id
                         from observers o
                            inner join observables obs on obs.id = o.observable_id
                         where o.user_id = @userId and not is_deleted
                         limit @pageSize offset @startIndex&#34;</span><span class=p>;</span>

    <span class=kt>var</span> <span class=n>result</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ObservablesQueryResultDto</span> <span class=p>{</span> <span class=n>Meta</span> <span class=p>=</span> <span class=k>new</span> <span class=n>MetaDataDto</span> <span class=p>{</span> <span class=n>CurrentPage</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>PageIndex</span><span class=p>,</span> <span class=n>PageSize</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>PageSize</span> <span class=p>}</span> <span class=p>};</span>

    <span class=k>using</span> <span class=p>(</span><span class=kt>var</span> <span class=n>connection</span> <span class=p>=</span> <span class=k>new</span> <span class=nf>NpgsqlConnection</span><span class=p>(</span><span class=n>_options</span><span class=p>.</span><span class=n>Value</span><span class=p>.</span><span class=n>ConnectionString</span><span class=p>))</span>
    <span class=p>{</span>
        <span class=k>await</span> <span class=n>connection</span><span class=p>.</span><span class=nf>OpenAsync</span><span class=p>(</span><span class=n>cancellationToken</span><span class=p>);</span>
        <span class=k>using</span> <span class=p>(</span><span class=kt>var</span> <span class=n>multi</span> <span class=p>=</span> <span class=k>await</span> <span class=n>connection</span><span class=p>.</span><span class=nf>QueryMultipleAsync</span><span class=p>(</span><span class=n>sql</span><span class=p>,</span>
                   <span class=k>new</span>
                   <span class=p>{</span>
                       <span class=n>userId</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>UserId</span><span class=p>,</span>
                       <span class=n>pageSize</span> <span class=p>=</span> <span class=m>100</span><span class=p>,</span>
                       <span class=n>startIndex</span>
                   <span class=p>}))</span>
        <span class=p>{</span>
            <span class=n>result</span><span class=p>.</span><span class=n>Items</span> <span class=p>=</span> <span class=k>await</span> <span class=nf>ParseObservables</span><span class=p>(</span><span class=k>await</span> <span class=n>multi</span><span class=p>.</span><span class=n>ReadAsync</span><span class=p>&lt;</span><span class=kt>dynamic</span><span class=p>&gt;(),</span> <span class=n>request</span><span class=p>.</span><span class=n>Search</span><span class=p>);</span>
            <span class=n>result</span><span class=p>.</span><span class=n>Meta</span><span class=p>.</span><span class=n>TotalItems</span> <span class=p>=</span> <span class=n>result</span><span class=p>.</span><span class=n>Items</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=k>new</span> <span class=nf>GetObservablesBySearchQueryResult</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
<span class=p>}</span>

<span class=c1>// Аналогичный &#34;футер&#34;</span></code></pre></div><p>А в "двоюродной" директории был такой код:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=csharp><span class=k>namespace</span> <span class=nn>ProjectE.Share.Api.Controllers.Commands.UpdateObserverCustomData</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>class</span> <span class=nc>UpdateObserverCustomDataCommandHandler</span> <span class=p>:</span> <span class=n>IRequestHandler</span><span class=p>&lt;</span><span class=n>UpdateObserverCustomDataCommand</span><span class=p>,</span> <span class=n>UpdateObserverCustomDataCommandResult</span><span class=p>&gt;</span>
    <span class=p>{</span>

        <span class=c1>// Аналогичный &#34;заголовок&#34;</span>

        <span class=k>public</span> <span class=k>async</span> <span class=n>Task</span><span class=p>&lt;</span><span class=n>UpdateObserverCustomDataCommandResult</span><span class=p>&gt;</span> <span class=nf>Handle</span><span class=p>(</span><span class=n>UpdateObserverCustomDataCommand</span> <span class=n>command</span><span class=p>,</span> <span class=n>CancellationToken</span> <span class=n>cancellationToken</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=kt>var</span> <span class=n>observable</span> <span class=p>=</span> <span class=k>await</span> <span class=n>_unitOfWork</span><span class=p>.</span><span class=n>ObservableRepository</span><span class=p>.</span><span class=nf>GetObservableByUserId</span><span class=p>(</span><span class=n>command</span><span class=p>.</span><span class=n>UserId</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>observable</span> <span class=p>==</span> <span class=k>null</span><span class=p>)</span> <span class=k>return</span> <span class=k>new</span> <span class=nf>UpdateObserverCustomDataCommandResult</span><span class=p>(</span><span class=n>CustomStatusCodes</span><span class=p>.</span><span class=n>NotFoundUserAccount</span><span class=p>,</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=s>&#34;Not found user observable account.&#34;</span> <span class=p>});</span>
            <span class=kt>var</span> <span class=n>result</span> <span class=p>=</span> <span class=k>await</span> <span class=nf>ChangeObserverCustomName</span><span class=p>(</span><span class=n>observable</span><span class=p>,</span> <span class=n>command</span><span class=p>.</span><span class=n>CustomName</span><span class=p>,</span> <span class=n>command</span><span class=p>.</span><span class=n>InviteId</span><span class=p>,</span> <span class=n>cancellationToken</span><span class=p>);</span>

            <span class=k>if</span> <span class=p>(!</span><span class=n>result</span><span class=p>)</span>
                <span class=n>_logger</span><span class=p>.</span><span class=nf>LogError</span><span class=p>(</span><span class=s>$&#34;Can&#39;t change observer #</span><span class=p>{</span><span class=n>command</span><span class=p>.</span><span class=n>InviteId</span><span class=p>}</span><span class=s> custom name&#34;</span><span class=p>);</span>

            <span class=k>return</span> <span class=k>new</span> <span class=nf>UpdateObserverCustomDataCommandResult</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=c1>// Аналогичный &#34;футер&#34;</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=k>namespace</span> <span class=nn>ProjectE.Share.Db.Repositories</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>class</span> <span class=nc>ObservableRepository</span> <span class=p>:</span> <span class=n>IObservableRepository</span>
    <span class=p>{</span>

        <span class=k>public</span> <span class=k>async</span> <span class=n>Task</span><span class=p>&lt;</span><span class=n>Observable</span><span class=p>&gt;</span> <span class=nf>GetObservableByUserId</span><span class=p>(</span><span class=kt>int</span> <span class=n>userId</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=k>return</span> <span class=k>await</span> <span class=n>_context</span><span class=p>.</span><span class=n>Set</span><span class=p>&lt;</span><span class=n>Observable</span><span class=p>&gt;()</span>
                <span class=p>.</span><span class=nf>Include</span><span class=p>(</span><span class=n>o</span> <span class=p>=&gt;</span> <span class=n>o</span><span class=p>.</span><span class=n>Invites</span><span class=p>)</span>
                    <span class=p>.</span><span class=nf>ThenInclude</span><span class=p>(</span><span class=n>o</span><span class=p>=&gt;</span><span class=n>o</span><span class=p>.</span><span class=n>Status</span><span class=p>)</span>
                <span class=p>.</span><span class=nf>Include</span><span class=p>(</span><span class=n>o</span> <span class=p>=&gt;</span> <span class=n>o</span><span class=p>.</span><span class=n>Observers</span><span class=p>)</span>
                <span class=p>.</span><span class=nf>SingleOrDefaultAsync</span><span class=p>(</span><span class=n>o</span> <span class=p>=&gt;</span> <span class=n>o</span><span class=p>.</span><span class=n>UserId</span> <span class=p>==</span> <span class=n>userId</span><span class=p>);</span>
        <span class=p>}</span>

    <span class=p>}</span>
<span class=p>}</span></code></pre></div><p>Тут надо обратить внимание на то, что доступ к данным в двух классах содержался в строковых константах с SQL-ем, а в одном - в LINQ-выражении.</p><p>Соотвественно, из-за этой размазанности логики доступа к данным вкупе с отсутствием тестов баги из серии "забыли поправить SQL в одном из слайсов" были у нас практически в каждом изменении.</p><p>MediatR же на этом фоне был мелким раздражителем, который приводил к:</p><div class="olist arabic"><ol class=arabic><li>Усложнению навигации по коду - вместо прыжка через метод, приходилось выполнять поиск по команде;</li><li>Необходимости на каждую операцию заводить по этой команде и её результату, даже если на вход подётся один int, а на выход идёт один boolean;</li></ol></div><p>После двух месяцев страданий, у меня родилась гениальная идея:</p><div class=image-block><img src=/drafts/project-e-retro/images/the-idea.png alt="the idea"></div><aside class=sidebar><h6 class=block-title>Что я вынес для себя</h6><div class="olist arabic"><ol class=arabic><li><a href=https://www.martinfowler.com/bliki/MonolithFirst.html>Фаулер</a>, <a href=https://www.oreilly.com/library/view/building-microservices/9781491950340/>Ньюман</a> и <a href=https://microservices.io/post/microservices/patterns/2020/10/18/microservices-are-a-mistake.html>Ричардсон</a> прав и проекты надо начинать с монолита;</li><li>Брать на поддержку проекты без тестов только при условии, что каждая задача на разработку начинается с покрытия тестами релевантного кода сколько бы это не стоило.</li><li>Мне вертикальная архитектура не подходит, можно на неё больше не смотреть.</li></ol></div></aside></section></section><section class="doc-section level-1"><h2 id=_история_продажи_реинжиниринга><a class=link href=#_история_продажи_реинжиниринга>История продажи реинжиниринга</a></h2><p>На самом деле идея перевести проект на Kotlin у меня появилась с самого начала, так как я сам специализируюсь на JVM и у меня была крутая команда, а найти адекватного специалиста по .net не получалось.
Но первое время дело дальше разговоров не шло.</p><p>Однако за два месяца активных работ (точнее попыток активной работы) не только я понял, что так продолжаться дальше не может, но и РП.
И 5 августа в треде о том, что уже второй дотнетчик делает задачи слишком долго, она написала:</p><div class=quote-block><blockquote><p>А как crazy idea - Леш, а переписать все на джава это сколько долго?</p></blockquote></div><p>Я ушёл, посчитал количество таблиц и эндпоинтов, просуммировал их, получил ~120, добавил +/- 50% и ответил: 60 - 180 человеко/дней.</p><p>Затем, 11 августа я написал РП такое сообщение:</p><div class=quote-block><blockquote><p>Чёт не спится:)
Мне идея переписать на <s>Джаве</s> Котлине кажется всё более разумной и реальной.
Из оценки в 100 дней - 50% это покрытие автоматическими тестами, что надо делать в любом случае, чтобы не помереть под регрессиями.
&lt;…​>
ну и у нас ещё есть переезд на свежий дотнет, который XXX оценил в 8 дней, и без тестов это скорее всего оптимистичная оценка.
Короч давай продавать эту авантюру заказчику - будет страшно интересно :troll: но всё закончится хорошо и если начнём в августе - к НГ уже будут видны результаты в скорости и качестве работы</p></blockquote></div><p>Затем, 14 августа РП написала, что заказчик готов выслушать наше предложение и мы назначили встречу.</p><p>К встрече я составил подробный план реинжиниринга и подготовил презентацию, которая содержала:</p><div class="olist arabic"><ol class=arabic><li>"Погоны" - мой опыт, три успешных кейса реинжиниринга схожего масштаба, работу над Эргономичным подходом;</li><li>Вышеописанные проблемы проекта.
При том приземлённые на конкретные цифры - сколько заняли конкретные задачи и сколько обычно занимаю аналогичные задачи, к каким конкретным багам привели эти проблемы, в целом статистику по багам в Проекте Э и других моих проектах;</li><li>Предлагаемые альтернативные технические решения;</li><li>Подробный план выполнения реинжиниринга.</li></ol></div><p>Приведя аргументы в пользу того, что реинжиниринг в принципе надо делать, я закинул идею заодно поменять и стек и обосновал это тем, что разница в трудозатратах не такая большая, а в сроках и цене на самом деле будет выигрыш за счёт наличия хороших кадров внутри компании.</p><p>И в конце показал план выполнения реинжиниринга, суть которого сводилась к: "Для вас эти работы будут проявляться только в том, что скорость разработки будет постепенно расти, а количество багов - падать".</p><p>Заказчик сказал, что очень интересно и надо подумать.
И ушёл.
На месяц с лишним.</p><p>А 23 сентября РП и аккаунт на встрече с топ-менеджментом заказчика договорились о старте работ по реинжинирингу.</p><aside class=sidebar><h6 class=block-title>Что я вынес для себя</h6><p>При написании этого поста я прямым текстом спросил у заказчика о том, что повлияло на его положительное решение и вот его ответ:</p><div class=quote-block><blockquote><p>В первую очередь сроки реализации доработок для старой архитектуры, а так же ваша презентация, она была довольно убедительной.
Желание повысить качество и быстродействие системы.</p></blockquote></div><p>Так же по моему опыту других проектов реинжиниринга отдельных подсистем, могу сказать, что бизнес идёт на это в двух случаях:</p><div class="olist arabic"><ol class=arabic><li>Очевидные операционные проблемы (производительность и стабильность), на которые жалуются клиенты и аргументированное обоснование того, что они не могут быть решены в рамках текущей архитектуры/технологий подсистемы;</li><li>Серьёзные изменения в требованиях, когда даже для заказчика очевидно, что это практически новая фича.</li></ol></div><p>Однако, я думаю что наличие проблем является необходимым, но недостаточным условием для того, чтобы бизнес согласился на реинжиниринг.
А вот достаточным условием является доверие владельца продукта к вам.
Он должен верить вашим словам о невозможности решить проблему локальными изменениями, верить что вы справитесь с задачей, верить что решение действительно исправит проблемы и верить, что вы действуете в его интересах.</p><p>На мой взгляд, презентация показалась убедительной (и соответсвенно это стоит взять в следующий раз в аналогичной ситуациии), потому что:</p><div class="olist arabic"><ol class=arabic><li>Я продемонстрировал собственную экспертизу - выраженную как в годах общего стажа, так и конкретных успешных кейсах выполнения реинжиниринга схожего масштаба;</li><li>Я был уверен в успехе и транслировал эту уверенность в метасообщении;</li><li>Я приземлил проблемы кодовой базы на конкретные задачи и цифры;</li><li>У меня было чёткое понимание того, что надо сделать по другому для решения проблем;</li><li>Я подготовил подробный план реинжиниринга;</li></ol></div></aside></section><section class="doc-section level-1"><h2 id=_планирование_реинжиниринга><a class=link href=#_планирование_реинжиниринга>Планирование реинжиниринга</a></h2><p>В первую очередь хочу предупредить: я не профессиональный менеджер и при планировании реинжиниринга импровизировал на ходу.
В моём случае это сработало и - если у вас нет другого варианта - вы можете пойти по тому же пути.
Если же вы сами эксперт в управлении - лучше придерживайтесь своего мнения:)
А если вы не эксперт, но можете делегировать эту работу эксперту - я бы на вашем месте так и сделал.</p><p>Импровизацию я начал с того, что попросил одного из разработчиков построить граф зависимостей оригинальной системы:</p><div class=image-block><img src=/drafts/project-e-retro/images/dependency-graph.png alt="dependency graph"></div><p>По факту это просто перечень REST-эндпоинтов (зелёные прямоугольники), RPC-эндпоинтов (синие) и обработчиков событий (красные) с обозначением вызовов, которые выполняются в процессе их исполнения.
Затем я пробежался по ним беглым взглядом и оценил в "майках" - XS (4 часа), S (8 часов), M (24 часа), L (40 часов), XL (80 часов) - и визуализировал "размерный ряд" насыщенностью цвета прямоугольника.</p><p>"Линейка" при этом была следующая:</p><div class="olist arabic"><ol class=arabic><li>XS - Один тривиальный SQL-запрос или RPC-вызов;</li><li>S - Два-три тривиальных SQL-запроса и/или обращения к другому сервису;</li><li>M - Бизнес-логика не влазит на один экран;</li><li>L - Применялся в двух случаях, если:<ol class=loweralpha type=a><li>Это был первый эндпоинт сервиса;</li><li>Я не мог сходу понять структуру и/или детали поведения эндпонита (понимая, при этом его эффекты);</li></ol></li><li>XL - у меня был только один.
Это был метод добавления событий, их было семь видов, каждый из которых мапился на таблицу с PostgreSQL-наследованием и имел не совпадающую по структуре входящую DTO-шку.</li></ol></div><p>Всего получилось работ на 354 xs или 177 человеко/дней.
Это соответствует верхней границе первоначальной оценки в 60-180 дней, однако включает в себя несколько новых фич на ~60 человеко/дней, которые ме успели сделать к моменту выполнения детальной оценки.</p><p>После этого я нарезал все прямоугольники на спринты.
Задачи в спринты я заталкивал довольно оптимистично, поэтому их получилось восемь штук по 160 человеко/часов в каждом - то есть всего 160 человеко/дней.
Но решил, что пускай мы лучше будем целиться в срок с запасом и первый план оставил таким.</p><p>Нарезку я делал интуитивно, руководствуясь следующими принципами (и балансируя между ними):</p><div class="olist arabic"><ol class=arabic><li>Набираем эндпоинты в спринты так, чтобы оценка задач в спринте примерно соответствовала суммарной мощности команды.
Тут мотивация очевидна, я думаю;</li><li>Идём снаружи внутрь - реинжинирим код только после того, как он перестаёт использоваться в оригинальной системе.
Это позволило нам, во-первых, не делать RPC-сервер в своей версии (который после перехода на монолит нам не понадобится), а, во-вторых, исключило вероятность того, что мы сломаем старый код не покрытый тестами;</li><li>Фокусируемся на том, чтобы максимально быстро заканчивать каждый микросервис.
То есть лучше за одну неделю сделать полностью один МС и за вторую полностью второй, чем за неделю сделать два МСа на 50% и за вторую неделю доделать их полностью.
Это позволило нам минимизировать сложность роутинга в каждый момент времени, быстрее освобождать ресурсы кластера и, главное, минимизировать время, когда с БД одновременно работает старый и новый бэк, что могло привести к неприятным неожиданностям.</li><li>Стараемся все эндпоинты на одном URL сделать за один спринт;
Для упрощения роутинга и минимизации времени, когда с одними и теми же данными работают оба бэка;</li><li>Эндпоинты на одном URL стараемся делать в таком порядке - GET, DELETE, PUT, POST.
Это позволио снизить вероятность поломки старого бэка, какой-то "не такой" записью;</li><li>Стараемся, чтобы над одним МСом (хотя бы в рамках спринта) работал только один человек.
Это позволило нам минимизировать конфликты слияния.</li></ol></div><aside class=sidebar><h6 class=block-title>Что я вынес для себя</h6><div class="olist arabic"><ol class=arabic><li>По возможности лучше делегировать планирование профессиональному управленцу;</li><li>Если делегировать невозможно - в аналогичном проекте я бы выполнил планирование также;</li><li>Мёрж конфликты - очень дорогая штука, один из самых кровавых стоил нам двух дней разработки.
Соответственно надо прикладывать максимум усилий по их исключению.</li></ol></div></aside></section><section class="doc-section level-1"><h2 id=_процесс_работы_команды><a class=link href=#_процесс_работы_команды>Процесс работы команды</a></h2><p>Про процесс особо рассказать нечего - всё было "как у всех" - псевдоскрам с двухнедельными спринтами и дейликами.</p><p>К началу каждого спринта у каждого разработчика был список эндпоинтов, который в идеале он должен был сделать за спринт.
При том, как правило, в спринт я набирал задачи очень оптимистично, и 100% выполнение плана было редкостью.</p><p>Сам процесс разработки у нас начинался очень хаотично, проходил разные стадии эволюции, но в итоге устаканился на таком:</p><div class="olist arabic"><ol class=arabic><li>Разработчик создаёт фича-ветку от мастера;</li><li>Разработчик реализует фичу и проходит ревью в ветке;</li><li>Фича-ветка мёржится в мастер;</li><li>Раз в спринт (7-ой из 10 день) объявляется код фриз;</li><li>QA начинает тестировать релиз на dev-стенде, мёржи новых фич в мастер запрещены;</li><li>На 10-ый день (или после того, как QA проверят весь релиз), на мастер вешается тег и тег заливается на stage-стенд, там гоняются автоматические тесты QA-команды;</li><li>Утром 11-ого дня спринта (или на следующий рабочий день, после заливки на стейдж) тег заливается на prod-стенд;</li><li>Код фриз снимается, запускается очередной спринт/релизный цикл.</li></ol></div><p>В конце очередного спринта я подбивал факт.
Первые спринтов 5-6 я действовал по принципу всё или ничего - фича переносится в факт только полностью и после того как пройдёт QA и окажется stage-стенде.</p><p>Мотивацией этому было то, что я очень боялся, что мы свалимся в имитацию бурной деятельности без видимых результатов для заказчика.
Однако такой подход привёл к тому, что у нас пару спринтов получилось 0 единиц сделанной работы и в целом видимая мощность команды сильно прыгала из-за чего сложно было понять попадаем ли мы в план.
Поэтому где-то в середине реинжиниринга я перешёл на пропорциональный перенос работ в план - субъективно определял по собственным ощущениям или ощущениям разработчика процент решения задачи и соответсвующий процент "майки" заносил в факт.</p><p>Другая техника, которой я боролся за минимизацию времени доведения задач до прода - дейлики.
И да, как и у всех - у нас были дейлики.</p><p>Но в отличие от всех <em>[команд, в котрых я работал]</em>, на дейликах мы рассказывали не кто чем занимался и будет заниматься, а выясняли кто что должен сделать чтобы каждая задача в процессе максимально быстро оказалась в проде.
И эта техника сработала в том плане, что мы весь реинжиниринг дейлики проводили в таком формате и все остались довольны.</p><p>Сложно сказать, чтобы было, если бы мы проводили обычные дейлики, но субъективно мне такой формат ближе (фокусом на достижении целей, а не максимизацией утилизации ресурсов) и для себя я выбрал этот формат дефолтным.</p><p>Так же стоит упомянуть о месте в котором мне просто повезло, а вам может не повезти.
Без каких-либо усилий с моей стороны, заказчик практически заморозил разработку бэка на время реинжиниринга и соответсвенно у нас не было цели, убегающий за горизонт.
В этот раз мне повезло, но в следующий раз я возьму этот вопрос на контроль.</p><aside class=sidebar><h6 class=block-title>Что я вынес для себя</h6><div class="olist arabic"><ol class=arabic><li>Спринты прекрасно работают для реинжиниринга, так как внём нет извечной проблемы, когда по среди спринта от заказчика прилетает горячий пирожок, который надо было сделать вчера;</li><li>Отслеживать прогресс надо процентами выполнения задач, а не штуками;</li><li>Дейлики по задачам мне подходят больше, чем дейлики по людям;</li><li>Важно приложить максимум усилий к заморозке разработки оригинальной кодовой базы, либо при каждой измененеии проговараривать с заказчиком как это повлияет на срок и бюджет реинжиниринга.</li></ol></div></aside></section><section class="doc-section level-1"><h2 id=_что_пошло_не_плану><a class=link href=#_что_пошло_не_плану>Что пошло не плану</a></h2><section class="doc-section level-2"><h3 id=_спринты><a class=link href=#_спринты>Спринты</a></h3><p>Первое что пошло не по плану - скорость работы команды в первые два спринта.
При оценке задач я ориентировался на среднюю скорость работы и не учёл несколько факторов осложнявших старт:</p><div class="olist arabic"><ol class=arabic><li>В новом проекте приходилось сетапать много "инфраструктурного" кода (например, запуск тестконтейнеров без поломки кэша контектсов) и решать уникальные задачи (например, работу с несколькими DataSource в Spring Data JDBC);</li><li>Команда видела C# в первый и для юниоров читать код на незнакомом языке было довольно сложно;</li><li>Команда в целом слабо ориентировалась в кодовой базе оригинального проекта;</li><li>Приходилось искать решения не типичных проблем из-за наследия .net-бэка (например, обработку CamelCase enum-ов в (де)сериализации DTO).</li></ol></div><p>Из-за этого за первые два спринта (или 25% времени) мы осилили сделать только 5% работы.
Поэтому после второго спринта пришлось сказать, что это была "разминка" и вот теперь оставшиеся 95% работы мы точно сделаем за 8 спринтов.
И в этот раз в целом всё пошло более-менее поплану и в эти 8 спринтов мы уложились, единственное что в последнем спринте одному разработчику пришлось устроить 24 часовой хакатон (по собственной инициативе).</p></section><section class="doc-section level-2"><h3 id=_тестирование><a class=link href=#_тестирование>Тестирование</a></h3><section class="doc-section level-3"><h4 id=_разработчиками><a class=link href=#_разработчиками>Разработчиками</a></h4><p>Вообще Эргономичный подход предполагает план тестирования.
Он пока что публично не описан, но очень кратко его можно описать следующими принципами:</p><div class="olist arabic"><ol class=arabic><li>Тестируется система в конфигурации максимально приближенной к боевой;
Мокаются только внешние и дорогие или нестабильные зависимости (например, внешний сервис отправки почты), и то на уровне HTTP.</li><li>Тесты взаимодействуют с системой в обход публичного API только в крайних случаях.
По умолчанию и сетап и действие и верификация выполняются через публичное API.</li><li>Тесты пишутся исходя из сценариев использования - каждый юзкейс в ТЗ, должен быть покрыть тестом;</li><li>Все задокументированные ошибки API должны быть покрыты тестами (тут, при необходимости, допускается использование моков);</li><li>В бизнес-логике (реализованной в ядре в чистых функциях без ввода-вывода) тестами должны быть покрыты все ветки.
Если бизнес-логика развесистая, её допустимо тестировать в обход публичного API и напрямую вызывать функции ядра.</li></ol></div><p>И в моей практике эти принципы работают очень хорошо - по статистике в моих проектах команда QA находит мажорные баги примерно раз в три месяца.
Под мажорными я понимаю баги, которые могли бы затронуть большинство пользователей.</p><p>Но в Проекте Э пришлось отойти от этих принципов.
И пожалеть об этом.</p><p>Честно говоря я уже не помню конкретных причин (дело было почти год назад), но я не стал в тестах поднимать контейнеры старого бэка.
Скорее всего из-за того что [быстро] не придумал как натравить старый бэк на БД, поднимаемой testconainers.</p><p>И из-за того, что мы шли снаружи внутрь и начинали с методов чтения, у нас не было ручек для сетапа фикстуры тестов и верификации через публичное API.
Поэтому тестировать я планировал не сценарии использования, а отдельные эндпоинты.</p><p>Соответственно, новый план тестирования был такой:</p><div class="olist arabic"><ol class=arabic><li>Сначала пишем тест на отдельный эндпоинт, который проходит на старом бэке, поднятом разработчиком руками;</li><li>Переводим тест на вызов нового бэка;</li><li>Выполняем реинжиниринг этого эндпоинта;</li></ol></div><p>Но практически сразу в этом плане обнаружилась дыра - как сетапить фикстуру?
Через публичное API нельзя, так как его не будет на новом бэке.
А через БД нельзя, так как было не понятно как натравить старый бэк на базу в testcontainers.</p><p>В итоге мы писали тесты сразу на отдельные эндпоинты в новом бэке и сетапили фикстуру SQL-скриптами.
А RPC-вызовы к старому бэку мокали.</p><p>Кроме того, из соображений минимизации сроков реинжиниринга, мы отказались от покрытия тестами негативных сценариев.</p><p>И за оба решения поплатились большим (84 штуки за 5.5 месяцев) количеством багов.
Большинство багов было связано с нарушением обратной совместимости, но были и баги в негативных сценариях и баги вида "тесты на метод А проходят, тесты на метод Б проходят, а вот когда фронт зовёт метод А, а потом метод Б - всё взрывается".</p><p>Баги обратной совместимости мы в конечном итоге победили такой схемой:</p><div class="olist arabic"><ol class=arabic><li>Перед старом работ над эндпоинтом, команда QA-пишет тест на структуру ответа в Postman;</li><li>В МР разработчик прикладывает два скриншота - как тест проходит с новым и старым бэком.</li></ol></div><p>Но, незадолго до введения этого правила я уволил стажёра (спойлер 😱), которая генеряла большинство таких багов, поэтому сложно сказать, что внесло больший вклад.</p><p>А ошибки в сценариях использования (как негативных, так и позитивных) мы сейчас постепенно изводим возвратом к принципам тестирования ЭП.</p><p>Так же мы отдельно поплатились за сетап БД SQL-скриптами.
Во-первых, изначально для моков старого бэка ответы генерировались из чёрт знает каких данных (текущего состояния БД на рабочей машине разработчика).
Соответственно, когда мы эти методы переносили в новый бэк, то для написания скриптов сетапа фикстуры приходилось героически определять входные данные, которые должны быть поданы в операцию чтобы получить заданный результат.</p><p>Второй проблемой, актуальной до сих пор стала хрупкость тестов.
В время реинжиниринга она проявлялась в том, что при переносе на новый бэк внутреннего эндпоинта приходилось прописывать скрипты сетапа БД для него во все тесты, в рамках которых этот эндпоинт вызывался.
А сейчас - при изменении схемы БД приходится править сетап фикстуры для множества тестов.
Но это мы потихоньку прибераем, переводя тесты на использование публичного API.</p><p>Первую проблему мы частично решили введением "эталонной БД" - взяли дамп с одного из стендов и для генерации мок-данных запускали бэк на нём.</p><p>А с хрупкостью тестов живём до сих пор, переводя их на публичное АПИ по мере появления проблем.</p></section><section class="doc-section level-3"><h4 id=_командой_qa><a class=link href=#_командой_qa>Командой QA</a></h4><p>План тестирования командой QA сводился к паре фраз: "Тестировать будем на дев стенде и стейдже. На деве - через Постаман, на стейдже - через МП".</p><p>Но тоже довольно быстро уткнулись в дыру в этом плане - как тестировать эндпоинт?</p><p>На момент начала реинжиниринга, бэк-команда видела проект в первый раз, а команды QA и мобильной разработки работали с ним четыре месяца.
В итоге определение сценариев, которые мог затронуть эндпоинт и тест кейсов, которыми его можно проверить превращалось в целую эпопею.</p><p>Эту проблему мы так и не решили до конца проекта реинжиниринга.
Буду благодарен, если расскажете в комментариях хороший способ её решения.</p></section></section><section class="doc-section level-2"><h3 id=_выгрузки><a class=link href=#_выгрузки>Выгрузки</a></h3><p>Я сильно ошибся в оценке реализации пары фич.
Это две схожие фичи в админке, которые позволяют просматривать списки пациентов и событий дневников.
Казалось бы - что там делать?</p><p>Проблема с ними была в том, что данные лежали по разным базам, данных планируется много (до десятков миллионов строк) и при этом надо обеспечить стандартные фичи - пагинацию, сортировку по любому полю и фильтрацию по любому набору полей.
Плюс по требованиям надо было обеспечить выгрузку в xlsx с лимитом на количество строк равным лимиту самого формата - чуть больше одного миллиона.
В итоге нам пришлось руками делать <a href=https://en.wikipedia.org/wiki/Block_nested_loop>block nested loop join</a>, о чём я чуть подробнее написал в <a href=https://azhidkov.pro/microposts/23/06/streaming-join/>отдельном микропосте</a>.</p><p>В результате вместо запланированных 104 часов на эту работу ушло 175.75 часов.</p></section><section class="doc-section level-2"><h3 id=_баги_net_бэка><a class=link href=#_баги_net_бэка>Баги .net-бэка</a></h3><p>При планировании я совсем не учитывал поддержку изначальной версии системы.
И хотя разработка была заморожена и новых фич мы не пилили - несколько раз в kotlin-команду прилетали старые баги оригинальной системы, которые проявились только после появления реальных пользователей.
Но нам повезло, багов было не много и они были простые и отъели не так много времени.</p></section><section class="doc-section level-2"><h3 id=_стажёр><a class=link href=#_стажёр>Стажёр</a></h3><p>По среди реинжиниринга мне пришлось уволить стажёра.
Вообще, положа руку на сердце, её надо было уволить намного раньше, но я всё давал шансы.
Пока она не пропала на несколько дней.
И даже тогда я дал ещё один шанс, но как только она тут же снова пропала - моё терпение лопнуло.</p><p>Удивительно (на самом деле нет) - но на скорость работы команды это никак не повлияло.
Видимо та польза, которую она приносила, полностью компесировалась проблемами которые, которые она порождала в процессе работы - мучительно долгие ревью, больше количество ошибок, иногда код который проходил только тесты, написанные для подтверждения его работоспосбоности, а не подтверждения его соответствия требованиям.</p><aside class=sidebar><h6 class=block-title>Что я вынес для себя</h6><div class="olist arabic"><ol class=arabic><li>Первые один-два спринта будут блинами комом и надо быть готовым (заложить в план) к тому, что их цели не будут выполнены даже на 50%;</li><li>Эндпоинты, которые на глаз оцениваются более чем в три дня работы надо всё-таки детально проектировать и декомпозировать до подзадач размером до одного дня;</li><li>Надо придерживаться принципов тестирования Эргономичного подхода - писать тесты на сценарии использования, писать тесты через публичное API, покрывать тестами негативные кейсы;</li><li>Перед началом реинжиниринга надо построить карту, по которой можно быстро определять тесткейсы, которые позволят протестировать каждый эндпоинт;</li><li>Даже если заморозить разработку оригинальной системы, она всё равно может потребовать ресурсов на поддержку;</li><li>Перед стартом проекта надо подумать о своей команде - всем ли я доверяю, все ли дойдут до конца, планируются ли у кого-то отпуск?
Выявленные риски стоит заложить в план, в виде люфта на решение проблем и заранее продумать план, что делать если они выстрелят;</li></ol></div></aside></section></section><section class="doc-section level-1"><h2 id=_факапы_в_проде><a class=link href=#_факапы_в_проде>Факапы в проде</a></h2><p>Для начала надо прояснить что я имею ввиду под факапом и продом.</p><p>Под факапом я понимаю проблему конечных пользователей, с которой к нам пришёл заказчик.</p><p>Касательно прода - это окружение, которым пользуется заказчик и живые пользователи, и у нас это не так страшно, как может показаться.
Первые два наиболее багоёмких месяца работы реальных пользователей у нас не было - приложением пользовались буквально несколько человек со стороны заказчика и близких ему врачей.</p><p>Живые пользователи, в количестве ста человек к нам пришли в начале января.
И далее был линейный рост примерно по сто человек в месяц.</p><section class="doc-section level-2"><h3 id=_приглашение_в_наблюдатели><a class=link href=#_приглашение_в_наблюдатели>Приглашение в наблюдатели</a></h3><p>Первый факап в проде у нас случился после первого же релиза нового бэка.</p><p>У нас есть функциональность приглашения пользователя в наблюдатели по емейлу.
В оригинальном бэке она работала так:</p><div class="olist arabic"><ol class=arabic><li>Сервис share идёт в сервис accounts и смотрит зарегестрирован ли пользователь с таким емейлом;</li><li>Сервис share публикует :[line-through]<mark>событие</mark> команду SendAccountShareInviteLinkIntegrationEvent, куда передаёт флаг accountExists</li><li>Сервис email-notifications формирует ссылку с этим флагом и отправляет письмо на указанный емейл;</li><li>Пользователь проходит по ссылке;</li><li>Фронт смотрит на флаг и либо редиректит пользователя на форму ввода пароля, либо на главную/форму аутентификации.</li></ol></div><p>И при реинжиниринге во входящей DTO-ке разработчик потерял "s" в имени флага.
Занавес.</p><p>Проблема ещё усугубилось тем, что в это же время и в этой же функциональности нашли и починили баг на фронте, и мы очень долго разводили кто где ошибся.</p></section><section class="doc-section level-2"><h3 id=_поиск_наблюдаемого><a class=link href=#_поиск_наблюдаемого>Поиск наблюдаемого</a></h3><p>Второй факап у нас случился уже ближе к концу реинжиниринга.</p><p>У врача есть возможность искать своих пациентов.
В старом бэке поиск выполнялся и по имени и по логину.
А при реинжиниринге потеряли поиск по имени.
Занавес.</p></section><section class="doc-section level-2"><h3 id=_обработка_протухших_токенов><a class=link href=#_обработка_протухших_токенов>Обработка протухших токенов</a></h3><p>Последний релиз реинжиниринга у нас тоже отметился факапом.</p><p>МП в плане обновления токена, МП у нас реактивные - рефрешат его по 401-ой ошибке, а не заранее.
А при реализации рефреша токена разработчик пропустил, что библиотека парсина JWT будет выбрасывать исключение и в случае валидного, но протухшего токена.
А все неожиданные исключения у нас мапятся на 500.
Занавес.</p><hr><p>Примечательно, что всех трёх факапов можно было бы избежать, если бы мы придерживались принципам тестирования ЭП.</p><p>Факап с приглашением бы отловили когда поняли, что тесты двух юз кейсов должны отличаться флагом в ссылке в письме, добавили бы забытую проверку и обнаружили, что один из них не проходит.</p><p>Факап с поиском очевидным образом бы отловил тест кейса поиска по имени.</p><p>Факап с протухшими токенами бы отловил тест кейса обработки протухшего токена.</p><aside class=sidebar><h6 class=block-title>Что я вынес для себя</h6><div class="olist arabic"><ol class=arabic><li>И снова - надо придерживаться принципов тестирования Эргономичного подхода.</li></ol></div></aside></section></section><section class="doc-section level-1"><h2 id=_результаты><a class=link href=#_результаты>Результаты</a></h2><p>Итого, проект реинжиниринга длился ~5.5 месяцев с 1 ноября 2022 года по 17 апреля 2023 года.
Общие трудозатраты на разработку, поддержку и коммуникации составили 1402.75 часа (175 человеко/деней).</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Точность попадания в подробную оценку может показаться феноменальной - 175 против 177 дней.
Однако на самом деле оценка была несколько завышена относительно идеальной - за 175 дней помимо того, что было запланировано, мы выполнили ещё и реинжиниринг сервисов точек продаж и устройств, которые я не учитывал в подробной оценке.</p></aside><p>В результате у нас получилось:</p><div class="olist arabic"><ol class=arabic><li>23,944 строк кода;</li><li>730 классов;</li><li>234 теста (преимущественно интеграционных);</li><li>100% покрытие эндпоинтов тестами;</li><li>93.2% покрытия строк кода тестами;</li><li>1:30 минут полное время сборки, включая все тесты кода, тесты архитектуры, detekt, сборку и верификацию покрытия кода;</li><li>81 баг, который нашли мы или QA;</li><li>3 бага, которые нашли пользователи или заказчик.</li></ol></div><p>Стоило ли оно того?
Безусловно да.</p><p>Через три месяца после завершения реинжиниринга я проанализировал задачи в Jira и написал об этом <a href=https://azhidkov.pro/microposts/23/07/project-e-retro-v2/>подробный пост</a>.
Главный вывод этого поста: после завершения реинжиниринга мы стали работать в два раза быстрее, в том числе за счёт того, что стали допускать в два раза меньше ошибок.</p><aside class=sidebar><h6 class=block-title>Что я вынес для себя</h6><div class="olist arabic"><ol class=arabic><li>Проекты до человеко-года на МСА будут дороже минимум на 30%, аналогичных проектов на монолите;</li><li>Автоматизация тестирования как минимум в двое сокращает количество ошибок;</li><li>При наличии сильного лида, замотивированность разработчиков важнее квалификации.</li></ol></div></aside></section><section class="doc-section level-1"><h2 id=_заключение><a class=link href=#_заключение>Заключение</a></h2><p>Какие выводы можно сделать из этой истории?</p><div class="olist arabic"><ol class=arabic><li>Главный вывод для меня - по Эргономичному подходу можно успешно делать проекты в 1+ человеко/год;</li><li>Если вы хотите, чтобы ваши последователи без проблем убедили заказчика в том что вы не справились со своей задачей, то:<ol class=loweralpha type=a><li>начните небольшой проект с микросервисной архитектуры и сделайте её такой, чтобы каждая операция делала по 2-3 синхронных вызова в другие сервисы;</li><li>не напишите ни одного теста</li><li>примените вертикальную архитектуру;</li></ol></li><li>Если же вы хотите, чтобы ваши последователи были вам благодарны, то:<ol class=loweralpha type=a><li>Прислушайтесь к <a href=https://www.martinfowler.com/bliki/MonolithFirst.html>Фаулеру</a>, <a href=https://www.oreilly.com/library/view/building-microservices/9781491950340/>Ньюману</a> и <a href=https://microservices.io/post/microservices/patterns/2020/10/18/microservices-are-a-mistake.html>Ричардсону</a> и начните новый проект с монолита.
А чтобы упростить переход на МСА (или вообще избежать его) - прислушайтесь к <a href="https://www.youtube.com/watch?v=5OjqD-ow8GE">Брауну</a> и <a href=https://azhidkov.pro/posts/22/08/ergonomic-decomposition/#_пакетирование_по_объектам_ака_объектно_ориентированная_декомпозиция>мне</a> и сделайте его модульным.</li><li>Покройте 100% своих эндпоинтов тестами.
А чтобы они были показательными и стабильными - прислушайтесь к <a href=https://martinfowler.com/articles/mocksArentStubs.html>Фаулеру</a>, <a href=https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html>Мартину</a>, <a href="https://youtu.be/z9quxZsLcfo?t=1270">Беку</a>, <a href="https://www.ozon.ru/product/printsipy-yunit-testirovaniya-horikov-vladimir-553281795/?sh=VykwEHH-fw">Хорикову</a> и <a href=https://azhidkov.pro/posts/21/03/210321-project-l-testing/>мне</a> и пишите их в стиле <a href=https://habr.com/ru/companies/jugru/articles/571126/>классической школы</a></li><li>Возьмите простую архитектуру - хотя бы слоёную (внутри модулей).
А чтобы упростить тестирование и понимание кода - лучше возьмите функциональную/неизменяемую архитектуру (описание <a href=https://habr.com/ru/articles/571668/>без монад</a> и <a href=https://habr.com/ru/companies/jugru/articles/341460/>с ними</a>, <a href=https://azhidkov.pro/posts/21/10/211018-ergo-approach-post/#_структура_реализации_операции_системы>моя версия</a>).</li></ol></li><li>Реализовать свою мечту и переписать чужой легась - можно;</li><li>Попасть в бюджет при этом - тоже можно;</li><li>Чтобы убедить владельца продукта в необходимости реинжиниринга, надо:<ol class=loweralpha type=a><li>Заслужить его доверие;</li><li>Оперировать понятными для него фактами;</li><li>Приземлять проблемы легаси системы на деньги;</li><li>Показать, что вы понимаете в чём конкретно заключены проблемы легаси системы, что надо сделать по другому, чтобы их решить.</li></ol></li><li>Простая методика оценки работ посредством умножения на константу количества таблиц и эндпоинтов хорошо работает для типовых crud-приложений;</li><li>При планировании надо учитывать, что скорость команды на старте будет очень низкой, но будет постоянно расти;</li><li>Первый год разработки на микросервисах дороже разработки на монолите.
Минимум на 30%;</li><li>Автоматизация тестирования снижает количество багов и трудозатрат на их устранение.
Минимум в два раза;</li><li>Мотивация команды имеет огромное влияние на трудозатарты.
От 30% дополнительных трудозатрат в случае низкой мотивации.</li></ol></div><p>В следующем посте я расскажу как мы всё это делали фактически:</p><div class="olist arabic"><ol class=arabic><li>как структурировали приложение;</li><li>как боролись за низкую сцепленность;</li><li>как тестировали;</li><li>как эволюционировала наша модель ветвления;</li><li>как деплоились;</li><li>какие были технические сложности и как мы их преодолевали;</li><li>какие факапы у нас были в проде.</li></ol></div></section></article></section></div></main><script src=/js/app.js></script></body></html>