<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Рациональный подход к декомпозиции систем на модули или микросервисы - Алексей Жидков"><meta property="og:description" content="Рациональный подход к декомпозиции систем на модули или микросервисы"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/drafts/effects-diagram/ood-decomposition-v4/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/drafts/effects-diagram/ood-decomposition-v4/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/drafts/effects-diagram/ood-decomposition-v4/><title>Рациональный подход к декомпозиции систем на модули или микросервисы - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/drafts/effects-diagram/ood-decomposition-v4/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Рациональный подход к декомпозиции систем на модули или микросервисы</h1></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><section class="doc-section level-1"><h2 id=_чего_от_разработки_по_хотят_разработчики_продакты_и_владельцы_бизнеса><a class=link href=#_чего_от_разработки_по_хотят_разработчики_продакты_и_владельцы_бизнеса>Чего от разработки ПО хотят разработчики, продакты и владельцы бизнеса?</a></h2><p>Одного и того же - побольше дофаминчика (гормон счастья), поменьше кортизольчика (гормон стресса).
При том источники и дофамина, и кортизола у них одни и те же.
Дофамин вырабатывается, когда фичи выпускаются в срок и без багов, а кортизол - когда сроки срываются и вылазят баги и регрессии.
Бизнесу будет ближе финансовая версия - срыв сроков и баги очевидным образом приводят к увлечению стоимости разработки.
Что приводит к выбросу кортизола уже у владельцев.</p></section><section class="doc-section level-1"><h2 id=_как_обеспечить_высокий_уровень_дофамина_всей_команды><a class=link href=#_как_обеспечить_высокий_уровень_дофамина_всей_команды>Как обеспечить высокий уровень дофамина всей команды?</a></h2><p>Для того чтобы поддерживать высокий уровень дофамина и низкий уровень кортизола у всех участников процесса, нам необходимо декомпозировать системы на модули.
Декомпозиция помогает обеспечить высокую скорость и качество разработки за счёт:</p><div class=ulist><ul><li>Ограничения объёма кода, который необходимо изучить и адаптировать к изменениям в требованиях;</li><li>Исключения конфликтов при параллельной разработке независимых функций системы;</li><li>Создания возможности независимого выпуска и развёртывания отдельных функций системы.</li></ul></div><p>Однако, этого можно достичь, только в том случае, если получившиеся модули обладают высокой функциональной связанностью и низкой сцепленностью.</p><p>(<mark>todo: картинка</mark>)</p><p>Кроме того, для максимизации <s>выброса дофамина</s> скорости разработки и минимизации <s>выброса кортизола</s> стоимости разработки, необходимо чтобы сама работа по декомпозиции системы проходила быстро и давала качественные результаты.</p></section><section class="doc-section level-1"><h2 id=_как_обеспечить_высокий_уровень_дофамина_всей_команды_при_выполнении_декомпозиции><a class=link href=#_как_обеспечить_высокий_уровень_дофамина_всей_команды_при_выполнении_декомпозиции>Как обеспечить высокий уровень дофамина всей команды при выполнении декомпозиции?</a></h2><p>А для того чтобы эта работа проходила быстро и давала качественные результаты, необходимо, чтобы она была структурирована и стандартизирована.
Таким образом необходим некий рациональный подход к декомпозиции.
И тут в нашей индустрии проблемы.</p><p>По моему опыту, в ВУЗах декомпозиции либо не обучают совсем, либо обучают монструозным и фактически устаревшим методологиям вроде RUP-а.
А по мнению Джона Остерхаута в США дела обстоят так же:</p><div class=quote-block><blockquote><p>Problem decomposition is the central design task that programmers face every day, and yet, other than the work described here, I have not been able to identify a single class in any university where problem decomposition is a central topic.
We teach for loops and object-oriented programming, but not software design.</p><p>Декомпозиция - это центральная задача проектирования, с которой программисты сталкиваются каждый день, и все же, кроме работы, описанной здесь, я не смог определить ни одного курса ни в одном университете, где декомпозиция является центральной темой.
Мы учим циклам и объектно-ориентированному программированию, но не проектированию ПО.</p><footer>— <cite>John Ousterhout, A Philosophy of Software Design</cite></footer></blockquote></div><p>Из-за этого, в большинстве команд, которые я видел в последние годы, проектирование и декомпозиция заключалась в паре часов несистематизированного рисования прямоугольников и стрелок одним-двумя разработчиками.
А полноценное проектирование и декомпозицию я видел в последний раз в 2005 году и они заняли несколько месяцев.</p><p>Для того чтобы обеспечить высокий уровень дофомина и на этапе проектирования и декомпозиции и на этапе последующей реализации, нам необходим подход к декомпозиции, который:</p><div class="olist arabic"><ol class=arabic><li>Вообще есть;</li><li>Прост в изучении;</li><li>Прост в исполнении;</li><li>Даёт хорошие результаты вне зависимости от исполнителя;</li></ol></div><p>Это и будет тем самым рациональным подходом к декомпозиции, который нам необходим.</p></section><section class="doc-section level-1"><h2 id=_а_что_не_так_с_классикой><a class=link href=#_а_что_не_так_с_классикой>А что не так с классикой?</a></h2><p>У опытного разработчика, тут может возникнуть вопрос: "Зачем нужен очередной велосипед? Этих подходов к декомпозиции - тысячи!".
Я честно проделал домашнюю работу, и перед тем как придумать собственный велосипед изучил более двадцати различных подходов к декомпозиции начиная с 60-ых годов, многое взял себе, но не один из них мне не удалось положить свою на каждодневную практику.</p><p>Подробно основные существующие подходы я рассмотрел в <a href=https://azhidkov.pro/posts/22/08/ergonomic-decomposition/>отдельном посте</a> и здесь приведу только причины, по которым я не смог взять их в свою практику:</p><div class="olist arabic"><ol class=arabic><li>Декомпозиция по слоям не масштабируется и даёт плохие результаты с точки зрения связанности и сцепленности;</li><li>Декомпозиции по фичам и компонентам плохо описаны, и при попытке их применения возникает множество вопросов, на которые у источников нет ответов.
Я нашёл эти ответы самостоятельно и у меня получился подход к декомпозиции на базе эффектов;</li><li>DDD сложен и в изучении, и применении.
Мне не разу ни удалось "продать" DDD хотя бы РП, фронт-разработчикам, аналитикам и QA-инженерам в собственной команде.
Кроме того, наличие "на борту" экспертов предметной области, критически важное для DDD, в моей практике является скорее исключением, чем правилом.</li></ol></div><p>Изучением и апробированием классики я занимался 6 лет - с 2014 до 2020 года.
Так и не найдя внятного ответа на вопрос "Как мне декомпозировать систему?", во второй половине 2020 я начал искать собственный подход к декомпозиции и написал разделы книги о <a href=https://azhidkov.pro/book/ergo/#_таблица_эффектов>таблице эффектов</a> и <a href=https://azhidkov.pro/book/ergo/#_принципы_проектирования_системы>компонентах</a> (осторожно, устаревшие и нередактированные черновики).
К марту 2021 года я придумал <a href=https://azhidkov.pro/posts/21/03/250326-project-decomposiotion/>объединить их в один граф</a> и в итоге это превратилось в декомпозицию на базе эффектов.</p></section><section class="doc-section level-1"><h2 id=_декомпозиция_на_базе_эффектов><a class=link href=#_декомпозиция_на_базе_эффектов>Декомпозиция на базе эффектов</a></h2><section class="doc-section level-2"><h3 id=_подход_проверен_и_обоснован_научно><a class=link href=#_подход_проверен_и_обоснован_научно>Подход проверен и обоснован научно</a></h3><p>Прежде чем перейти к самому подходу, хочу подчеркнуть, что он научно обоснован.
Есть три научных статьи, описывающих такой же по сути подход:</p><div class=ulist><ul><li><a href=https://www.researchgate.net/publication/283566310_Improving_Design_Decomposition>Improving Design Decomposition</a>;</li><li><a href=https://www.researchgate.net/publication/326260296_Functional_Decomposition_for_Software_Architecture_Evolution>Functional Decomposition for Software Architecture Evolution</a>;</li><li><a href=https://www.researchgate.net/publication/327229270_Identifying_Microservices_Using_Functional_Decomposition_4th_International_Symposium_SETTA_2018_Beijing_China_September_4-6_2018_Proceedings>Identifying Microservices Using Functional Decomposition</a>.</li></ul></div><p>Я не буду здесь подробно останавливаться на этих статьях - они в открытом доступе и заинтересованный читатель может изучить их самостоятельно - приведу лишь главный с моей точки зрения результат:</p><div class=quote-block><blockquote><p>The evaluation results give us reasons to believe that our approach identifies microservices in a quality that is comparable to a design done by human software designers.
Our approach, however, achieved the microservices identification much faster and with less effort compared to human developers.
While identifying the microservices was a matter of days for the students at KIT and SWU-RISE, by employing our approach it was a matter of hours.</p><p>Результаты оценки дают нам основания полагать, что наш подход выявляет микросервисы, качество которых сравнимо с дизайном, выполненным людьми.
При этом наш подход позволяет выявлять микросервисы гораздо быстрее и с меньшими усилиями по сравнению с выполнением этой работы вручную.
В то время как у студентов KIT и SWU-RISE выявление микросервисов потребовало несколько дней, с использованием нашего подхода это заняло несколько часов.</p><footer>— <cite>Shmuel Tyszberowicz, Robert Heinrich, Bo Liu and Zhiming Liu, Identifying Microservices Using Functional Decomposition</cite></footer></blockquote></div></section><section class="doc-section level-2"><h3 id=_концептуальная_модель_системы><a class=link href=#_концептуальная_модель_системы>Концептуальная модель системы</a></h3><p>Для того чтобы применить подход к декомпозиции на базе эффектов, систему необходимо представить в виде графа операций и элементов состояния, связанных эффектами чтения и записи.
После чего процесс декомпозиции фактически сводится к кластеризации этого графа.
Пока что создать полностью автоматический алгоритм кластеризации, который бы давал удовлетворительные результаты, мне не удалось, поэтому кластеризация выполняется вручную.
И так как человеку проще выполнять кластеризацию графа, представленного визуально, я разработал специальную диаграмму, для представления графов эффектов.</p><p>Концептуальная модель системы и нотация диаграммы подробно описаны в <a href=https://azhidkov.pro/effects-diagram/specification-html/>спецификации</a>.
Упрощённо же можно считать, что:</p><div class=ulist><ul><li>Операции - это эндпоинты REST API;</li><li>Ресурсы - таблицы БД;</li><li>Эффекты записи - SQL INSERT/UPDATE/DELETE запросы;</li><li>Эффекты чтения - SQL SELECT-запросы.</li></ul></div><p>Соотвественно, для построения диаграммы эффектов, надо для каждого метода API добавить на диаграмму по прямоугольнику светло-синего цвета, для каждой таблицы добавить по прямоугольнику тёмно-синего цвета, для каждого запроса модификации данных добавить красную стрелку между соответствующей операцией и ресурсом, а для каждого запроса чтения данных - синюю стрелку.
В результате у вас получится картинка, состоящая из таких элементов:</p><div class=image-block><img src=/drafts/effects-diagram/images/short-notation-example.svg alt="short notation example"></div><p>Здесь, очевидным образом, операция "Зарегистрировать пользователя" вносит данные в таблицу "Пользователи", а операция "Аутентифицировать пользователя" считывает данные из этой таблицы.
Процесс построения диаграммы эффектов реального проекта с примерами всех распространённых видов ресурсов и операций описан в посте <a href=https://azhidkov.pro/posts/22/06/220611-true-story-project/>Диаграмма эффектов: пример построения</a>.</p><p>Также важно отметить, что все элементы диаграммы эффектов один в один транслируются в код:</p><div class="olist arabic"><ol class=arabic><li>Операции - в методы классов сервисов приложения;</li><li>Ресурсы - в классы сущностей и репозиториев (событий и топиков брокеров сообщений, ДТО и клиентов REST API и т.д.);</li><li>Эффекты - в вызовы методов классов репозиториев в методах классов сервисов.</li></ol></div><p>После визуализации системы с помощью диаграммы эффектов, задача декомпозиции системы сводится к кластеризации диаграммы.</p></section><section class="doc-section level-2"><h3 id=_кластеризация_диаграммы_эффектов><a class=link href=#_кластеризация_диаграммы_эффектов>Кластеризация диаграммы эффектов</a></h3><p>В основе подхода к кластеризации диаграммы лежит несколько простых и хорошо известных идей:</p><div class="olist arabic"><ol class=arabic><li>Ресурсы являются глобальными переменными;</li><li>Между всеми методами, которые взаимодействуют с одним ресурсом, появляется сцепленность через общее окружение (common environment coupling);</li><li>Один из основных методов снижения сцепленности системы в целом - это локализация сцепленности через общее окружение в модулях;</li><li>Запись глобальной переменной порождает большую сцепленность, чем чтение.</li><li>В связях между модулями не должно быть циклов;</li><li>Если модулю сложно дать хорошее имя, отражающее его содержание, это говорит о низкой функциональной связанности модуля.</li></ol></div><p>То, что запись порождает большую сцепленность, чем чтение - может быть не очевидно.
Однако это легко продемонстрировать, если рассмотреть их в контексте многопоточной работы.
Считывать глобальную переменную могут сколь угодно много потоков без какой-либо синхронизации и проблем.
Но, как только кто-то начинает изменять эту переменную, всё тут же становится намного сложнее: теперь надо обеспечить безопасный доступ и не создать дедлок, обеспечить протокол взаимодействия (сначала запись, потом чтение), следить за тем, чтобы операция записи не стала бутылочным горлышком в производительности системы и т.д.</p><p>Вооружившись этими идеями, легко определить требования к хорошей кластеризации диаграммы эффектов (декомпозиции системы):</p><div class="olist arabic"><ol class=arabic><li>Между кластерами нет циклов;</li><li>Эффекты записи (красные стрелки) инкапсулированы в одном кластере;</li><li>Количество эффектов чтения (синих стрелок), пересекающих границы кластеров, минимально;</li><li>Каждому кластеру легко дать имя, отражающее его содержание.</li></ol></div><p>Для простых диаграмм такая кластеризация может быть видна на глаз.
Примером простой диаграммы является диаграмма эффектов проекта True Story Project:</p><p>(<mark>todo: картинка геосервисов</mark>)</p><p>Здесь сразу же бросаются в глаза 3-4 кластера:</p><div class="olist arabic"><ol class=arabic><li>Работа с изображениями;</li><li>Формирование фида;</li><li>Интеграция с 2Гис;</li><li>Интеграция с Яндекс.Картами.</li></ol></div><p>Тут хорошо видно, что интуитивная декомпозиция зависит и от разработчика диаграммы (как он расположит элементы) и от наблюдателя - я на этой диаграмме вижу 4 кластера, но некоторые другие люди "автоматически" объединяют интеграции в один модуль.</p><p>Но большие или сложные системы на глаз кластеризовать не получится.
Для того чтобы структурировать процесс кластеризации больших диаграмм, я разработал специальную методику.</p></section><section class="doc-section level-2"><h3 id=_методика_кластеризации_диаграммы_эффектов><a class=link href=#_методика_кластеризации_диаграммы_эффектов>Методика кластеризации диаграммы эффектов</a></h3><p>Методика состоит из двух больших этапов - кластеризации и оптимизации кластеров.
Для этапа кластеризации существует алгоритм, который позволяет выполнить первичную кластеризацию, собирать "низко висящие фрукты" и подсветить места, требующие особого внимания.
А вот для этапа оптимизации требуется понимание предметной области и ограничений проекта, поэтому для него невозможно написать универсальный алгоритм.
И разработчику приходится его выполнять, исходя из требований проекта и собственного опыта.</p><section class="doc-section level-3"><h4 id=_алгоритм_первичной_кластеризации_диаграммы_эффектов><a class=link href=#_алгоритм_первичной_кластеризации_диаграммы_эффектов>Алгоритм первичной кластеризации диаграммы эффектов</a></h4><p>Алгоритм первичной кластеризации является итеративным, и каждая итерация состоит из трёх шагов:</p><div class="olist arabic"><ol class=arabic><li>Генерация кластеров.</li><li>Расширение кластеров.</li><li>Агрегация ресурсов.</li></ol></div><p>Генерация кластеров заключается в том, чтобы перебрать все некластеризованные ресурсы и кластеризовать их с операциями, которые:</p><div class="olist arabic"><ol class=arabic><li>Связаны только с этим ресурсом.</li><li>Связаны с этим ресурсом своим единственным эффектом записи.</li><li>Являются операциями чтения, для которых данных ресурс выступает первичным.
Определение первичного ресурса (и вообще его наличия) остаётся на усмотрение исполнителя.</li></ol></div><p>Расширене кластеров заключается в том, чтобы перебрать все некластеризованные элементы, связанные только c элементами внутри одного кластера, и добавить их в этот кластер.</p><p>Этап агрегации ресурсов заключается в том, чтобы оставшиеся некластеризованные ресурсы попытаться объединить в "разумные" группы между собой или с кластеризованными ресурсами.
Строго говоря, на этапе агрегации надо перебрать все возможные попарные соединения и выбрать из них "разумные".
Однако "разумные" пары, как правило, имеют общую операцию, поэтому эмпирический алгоритм агрегации выглядит так:</p><div class="olist arabic"><ol class=arabic><li>Для каждого некластеризовнного ресурса выбрать ресурсы, с которыми у него есть общая операция.</li><li>Если в списке есть "разумная" пара данному ресурсу - сгруппировать их.
Универсального и формализованного критерия разумности я пока что не нашёл, поэтому это решение остаётся за исполнителем.</li></ol></div><p>Далее сгруппированные ресурсы рассматриваются как единое целое - все эффекты связывающие любой из ресурсов этой группы с одной и той же операцией считаются одним эффектом.
Если операцию связывают с группой и эффекты чтения и эффекты записи, то считается что операция связана с группой эффектом записи.</p><p>После агрегации ресурсов снова возвращаемся к этапу генерации кластеров.
Если этапы генерации и расширения кластеров не привели к уменьшению количества некластеризованных элементов, то, теоретически, этап агрегации можно снова повторить и продолжать это делать до включения всех оставшихся ресурсов в одну группу.
Однако практически уже на второй последовательной итерации агрегации (когда одина группа некластеризованных ресурсов содержит в себе три базовых ресурса) нужно быть начеку.
Большие группы зачастую указывают на операции, которые делают слишком много работы и как следствие обладают высокой сцепленностью - поэтому возможно придётся вернуться к этапу проектирования самих операций и ресурсов.
Либо декомпозиция на базе эффектов не подходит для вашей задачи.</p><p>В результате применения этого алгоритма вы получите либо полную, либо частичную первичную декомпозицию.
Но в любом случае это лишь первичная декомпозиция и её надо проверить на "разумность" и, при необходимости - доработать.</p></section><section class="doc-section level-3"><h4 id=_ручное_завершение_кластеризации><a class=link href=#_ручное_завершение_кластеризации>Ручное завершение кластеризации</a></h4><p>Если алгоритм кластеризации породил частичную декомпозицию, то её придётся завершить вручную.
На этой стадии останутся некластеризованными только те элементы, которые связаны с двумя и более кластерами (в противном случае они бы были кластеризованы на шаге расширения кластеров).
И тут для каждого элемента есть несколько вариантов, из которых необходимо выбрать один на усмотрение исполнителя:</p><div class="olist arabic"><ol class=arabic><li>Для некластеризованных операций записи в первую очередь стоит рассмотреть вариант расцепки операции через очередь сообщений.
Для этого надо сделать:<ol class=loweralpha type=a><li>Определить ресурс очереди сообщений для операции;</li><li>Добавить эффект записи по публикации сообщения базовой операцией;</li><li>Выделить основной эффект операции</li><li>Оставить у операции только основной эффект и эффект публикации сообщения;</li><li>Для всех остальных эффектов добавить новые операции в тех кластерах, ресурсы которых модифицируются этими эффектами.</li></ol></li><li>Если с одним из кластеров элемент связан бОльшим количеством связей или они кажутся "сильнее" - его можно внести в этот кластер.
В случае операции стоит принять во внимание её клиента (внешнюю сущность, инициирующую выполнение операции) - если с одним из кластеров у неё общий клиент, то связь с этим кластером сильнее;</li><li>Если элемент выглядит связанным со всеми кластерами в равной степени - его можно поместить в собственный кластер.
В этот же кластер, можно добавить другие элементы связанные с теми же кластерами.</li><li>Если кластеры, связанные с элементом, имеют высокую функциональную связанность - их все можно объединить в один кластер.</li><li>Если все эти варианты выглядят странно или нелогично - нужно пересмотреть состав существующих кластеров.</li><li>Последний вариант - вернуться к дизайну операций и ресурсов.</li></ol></div></section><section class="doc-section level-3"><h4 id=_оптимизация_кластеров><a class=link href=#_оптимизация_кластеров>Оптимизация кластеров</a></h4><p>Этап оптимизации кластеров состоит из следующих шагов:</p><div class="olist arabic"><ol class=arabic><li>Наименование кластеров.</li><li>Визуализация графа кластеров.</li><li>Проверка "разумности" связей кластеров.</li><li>Объединение модулей.<ol class=loweralpha type=a><li>Сокрытие подмодулей.</li><li>Группировка функционально схожих модулей.</li></ol></li></ol></div><p>После получения полной кластеризации, каждому кластеру необходимо дать имя, отражающее его содержание.
В случае хорошей декомпозиции - это не составит труда.
Если же определить имя какого-то кластера не получается, то необходимо рассмотреть его внимательнее.
Часто такие проблемы решаются с помощью разделения проблемного кластера на два более мелких и сфокусированных.
Но поиск разумного имени кластера может привести и к перепроектированию ресурсов и операций.</p><p>После того, как каждому кластеру дано разумное имя, полезно проделать ещё одно упражнение - визуализировать граф кластеров.
Такая визуализация помогает увидеть "лес за деревьями" и оценить "разумность" уже самого леса.</p><p>Получив граф кластеров - проверьте его на соответствие вашему здравому смыслу.
Я в этом случае фокусируюсь на связях и их направлении:</p><div class="olist arabic"><ol class=arabic><li>Разумно ли, что этот модуль зависит от того?</li><li>Может ли целевой модуль зависимости существовать без зависимого?</li><li>Какой из модулей более стабилен (более стабильным должен быть целевой модуль).</li></ol></div><p>У вас могут быть свои вопросы для оценки соответствия здравому смыслу.</p><p>Наконец, последний шаг (особенно если получилось больше 5 кластеров) - найти и объединить подмодули и функционально схожие модули.
Подмодуль - это модуль, обеспечивающий работу одного базового модуля.
В этом случае кластер подмодуля необходимо поместить внутрь кластера модуля.</p><p>Функционально схожие модули - это модули, выполняющие разными способами одну и ту же функциональность, либо выполняющие разные подфункции одной общей функции.
Такие модули надо объединить в общий кластер.
Этому кластеру также надо дать имя и если это вызывает затруднения, то от объединения лучше отказаться.</p><p>Всё, теперь можно создавать структуру пакетов, соответствующую структуре кластеров, в каждом пакете создавать по классу сервиса со всеми операциями кластера и по классу репозитрия/клиента/топика для каждого ресурса кластера.
Также в целях снижения сцепленности в сервисы модуля надо будет добавить по методу на каждую стрелку, входящую в кластер.</p><p>Теперь рассмотрим процесс выполнения декомпозиции реального проекта.</p><p>(<mark>todo: остановились здесь</mark>)</p></section></section></section><section class="doc-section level-1"><h2 id=_кейс_кэмп><a class=link href=#_кейс_кэмп>Кейс: Кэмп</a></h2><p>Примеры в программировании и особенно дизайне - это всегда боль.
Слишком простые или синтетически не особо полезны.
Слишком сложные и реальные - мало кто станет в них вгружаться, и сложно отделить релевантые детали от лишнего шума.
Кэмп явлется на мой взгляд золотой серединой.</p><p><a href="https://play.google.com/store/apps/details?id=ru.ngtrans.camp">Кэмп</a> - реальный проект который стоил семизначную сумму для заказчика и выполнялся командой из 12 человек в пике, бакенд делали два разработчика и сейчас находится в промышленной эксплуатации.
Суммарно на выполнение проекта было затрачено 5500 человеко/часов, из которых 950 - на бакенд.</p><p>Но это был экспериментальный проект, который (с согласия заказчика) выполнялся силами исключительно молодых специалистов, а лиды только проводили ревью и помогали консультациями.
Поэтому по фактическому объёму функциональности проект достаточно компактный.</p><p>Проект является специализированной геоинформационной системой для водителей-дальнобойщиков.
В отличие от больших ГИС систем вроде Яндекс.Карт он отличается тем, что позволяет найти не просто гостиницу по дороге, а гостиницу где водитель может и сам переночевать и рефрижиратор на 86 "кубов" припарковать.</p><p>Соответственно двумя ключевыми сущностями являются водители и "точки" (кафе, заправки, СТО и т.п.).
Точки в систему вносят сами пользователи после предварительной модерации.
С водителями связаны характеристики машин, которые они водят (сейчас - только тип машины и размер колёс), а с точками - характеристики машин, которые они в состоянии обслужить.</p><p>Кроме того, в системе реализована система пуш-уведомлений пользователей о новостях приложения, а так же о результатах модерации добавленной точки.</p><p>Вся эта функциональность отражена не следующей диаграмме эффектов:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-orig.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-orig.drawio.svg alt="camp effects orig.drawio"></a></div><p>Теперь давайте прогоним по этой диаграмме алгоритм декомпозиции на базе эффектов и посмотрим, что получится.</p><section class="doc-section level-2"><h3 id=_декомпозиция_диаграммы_эффектов_кэмпа><a class=link href=#_декомпозиция_диаграммы_эффектов_кэмпа>Декомпозиция диаграммы эффектов Кэмпа</a></h3><section class="doc-section level-3"><h4 id=_этап_первичной_кластеризации><a class=link href=#_этап_первичной_кластеризации>Этап первичной кластеризации</a></h4><section class="doc-section level-4"><h5 id=_итерация_1_шаг_генерации_кластеров><a class=link href=#_итерация_1_шаг_генерации_кластеров>Итерация 1, шаг генерации кластеров</a></h5><p>На первом шаге надо перебрать все ресурсы и объединить их сильно связанными с ними операциями.
Перебирать будем в "естественном" порядке - сверху вниз, слева на право по связям.</p><p>Поэтому начнём с ресурса "Сервис отправки СМС".
С ним связана только операция "Запросить OTP", однако она сама связана операцией записи с другим ресурсом, поэтому пока её откладываем.</p><p>То же самое с ресурсом "OTP" - он связан с операциями "Запросить OTP" и "Получить токен из отп", но обе операции имеют по два эффекта записи, поэтому этот ресурс пока пропускаем.</p><p>Далее идёт ресурс "Токены".
Его мы наконец можем объединить с операцией "Получить токен из логина/пароля" и получить первый кластер (на первом этапе я буду именовать кластера по порядковому номеру их добавлению на диаграмму).
Операция "Получить токен из отп" тоже просится в этот кластер, но так как она связана эффектом записи с другим ресурсом мы её пока откладываем.</p><p>Далее идёт ресурс "Пользователи".
Только с ним связаны операции "Изменить пользователя" и "Удалить пользователя", а для операции только на чтение "Получить пользователя" он очевидно является первичным.
Объединяем их все во второй кластер.</p><p>Затем рассмотрим схожие ресурсы "Типы машин" и "Размер колес", оба ресурса связаны эффектами чтения с двумя операциями и не один из них не выступает первичным для этих операций, поэтому пока что пропустим их.</p><p>Теперь переходим к ресурсу "Топик 'Точка промодерирована'".
Связанные с ним операции - "Удалить точку" и "Изменить точку" связаны эффектами записи с другими ресурсами, поэтому этот ресурс пока что оставляем некластеризованным.</p><p>После чего переходим к ресурсу "Точки на карте".
Он явно является первичным для операции "Получить точки", а так же он является единственным ресурсом операции "Создать точку".
Добавляем их в третий кластер.</p><p>Далее у нас снова схожая пара ресурсов "Услуги" и "Тэги".
Оба ресурса связаны своим единственным эффектом чтения с операцией "Получить точки", которая уже входит в третий кластер - отложим их до шага расширения кластеров.</p><p>Теперь переходим к подграфу уведомлений.</p><p>Тут у нас есть ресурс "Сервис отправки Push-уведомлений" с которым связаны операции "Создать новостное уведомление" и "Создать персональные уведомления", у которых по два эффекта записи, поэтому пока отложим их все.</p><p>Зато в четвёртый кластер мы можем объединить ресурс "Уведомления" с операциями "Удалить уведомление", "Получить список новостных уведомлений" (это их единственный ресурс) и "Получить список персональных уведомлений" (для этой операции он является первичным).</p><p>Наконец, последний ресурс "Прочитанные уведомления" можно объединить с операцией "Прочитать уведомление", для которой он является единственным ресурсом в пятый кластер.</p><p>На этом первая итерация генерации кластеров заканчивается и у нас получается такая промежуточная кластеризация:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-1.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-1.drawio.svg alt="camp effects step 1.drawio"></a></div></section><section class="doc-section level-4"><h5 id=_итерация_1_шаг_расширения_кластеров><a class=link href=#_итерация_1_шаг_расширения_кластеров>Итерация 1, шаг расширения кластеров</a></h5><p>Далее идёт этап расширения кластеров, на котором все некластеризованные элементы, связанные только с одним кластером надо поместить в этот кластер.
У нас сейчас таких элементов два - ресурсы "Услуги" и "Тэги" связаны только с третьим кластером - затягиваем их в него (изменённый кластер обозначен пунктирной линией):</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-2.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-2.drawio.svg alt="camp effects step 2.drawio"></a></div></section><section class="doc-section level-4"><h5 id=_итерация_1_шаг_агрегации_ресурсов><a class=link href=#_итерация_1_шаг_агрегации_ресурсов>Итерация 1, шаг агрегации ресурсов</a></h5><p>Теперь переходим к следующему шагу - агрегации ресурсов.
Для этого перебираем оставшиеся некластеризованные ресурсы и смотрим есть ли для них "разумная" пара, с которой они связаны общей операцией.
Перебор снова будем делать в "естественном" порядке.</p><p>Поэтому снова начинаем с ресурса "Сервис отправки СМС".
Он через операцию "Запросить OTP" связан с ресурсом "OTP".
Образуют ли они "разумную"" группу?
Вообще хороший вопрос.
Связаны они тем, что сервис является механизмом доставки OTP.
Но сам сервис теоретически может использоваться для доставки другой информации, и OTP можно доставлять с помощью других механизмов.
Тем не менее, прямо сейчас все они решают одну конкретную задачу - обеспечение пользователя одноразовым паролем для входа и я решаю агрегировать эти два ресурса.</p><p>Затем идёт пара ресурсов "Типы машин" и "Размер колес".
И то и другое является атрибутами машин, поэтому в принципе их можно агрегировать.
Но на конечный результат это не повлияет и в кластеризации нам не поможет, поэтому я их оставляю отдельными ресурсами.</p><p>Далее переходим к ресурсу - "Топик 'Точка промодерирована'".
Он через операции "Удалить точку" и "Изменить точку" связан с ресурсом "Точки на карте" и является механизмом оповещения об изменениях в последнем.
На мой взгляд они формируют разумную группу и этот ресурс можно занести в кластер.</p><p>Аналогично с последним некластеризованным ресурсом "Сервис отправки Push-уведомлений" - он является механизмом доставки уведомлений до пользователя и на мой взгляд образует разумную группу с ресурсом уведомлений.</p><p>После выполнения всех этих агрегаций, у нас получается следующий этап кластеризации (здесь агрегированные ресурсы обозначены штриховкой):</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-3.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-3.drawio.svg alt="camp effects step 3.drawio"></a></div><p>Теперь заходим на вторую итерацию и возвращаемся к шагу генерации кластеров.</p></section><section class="doc-section level-4"><h5 id=_итерация_2_шаг_генерации_кластеров><a class=link href=#_итерация_2_шаг_генерации_кластеров>Итерация 2, шаг генерации кластеров</a></h5><p>На шаге генерации кластеров на второй итерации мы так же проходимся по некластеризованным ресурсам, но теперь агрегированные ресурсы рассматриваем как одно целое.
После агрегации ресурсов, операция "Запросить OTP" стала связана одним эффектом записи с группой ресурсов "Сервис отправки СМС" и "ОТП" и стало возможных кластеризовать:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-4.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-4.drawio.svg alt="camp effects step 4.drawio"></a></div><p>После этого некластеризованными остались только ресурсы "Типы машин" и "Размер колес", в отношении которых ничего не поменялось, поэтому переходим на следующий шаг.</p></section><section class="doc-section level-4"><h5 id=_итерация_2_шаг_расширения_кластеров><a class=link href=#_итерация_2_шаг_расширения_кластеров>Итерация 2, шаг расширения кластеров</a></h5><p>После шага агрегации, ресурсы "Удалить точку" и "Изменить точку", а также "Создать новостное уведомление" и "Создать персональные уведомления" стали связаны только с элементами четвёртого и пятого кластеров соответсвенно, поэтому теперь их можно затянуть в эти кластеры:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-5.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-5.drawio.svg alt="camp effects step 5.drawio"></a></div><p>На этом алгоритм первичной кластеризации зашёл в тупик - операция "Получить токен из отп" связана двумя эффектами записи с разными кластерами, а ресурсы "Типы машин" и "Размеры колёс" связана двумя равноценными эффектами чтения с разными кластерами.
Пришло время расчехлять свой большой мозолистый мозг.</p></section></section><section class="doc-section level-3"><h4 id=_этап_ручного_завершения_кластеризации><a class=link href=#_этап_ручного_завершения_кластеризации>Этап ручного завершения кластеризации</a></h4><p>Начнём с операции "Получить токен из отп".
У нас есть целая россыпь вариантов, как поступить с ней:</p><div class="olist arabic"><ol class=arabic><li>Внести в шестой кластер.</li><li>Внести в первый кластер.</li><li>Расцепить через очередь сообщений</li><li>Объединить первый и четвёртый кластер и внести туда.</li><li>Операции получения токенов занести в четвёртый и второй кластеры и сделать новый кластер вокруг ресурса "Токены".</li></ol></div><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-6-variants.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-6-variants.drawio.svg alt="camp effects step 6 variants.drawio" height=500></a></div><p>В целом, все эти варианты имеют право на жизнь.
Но давайте рассмотрим их с точки зрения "тяжести" графа - пусть связь между кластерами синей стрелкой будет стоить одну единицу, а красной - две.
В этом случае вес вариантов выше будет следующий:</p><div class="olist arabic"><ol class=arabic><li>4</li><li>3</li><li>1</li><li>1</li><li>5</li></ol></div><p>Вполне предсказуемо, выигрывают варианты 3 и 4, которые исключают эффект записи между кластерами.
Какой вариант выбрать из них?
Я выбираю 4.
Потому что на данном этапе и OTP и сервис отправки смс являются деталями реализации модуля аутентификации.</p><p>Теперь у нас осталось только два некластеризованных элемента - ресурсы "Типы машин" и "Размеры колёс".</p><p>С ними можно поступить тремя путями - занести их в один из существующий кластер, сделать из них по кластеру и объединить в один кластер.</p><p>Первый путь создаст нам проблемы на этапе именования кластеров - любой из этих ресурсов в любом из существующих кластеров будет смотреться чужеродно.</p><p>Второй путь приведёт к проблемам на этапе анализа "разумности" графа кластеров - модули "Типы машин" и "Размеры колёс", явно будут выпадать по уровню абстракции среди "Пользователей", "Точек" и т.п.</p><p>Поэтому я выбрал третий путь - объединить их в общий кластер:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-6.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-6.drawio.svg alt="camp effects step 6.drawio"></a></div><p>На этом мы получаем полную кластеризацию и можем переходить к этапу её оптимизации.</p></section><section class="doc-section level-3"><h4 id=_этап_именования_кластеров><a class=link href=#_этап_именования_кластеров>Этап именования кластеров</a></h4><p>На этом этапе мы по очереди рассматриваем кластеры и даём им имена, отражающие их содержимое.</p><p>Так для кластера с элементами "Запросить OTP", "Сервис отправки СМС", "OTP", "Получить токен из отп", "Токены" и "Получить токен из логина/пароля" на мой взгляд отлично подходит имя <strong>"Авторизация"</strong>.</p><p>Для кластера с элементами "Пользователи", "Изменить пользователя", "Удалить пользователя" и "Получить пользователя" - подходит имя <strong>"Пользователи"</strong>.</p><p>Кластер с элементами "Типы машин" и "Размер колес" можно назвать <strong>"Характеристики машин"</strong>.</p><p>Самому большому кластеру с элементами "Точки на карте", "Топик результатов модерации", "Создать точку", "Удалить точку", "Изменить точку", "Получить точки", "Услуги", "Тэги" можно дать имя <strong>"Точки"</strong>.</p><p>Затем кластеру с элементами "Уведомления", "Сервис отправки Push-уведомлений", "Создать новостное уведомление", "Создать персональные уведомления", "Удалить уведомление", "Получить список новостных уведомлений", "Получить список персональных уведомлений" подходит имя <strong>"Уведомления"</strong>.</p><p>А вот для последнего кластера с элементами "Прочитанные уведомления" и "Прочитать уведомление" имя "Прочитанные уведомления" хоть и подходит, но меня заставляет поморщиться.
Это слишком низкоуровневая штука, для верхнеуровневой структуры модулей.</p><p>Быстрым решением будет объединить этот кластер с кластером <strong>"Уведомления"</strong>.
Однако меня эта нестыковка уже не повторимым ходом мысли вывела на другое решение.</p><p>Сначала я задумался - а что общего у персональных и новостных уведомлений?</p><p>На самом деле - практически ничего.
Во-первых, то обо что я споткнулся - флаг прочтения есть только у персональных уведомлений.</p><p>Они отправляются разными сущностями - персональные отправляются системой автоматически, а новостные - по запросу администратора.</p><p>Они отправляются разным людям - персональные отправляются водителю, создавшему точку, а новостные - всем водителям.</p><p>Даже АПИ методы для отправки используются разные.</p><p>И так я пришёл к тому, что у меня была ошибка в изначальном дизайне - ресурсы "Уведомления" и "Сервис отправки Push-уведомлений" надо было разделить на два - для персональных и новостных уведомлений.
И если это сделать, то всё сразу встаёт на свои места - этим двум новым кластерам легко дать имена <strong>"Новостные уведомления"</strong> и <strong>"Персональные уведомления"</strong> и они будут уже не так сильно выбиваться по уровню абстракции:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-7.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-7.drawio.svg alt="camp effects step 7.drawio"></a></div><p>Теперь мы можем переходить к шагу анализа графа кластеров.</p></section><section class="doc-section level-3"><h4 id=_этап_анализа_графа_кластеров><a class=link href=#_этап_анализа_графа_кластеров>Этап анализа графа кластеров</a></h4><p>На этом этапе первым делом необходимо этот граф визуализировать:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-8.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-8.drawio.svg alt="camp effects step 8.drawio"></a></div><p>При анализе я в первую очередь смотрю на зависимости.</p><p>Разумно что авторизация зависит от пользователей?
Мне кажется разумно - мы же пользователей авторизуем и.</p><p>Разумно ли, что пользователи и точки зависят от характеристик машин?
Мне кажется разумно - характеристики машин, являются абстрактными понятиями, характеризующие конкретных пользователей и точки и было бы странно, если бы тип машины "знал", в каких точках его могут обслужить.</p><p>Затем я проверяю, что все элементы графа имеют примерно один уровень абстракции.
И тут мне субъективно кажется, что "Новостные уведомления" и "Персональные уведомления" немного выпадают по уровню абстракции.
А вот если и спрятать в более абстрактном модуле "Уведомления" - всё встанет на свои места.</p><p>И это даёт нам итоговую декомпозицию системы на пять верхнеуровневых модулей:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp-v4/camp-effects-step-9.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp-v4/camp-effects-step-9.drawio.svg alt="camp effects step 9.drawio"></a></div><p>На этом декомпозиция системы завершена - можно создавать проект, там заводить по пакету (или модулю) на каждый кластер, в каждом пакете создавать класс сервиса, для каждой операции кластера в соответствующем классе определять метод и вперёд, можно кодировать.</p></section></section></section><section class="doc-section level-1"><h2 id=_ограничения_подхода_к_декомпозиции_на_базе_эффектов><a class=link href=#_ограничения_подхода_к_декомпозиции_на_базе_эффектов>Ограничения подхода к декомпозиции на базе эффектов</a></h2><p>Основное ограничение подхода заключается в том, что он всё ещё находится на стадии опытной эксплуатации и максимальный размер проекта, который я по нему декомпозировал составляет один человеко-год.</p><p>С точки зрения типа и характера задач, подход на базе эффектов хорошо подходит для декомпозиции систем с богатым состоянием и правилами его изменения.
Если же в системе состояния как такого не много - компилятры, например, или системы потоковой обработки информации, ток декомпозировать такую систему на основе эффектов не получится.</p></section><section class="doc-section level-1"><h2 id=_характеристики_подхода_к_декомпозиции_на_базе_эффектов><a class=link href=#_характеристики_подхода_к_декомпозиции_на_базе_эффектов>Характеристики подхода к декомпозиции на базе эффектов</a></h2><p>Итак, для того чтобы максимизировать количество дофамина и минимизировать количество кортизола в команде, на нужен подход к декомпозиции, который обладает следующими характеристиками:</p><div class="olist arabic"><ol class=arabic><li>Вообще есть;</li><li>Прост в изучении;</li><li>Прост в исполнении;</li><li>Даёт хорошие результаты вне зависимости от исполнителя;</li></ol></div><p>Обладет ли подход к декомпозиции на базе эффектов этими характеристиками?</p><p>Он безусловно есть.
Возможно пока что описан не идиально, но я продолжу работы в этом направлении.</p><p>Для меня он существенно проще в изучении и исполнеии чем DDD.
Является ли он таковым для вас - судить вам.
Вы можете попробовать его применить в своём проекте или его небольшой части - это займёт не много времени, и вне зависимости от результатов поможет вам лучше понять свою систему.
По моему опыту трудозатраты на декомпозицию на базе эффектов идут в соотношении 1-2 человеко/часа проектирования к 1 человеко-месяцу разработки.
Соответсвенно, со скидкой на отсутсвие опыта, на декомпозицию проекта на 2 человеко-месяца вам должно хватить одного человеко-дня.</p><p>Наконец, результаты декомпозиции на базе эффектов всё-таки зависят от исполнителя, но в меньшей степени, чем интуитивная декомпозиция или декомпозиция на базе границ в языке предметной области.</p></section></article></section></div></main><script src=/js/app.js></script></body></html>