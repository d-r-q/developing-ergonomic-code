<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Рациональный подход к декомпозиции систем на модули или микросервисы - Алексей Жидков"><meta property="og:description" content="Рациональный подход к декомпозиции систем на модули или микросервисы"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/drafts/effects-diagram/ood-decomposition-v4/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/drafts/effects-diagram/ood-decomposition-v4/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/drafts/effects-diagram/ood-decomposition-v4/><title>Рациональный подход к декомпозиции систем на модули или микросервисы - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/drafts/effects-diagram/ood-decomposition-v4/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Рациональный подход к декомпозиции систем на модули или микросервисы</h1></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><section class="doc-section level-1"><h2 id=_чего_от_разработки_по_хотят_разработчики_продакты_и_владельцы_бизнеса><a class=link href=#_чего_от_разработки_по_хотят_разработчики_продакты_и_владельцы_бизнеса>Чего от разработки ПО хотят разработчики, продакты и владельцы бизнеса?</a></h2><p>Одного и того же - побольше дофаминчика (гормон счастья), поменьше кортизольчика (гормон стресса).
При том источники и дофамина, и кортизола у них одни и те же.
Дофамин вырабатывается, когда фичи выпускаются в срок и без багов, а кортизол - когда сроки срываются и вылазят баги и регрессии.
Бизнесу будет ближе финансовая версия - срыв сроков и баги очевидным образом приводят к увлечению стоимости разработки.
Что приводит к выбросу кортизола уже у владельцев.</p></section><section class="doc-section level-1"><h2 id=_как_обеспечить_высокий_уровень_дофамина_всей_команды><a class=link href=#_как_обеспечить_высокий_уровень_дофамина_всей_команды>Как обеспечить высокий уровень дофамина всей команды?</a></h2><p>Для того чтобы поддерживать высокий уровень дофамина и низкий уровень кортизола у всех участников процесса, нам необходимо декомпозировать системы на модули.
Декомпозиция помогает обеспечить высокую скорость и качество разработки за счёт:</p><div class=ulist><ul><li>Ограничения объёма кода, который необходимо изучить и адаптировать к изменениям в требованиях;</li><li>Исключения конфликтов при параллельной разработке независимых функций системы;</li><li>Создания возможности независимого выпуска и развёртывания отдельных функций системы.</li></ul></div><p>Однако, этого можно достичь, только в том случае, если получившиеся модули обладают высокой функциональной связанностью и низкой сцепленностью.</p><p>(<mark>todo: картинка</mark>)</p><p>Кроме того, для максимизации <s>выброса дофамина</s> скорости разработки и минимизации <s>выброса кортизола</s> стоимости разработки, необходимо чтобы сама работа по декомпозиции системы проходила быстро и давала качественные результаты.</p></section><section class="doc-section level-1"><h2 id=_как_обеспечить_высокий_уровень_дофамина_всей_команды_при_выполнении_декомпозиции><a class=link href=#_как_обеспечить_высокий_уровень_дофамина_всей_команды_при_выполнении_декомпозиции>Как обеспечить высокий уровень дофамина всей команды при выполнении декомпозиции?</a></h2><p>А для того чтобы эта работа проходила быстро и давала качественные результаты, необходимо, чтобы она была структурирована и стандартизирована.
Таким образом необходим некий рациональный подход к декомпозиции.
И тут в нашей индустрии проблемы.</p><p>По моему опыту, в ВУЗах декомпозиции либо не обучают совсем, либо обучают монструозным и фактически устаревшим методологиям вроде RUP-а.
А по мнению Джона Остерхаута в США дела обстоят так же:</p><div class=quote-block><blockquote><p>Problem decomposition is the central design task that programmers face every day, and yet, other than the work described here, I have not been able to identify a single class in any university where problem decomposition is a central topic.
We teach for loops and object-oriented programming, but not software design.</p><p>Декомпозиция - это центральная задача проектирования, с которой программисты сталкиваются каждый день, и все же, кроме работы, описанной здесь, я не смог определить ни одного курса ни в одном университете, где декомпозиция является центральной темой.
Мы учим циклам и объектно-ориентированному программированию, но не проектированию ПО.</p><footer>— <cite>John Ousterhout, A Philosophy of Software Design</cite></footer></blockquote></div><p>Из-за этого, в большинстве команд, которые я видел в последние годы, проектирование и декомпозиция заключалась в паре часов несистематизированного рисования прямоугольников и стрелок одним-двумя разработчиками.
А полноценное проектирование и декомпозицию я видел в последний раз в 2005 году и они заняли несколько месяцев.</p><p>Для того чтобы обеспечить высокий уровень дофомина и на этапе проектирования и декомпозиции и на этапе последующей реализации, нам необходим подход к декомпозиции, который:</p><div class="olist arabic"><ol class=arabic><li>Вообще есть;</li><li>Прост в изучении;</li><li>Прост в исполнении;</li><li>Даёт хорошие результаты вне зависимости от исполнителя;</li></ol></div><p>Это и будет тем самым рациональным подходом к декомпозиции, который нам необходим.</p></section><section class="doc-section level-1"><h2 id=_а_что_не_так_с_классикой><a class=link href=#_а_что_не_так_с_классикой>А что не так с классикой?</a></h2><p>(<mark>todo: дополнить пост материалом об анкл бобе</mark>)</p><p>У опытного разработчика, тут может возникнуть вопрос: "Как это нет подхода к декомпозиции? А как же слоёная архитектура? Чистая архитектура? DDD, в конце концов?".
Я изучил все эти и много других подходов к декомпозиции начиная с 60-ых годов, многое взял себе, но не один из этих подходов мне не удалось положить на каждодневную практику.</p><p>Подробно основные существующие подходы я рассмотрел в <a href=https://azhidkov.pro/posts/22/08/ergonomic-decomposition/>отдельном посте</a> и здесь приведу только причины, по которым мне они не подошли:</p><div class="olist arabic"><ol class=arabic><li>Декомпозиция по слоям не масштабируется и даёт плохие результаты с точки зрения связанности и сцепленности;</li><li>Декомпозиции по фичам и компонентам плохо описаны, и при попытке их применения возникает множество вопросов, на которые у источников нет ответов.
Я нашёл эти ответы самостоятельно и у меня получился подход к декомпозиции на базе эффектов;</li><li>DDD сложен и в изучении, и применении.
Мне не разу ни удалось "продать" DDD хотя бы РП, фронт-разработчикам, аналитикам и QA-инженерам в собственной команде.
Кроме того, наличие "на борту" экспертов предметной области, критически важное для DDD, в моей практике является скорее исключением, чем правилом.</li><li>В работах Роберта Мартина:<ol class=loweralpha type=a><li>Принципы пакетирования не содержать инструкции по выполнению декомпозиции;</li><li>Кричащая архитектура описана в одном пятиминутном посте;</li><li>Чистая архитектура является вариацией на тему слоёной архитектуры со всеми присущими ей недостатками.</li></ol></li></ol></div><p>Изучением и апробированием классики я занимался 6 лет - с 2014 до 2020 года.
Так и не найдя внятного ответа на вопрос "Как мне декомпозировать систему?", во второй половине 2020 я начал искать собственный подход к декомпозиции и написал разделы книги о <a href=https://azhidkov.pro/book/ergo/#_таблица_эффектов>таблице эффектов</a> и <a href=https://azhidkov.pro/book/ergo/#_принципы_проектирования_системы>компонентах</a> (осторожно, устаревшие и не отредактированные черновики).
К марту 2021 года я придумал <a href=https://azhidkov.pro/posts/21/03/250326-project-decomposiotion/>объединить их в один граф</a> и в итоге это превратилось в декомпозицию на базе эффектов.</p></section><section class="doc-section level-1"><h2 id=_декомпозиция_на_базе_эффектов><a class=link href=#_декомпозиция_на_базе_эффектов>Декомпозиция на базе эффектов</a></h2><section class="doc-section level-2"><h3 id=_подход_проверен_и_обоснован_научно><a class=link href=#_подход_проверен_и_обоснован_научно>Подход проверен и обоснован научно</a></h3><p>Прежде чем перейти к самому подходу, хочу подчеркнуть, что он научно обоснован.
Есть три научных статьи, описывающих такой же по сути подход:</p><div class=ulist><ul><li><a href=https://www.researchgate.net/publication/283566310_Improving_Design_Decomposition>Improving Design Decomposition</a>;</li><li><a href=https://www.researchgate.net/publication/326260296_Functional_Decomposition_for_Software_Architecture_Evolution>Functional Decomposition for Software Architecture Evolution</a>;</li><li><a href=https://www.researchgate.net/publication/327229270_Identifying_Microservices_Using_Functional_Decomposition_4th_International_Symposium_SETTA_2018_Beijing_China_September_4-6_2018_Proceedings>Identifying Microservices Using Functional Decomposition</a>.</li></ul></div><p>Я не буду здесь подробно останавливаться на этих статьях - они в открытом доступе и заинтересованный читатель может изучить их самостоятельно - приведу лишь главный с моей точки зрения результат:</p><div class=quote-block><blockquote><p>The evaluation results give us reasons to believe that our approach identifies microservices in a quality that is comparable to a design done by human software designers.
Our approach, however, achieved the microservices identification much faster and with less effort compared to human developers.
While identifying the microservices was a matter of days for the students at KIT and SWU-RISE, by employing our approach it was a matter of hours.</p><p>Результаты оценки дают нам основания полагать, что наш подход выявляет микросервисы, качество которых сравнимо с дизайном, выполненным людьми.
При этом наш подход позволяет выявлять микросервисы гораздо быстрее и с меньшими усилиями по сравнению с выполнением этой работы вручную.
В то время как у студентов KIT и SWU-RISE выявление микросервисов потребовало несколько дней, с использованием нашего подхода это заняло несколько часов.</p><footer>— <cite>Shmuel Tyszberowicz, Robert Heinrich, Bo Liu and Zhiming Liu, Identifying Microservices Using Functional Decomposition</cite></footer></blockquote></div></section><section class="doc-section level-2"><h3 id=_концептуальная_модель_системы><a class=link href=#_концептуальная_модель_системы>Концептуальная модель системы</a></h3><p>Для того чтобы применить подход к декомпозиции на базе эффектов, систему необходимо представить в виде графа операций и элементов состояния, связанных эффектами чтения и записи.
После чего процесс декомпозиции фактически сводится к кластеризации этого графа.
Пока что создать полностью автоматический алгоритм кластеризации, который бы давал удовлетворительные результаты, мне не удалось, поэтому кластеризация выполняется вручную.
И так как человеку проще выполнять кластеризацию графа, представленного визуально, я разработал специальную диаграмму, для представления графов эффектов.</p><p>Концептуальная модель системы и нотация диаграммы подробно описаны в <a href=https://azhidkov.pro/effects-diagram/specification-html/>спецификации</a>.
Упрощённо же можно считать, что:</p><div class=ulist><ul><li>Операции - это эндпоинты REST API;</li><li>Ресурсы - таблицы БД;</li><li>Эффекты записи - SQL INSERT/UPDATE/DELETE запросы;</li><li>Эффекты чтения - SQL SELECT-запросы.</li></ul></div><p>Соотвественно, для построения диаграммы эффектов, надо для каждого метода API добавить на диаграмму по прямоугольнику светло-синего цвета, для каждой таблицы добавить по прямоугольнику тёмно-синего цвета, для каждого запроса модификации данных добавить красную стрелку между соответствующей операцией и ресурсом, а для каждого запроса чтения данных - синюю стрелку.
В результате у вас получится картинка, состоящая из таких элементов:</p><div class=image-block><img src=/drafts/effects-diagram/images/short-notation-example.svg alt="short notation example"></div><p>Здесь, очевидным образом, операция "Зарегистрировать пользователя" вносит данные в таблицу "Пользователи", а операция "Аутентифицировать пользователя" считывает данные из этой таблицы.
Процесс построения диаграммы эффектов реального проекта с примерами всех распространённых видов ресурсов и операций описан в посте <a href=https://azhidkov.pro/posts/22/06/220611-true-story-project/>Диаграмма эффектов: пример построения</a>.</p><p>Также важно отметить, что все элементы диаграммы эффектов один в один транслируются в код:</p><div class="olist arabic"><ol class=arabic><li>Операции - в методы классов сервисов приложения;</li><li>Ресурсы - в классы сущностей и репозиториев (событий и топиков брокеров сообщений, ДТО и клиентов REST API и т.д.);</li><li>Эффекты - в вызовы методов классов репозиториев в методах классов сервисов.</li></ol></div><p>И вот мы наконец-то можем перейти непосредственно к декомпозиции на базе диаграммы эффектов.</p></section><section class="doc-section level-2"><h3 id=_декомпозиция_на_базе_диаграммы_эффектов><a class=link href=#_декомпозиция_на_базе_диаграммы_эффектов>Декомпозиция на базе диаграммы эффектов</a></h3><p>В основе декомпозиции на базе эффектов лежит несколько простых и хорошо известных идей:</p><div class="olist arabic"><ol class=arabic><li>Ресурсы являются глобальными переменными;</li><li>Между всеми методами, которые взаимодействуют с одним ресурсом, появляется сцепленность через общее окружение (common environment coupling);</li><li>Один из основных методов снижения сцепленности системы в целом - это локализация сцепленности через общее окружение в модулях;</li><li>Запись глобальной переменной порождает большую сцепленность, чем чтение.</li><li>В связях между модулями не должно быть циклов;</li><li>Если модулю сложно дать хорошее имя, отражающее его содержание, это говорит о низкой функциональной связанности модуля.</li></ol></div><p>То, что запись порождает большую сцепленность, чем чтение - может быть не очевидно.
Однако это легко продемонстрировать, если рассмотреть их в контексте многопоточной работы.
Считывать глобальную переменную могут сколь угодно много потоков без какой-либо синхронизации и проблем.
Но, как только кто-то начинает изменять эту переменную, всё тут же становится намного сложнее: теперь надо обеспечить безопасный доступ и не создать дедлок, обеспечить протокол взаимодействия (сначала запись, потом чтение), следить за тем, чтобы операция записи не стала бутылочным горлышком в производительности системы и т.д.</p><p>Вооружившись этими идеями, легко определить требования к хорошей декомпозиции (кластеризации) диаграммы эффектов:</p><div class="olist arabic"><ol class=arabic><li>Между кластерами нет циклов;</li><li>Эффекты записи (красные стрелки) инкапсулированы в одном кластере;</li><li>Количество эффектов чтения (синих стрелок), пересекающих границы кластеров, минимально;</li><li>Каждому кластеру легко дать имя, отражающее его содержание.</li></ol></div><p>Для простых диаграмм такая кластеризация может быть видна на глаз.
Примером простой диаграммы является диаграмма эффектов проекта True Story Project:</p><p>(<mark>todo: картинка геосервисов</mark>)</p><p>Здесь сразу же бросаются в глаза 3-4 кластера:</p><div class="olist arabic"><ol class=arabic><li>Работа с изображениями;</li><li>Формирование фида;</li><li>Интеграция с 2Гис;</li><li>Интеграция с Яндекс.Картами.</li></ol></div><p>Тут хорошо видно, что интуитивная декомпозиция зависит и от разработчика диаграммы (как он расположит элементы) и от наблюдателя - я на этой диаграмме вижу 4 кластера, но некоторые другие люди "автоматически" объединяют интеграции в один модуль.</p><p>Для того того, чтобы повысить степень детерминированности результата декомпозиции, я разработал специальный алгоритм.</p></section><section class="doc-section level-2"><h3 id=_алгоритм_декомпозиции_на_базе_диаграммы_эффектов><a class=link href=#_алгоритм_декомпозиции_на_базе_диаграммы_эффектов>Алгоритм декомпозиции на базе диаграммы эффектов</a></h3><p>Алгоритм состоит из двух больших этапов - механистический и гуманистический.
Механистический этап может быть практически полностью автоматизирован и выполняться буквально по шагам.
Но он не всегда может породить полную кластеризацию, а в тех случаях когда может - как правило опытный инженер может доработать получившийся результат в лучшую сторону.</p><p>Механистическая кластеризация является итеративной и каждая итерация состоит из трёх этапов:</p><div class="olist arabic"><ol class=arabic><li>Генерация кластеров</li><li>Расширение кластеров</li><li>Агрегация ресурсов</li></ol></div><p>Генерация кластеров заключается в том, чтобы перебрать все некластеризаванные ресурсы и кластеризовать их с операциями, которые:</p><div class="olist arabic"><ol class=arabic><li>Связаны только с этим ресурсом</li><li>Связаны с этим ресурсом своим единственным эффектом записи</li><li>Являются операциями чтения, для которых данных ресурс является первичным.
Определение первичного ресурса (и вообще его наличия) остаётся на усмотрение исполнителя.</li></ol></div><p>Расширене кластеров заключается в том, чтобы перебрать все некластеризованные элементы, связанные только с c элементами внутри одного кластера и добавить их в этот кластер.</p><p>Этап агрегации ресурсов заключается в том, чтобы оставшиеся не кластеризованные ресурсы попытаться объединить в "разумные" группы между собой или с кластеризованными ресурсами.
Строго говоря, на этапе агрегации надо перебрать все возможные попарные соединения и выбрать из них "наилучшие".
Однако на практике "наилучшие" пары как правило имеют общую операцию, поэтому эмпирический алгоритм агрегации выглядит так:</p><div class="olist arabic"><ol class=arabic><li>Для каждого некластеризовнного ресурса, выбрать ресурсы, с которыми у него есть общая операция</li><li>Если в списке есть "разумная" пара данному ресурсу - сгруппировать их.
Универсального и формализованного критерия разумности я пока что не нашёл, поэтому это решение остаётся за исполнителем.</li></ol></div><p>Далее сгруппированные ресурсы рассматриваются как единое целое, в частности все эффекты связывающие любой из ресурсов этой группы с одной и той же операцией считаются одним эффектом.
Если операцию связывают с группой и эффекты чтения и эффекты записи, то считается что операция связана с группой эффектом записи.</p><p>После агрегации ресурсов снова возвращаемся к этапу генерации кластеров.
Если этапы генерации и расширения кластеров не привели к уменьшению количества некластеризованных элементов, то, теоретически, этап агрегации можно снова повторить и продолжать это делать до включения всех оставшихся ресурсов в одну группу.
Однако практически уже на второй последовательной итерации агрегации (когда одина группа некластеризованных ресурсов содержит в себе три базовых) пора становиться на стороже и внимательно смотреть на получающиеся группы ресурсов и связанные с ними и операции и, возможно, вернуться к этапу проектирования самих операций и ресурсов.</p><p>Третью итерацию (агрегацию 4ёх ресурсов), на мой взгляд стоит выполнять просто на всякий случай, но сам факт необходимости в ней говорит либо о серьёзных ошибках в дизайне операций и агрегатов (по определению агрегатов, как единиц транзакционности), либо о том, что декомпозиция на базе эффектов не подходит для вашей задачи.</p><p>В результате применения этого алгоритма, вы получите либо полную, либо частичную первичную декомпозицию.
Но в любом случае лишь первичная декомпозиция и её надо проверить на соответствие здравому смыслу и, при необходимости - доработать.
И так как здесь приходится работать уже с семантикой и особенностями конкретной предметной области, а машины в "понимании" всё ещё слабы, мы вынуждены перейти к гуманистической и слабо предсказуемой части.</p><p>Если механический этап породил частичную декомпозицию, то её придётся завершить вручную.
Очевидным образом, на этом этапе останутся некластеризованными только те элементы, которые связаны с двумя и более кластерами.
И тут для каждого элемента есть несколько вариантов:</p><div class="olist arabic"><ol class=arabic><li>Для некластеризованных операций записи в первую очередь стоит рассмотреть вариант расцепки операции через очередь сообщений.</li><li>Если с одним из кластеров элемент связан бОльшим количеством связей или эти связи кажутся "сильнее" - его можно внести в тот кластер, с которым он сильнее связан.
В случае операции, тут стоит принять во внимание её клиента (внешнюю сущность, инициирующую выполнение операции) - если с одним из кластеров у неё общий клиент, то связь с этим кластером кажется сильнее;</li><li>Если элемент выглядит связанным со всеми кластерами в равной степени - его можно поместить в собственный кластер.
В этот же кластер, возможно, можно будет добавить другие элементы связанные с теми же кластерами.</li><li>Если кластеры, связанные элементом имеют высокую функциональную связанность - их все можно объединить в один кластер.</li><li>Если все эти варианты выглядят странно или нелогично - возможно стоит вернуться к дизайну операций и ресурсов.</li><li>Ещё вариант - пересмотреть состав существующих кластеров, возможно тогда получится получить логичную картинку.</li></ol></div><p>После получения полной кластеризации, каждому кластеру необходимо дать имя, отражающее его содержание.
В случае хорошей декомпозиции - это не составит труда.
Если же определить имя какого-то кластера не получается, то необходимо рассмотреть его внимательнее.
Достаточно часто такие проблемы решаются с помощью разделения проблемного кластера на два более мелких и сфокусированных.
Но поиск разумного имени кластера может привести и к редизайну ресурсов и операций.</p><p>После того, как каждому кластеру дано разумное имя полезно проделать ещё одно упражнение - нарисовать граф кластеров.
Такая визуализация помогает увидеть "лес за деревьями" и оценить "разумность" уже самого леса.</p><p>Наконец, последний шаг, особенно если получилось больше 5 кластеров - найти подмодули и функционально схожие модули.
Подмодуль - это модуль, обеспечивающий работу одного базового модуля.
В этом случае кластер подмодуля необходимо поместить в кластер модуля.
Как понять, что один модуль обеспечивает работу другого?
К сожалению у меня только общие слова.
Посмотрите в сторону уровней абстракции и политик/механизмов.</p><p>Функционально схожие модули - это модули, выполняющие разными способами одну и ту же функциональность, либо выполняющие разные подфункции одной общей функции.
Такие модули надо объединить в общий кластер.
Этому кластеру так же надо дать имя и если это вызывает затруднения, то от объединения лучше отказаться.</p><p>Наконец, последнее полезное упражнение - провести топологическую сортировку графа модулей.
Это позволит вам определить стабильность модулей (отношение количества входящих зависимостей к количеству исходящих) и убедиться, что техническая стабильность модулей согласована со стабильностью частей предметной области.
(<mark>todo: для этого не надо выполнять сортировку</mark>)</p><p>Всё, теперь можно создавать структуру директорий, соответствующую структуре кластеров, в каждой директории создавать по классу сервиса со всеми операциями кластера и по классу репозитрия/клиента/топика для каждого ресурса кластера.
Так же, в целях снижения сцепленности, в сервисы модуля надо будет добавить по методу на каждую стрелку, входящую в кластер.</p><p>Теперь рассмотрим процесс выполнения декомпозиции реального проекта.</p></section></section><section class="doc-section level-1"><h2 id=_кейс_кэмп><a class=link href=#_кейс_кэмп>Кейс: Кэмп</a></h2><p>Примеры в программировании и особенно дизайне - это всегда боль.
Слишком простые или синтетически не особо полезны.
Слишком сложные и реальные - мало кто станет в них вгружаться, и сложно отделить релевантые детали от лишнего шума.
Кэмп явлется на мой взгляд золотой серединой.</p><p><a href="https://play.google.com/store/apps/details?id=ru.ngtrans.camp">Кэмп</a> - реальный проект который стоил семизначную сумму для заказчика и выполнялся командой из 12 человек в пике, бакенд делали два разработчика и сейчас находится в промышленной эксплуатации.
Суммарно на выполнение проекта было затрачено 5500 человеко/часов, из которых 950 - на бакенд.</p><p>Но это был экспериментальный проект, который (с согласия заказчика) выполнялся силами исключительно молодых специалистов, а лиды только проводили ревью и помогали консультациями.
Поэтому по фактическому объёму функциональности проект достаточно компактный.</p><p>Проект является специализированной геоинформационной системой для водителей-дальнобойщиков.
В отличие от больших ГИС систем вроде Яндекс.Карт он отличается тем, что позволяет найти не просто гостиницу по дороге, а гостиницу где водитель может и сам переночевать и рефрижиратор на 86 "кубов" припарковать.</p><p>Соответственно двумя ключевыми сущностями являются водители и "точки" (кафе, заправки, СТО и т.п.).
Точки в систему вносят сами пользователи после предварительной модерации.
С водителями связаны характеристики машин, которые они водят (сейчас - только тип машины и размер колёс), а с точками - характеристики машин, которые они в состоянии обслужить.</p><p>Кроме того, в системе реализована система пуш-уведомлений пользователей о новостях приложения, а так же о результатах модерации добавленной точки.</p><p>Вся эта функциональность отражена не следующей диаграмме эффектов:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig.drawio.svg alt="camp effects orig.drawio"></a></div><p>Теперь давайте прогоним по этой диаграмме алгоритм декомпозиции на базе эффектов и посмотрим, что получится.</p><section class="doc-section level-2"><h3 id=_декомпозиция_диаграммы_эффектов_кэмпа><a class=link href=#_декомпозиция_диаграммы_эффектов_кэмпа>Декомпозиция диаграммы эффектов Кэмпа</a></h3><p>Для того, чтобы диаграмма лучше помещалась на страницу, я разобью её на две - основную (верхний независимый граф) и уведомления (нижний граф).
Начнём с основой диаграммы.</p><p>И так, поехали.
Что у нас там первое?
Надо перебрать все ресурсы и объединить их сильно связанными с ними операциями.
Перебирать будем в "естественном" порядке - сверху вниз, слева на право по связям.</p><p>И начнём с ресурса "Сервис отправки СМС".
С ним связана только операция "Запросить OTP", однако она сама связана операциями записи с другими ресурсами, поэтому пока её откладываем.
То же самое с ресурсом "OTP".</p><p>Далее идёт ресурс "Токены".
Его мы наконец можем объединить с операцией "Получить токен из логина/пароля" и получить первый кластер (на первом этапе я буду именовать кластера по порядковому номеру их добавлению на диаграмму).
Операция "Получить токен из отп" тоже явно просится в этот кластер, но так как она связана эффектом записи с другим ресурсом мы её пока откладываем.</p><p>Далее идёт ресурс "Пользователи".
Только с ним связаны операции "Изменить пользователя" и "Удалить пользователя", а для операции "Получить пользователя" он явно является первичным и она не связана эффектами записи с другими ресурсами.
Объединяем их все в новый кластер.</p><p>Затем рассмотрим схожие ресурсы "Типы машин" и "Размер колес", оба ресурса связаны эффектами чтения с двумя операциями и не один из них не выступает первичным для этих операций, поэтому пока что пропустим их.</p><p>Далее у нас снова схожая пара ресурсов "Услуги" и "Тэги".
Оба ресурса связаны своим единственным эффектом чтения с операцией "Получить точки".
Объединяем их все в кластер.</p><p>Теперь переходим к ресурсу "Точки на карте".
Он явно является первичным для операции "Получить точки", которая уже находится в кластере.
Кроме того, он является единственным ресурсом операции "Создать точку".
Добавляем их в последний созданный кластер.</p><p>Остался последний ресурс - "Топик 'Точка промодерирована'".
Связанные с ним операции - "Удалить точку" и "Изменить точку" связаны эффектами записи с другими ресурсами, поэтому этот ресурс пока что оставляем некластеризованным.</p><p>На этом первая итерация генерации кластеров заканчивается и у нас получается такая промежуточная кластеризация:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-main-1.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-main-1.drawio.svg alt="camp effects orig main 1.drawio"></a></div><p>Далее идёт этап расширения кластеров, на котором все некластеризованные элементы, связанные только с одним кластером надо поместить в этот кластер.
Сейчас у нас таких элементов нет - все они связаны либо с двумя кластерами, либо с кластерами и другими некластеризованными элементами.</p><p>Поэтому переходим к следующему этапу - агрегации ресурсов.
Для этого перебираем оставшиеся некластеризованные ресурсы и смотрим есть ли для них "разумная" пара, с которой они связаны общей операцией.
Перебор снова будем делать в "естественном" порядке.</p><p>Поэтому снова начинаем с ресурса "Сервис отправки СМС".
Он через операцию "Запросить OTP" связан с ресурсом "OTP".
Образуют ли они "разумную"" группу?
Вообще разумный вопрос.
Связаны они тем, что сервис является механизмом доставки OTP.
Но сам сервис теоретически может использоваться для доставки другой информации, и OTP можно доставлять с помощью других механизмов.
Тем не менее, прямо сейчас все они решают одну конкретную задачу - обеспечение пользователя одноразовым паролем для входа и я решаю агрегировать эти два ресурса.</p><p>Затем идёт пара ресурсов "Типы машин" и "Размер колес".
И то и другое является атрибутами машин, поэтому их я тоже решаю агрегировать.</p><p>И у нас остался последний, некластеризованный ресурс - "Топик 'Точка промодерирована'".
Он через операции "Удалить точку" и "Изменить точку" связан с ресурсом "Точки на карте" и является механизмом оповещения об изменениях в последнем.
На мой взгляд они формируют разумную группу и этот ресурс можно занести в кластер.</p><p>После выполнения всех этих агрегаций, у нас получается следующий этап кластеризации:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-main-2.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-main-2.drawio.svg alt="camp effects orig main 2.drawio"></a></div><p>Теперь заходим на вторую итерацию, однако некластерезованных ресурсов у нас уже не осталось, поэтому переходим сразу к этапу расширения кластеров.</p><p>На этом этапе, мы очевидным образом заносим операцию "Запросить OTP" в первый кластер, а операции "Удалить точку" и "Изменить точку" - в третий.</p><p>После этого у нас остаётся один некластеризованный элемент - операция "Получить токен из отп":</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-main-3.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-main-3.drawio.svg alt="camp effects orig main 3.drawio"></a></div><p>Эта операция связана двумя эффектами записи с разными кластерами, поэтому механестически её кластеризовать не получится и надо переходить к гуманистической части.</p><p>Однако, напомню, из-за ограничений размера страницы у нас остался не кластеризованным граф уведомлений.
Поэтому давайте сначала кластеризуем его и закончим с мехнестической частью.</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-notifications-0.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-notifications-0.drawio.svg alt="camp effects orig notifications 0.drawio" height=500></a></div><p>И так, на суку висит мочало, начинаем всё сначала.
А именно - объединяем ресурсы с операциями, которые связаны только с ним.</p><p>Начнём с ресурса "Сервис отправки Push-уведомлений".
С ним связано две операции, но под критерии текущего этапа подходит только одна - "Создать персональные уведопления".
Объединяем их в кластер.</p><p>Далее идёт ресурс "Уведомления".
С ним связаны пять операций - "Создать новостное уведомление", "Создать персональные уведомления", "Удалить уведомление", "Получить список новостных уведомлений", "Получить список персональных уведомлений".
Первые две отбрасываем, так как они связаны эффектом записи с другим ресурсом.
А вот остальные операции подпадают под наши критерии (для "Получить список персональных уведомлений" ресурс является первичным).
Объединяем их в кластер.</p><p>Наконец остаётся только ресурс "Прочитанные уведомления", который однозначно кластеризуется с "Прочитать уведомление":</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-notifications-1.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-notifications-1.drawio.svg alt="camp effects orig notifications 1.drawio"></a></div><p>На этом первая часть механистического подхода завершается и можно переходить к расширению кластеров.</p><p>Но тут мы снова упираемся в проблему.
Эта операция связана с двумя кластерами, один из которых зависит от другого.
Поэтому, чтобы исключить циклы в графе у нас остаётся только вариант подтянуть эту операцию в первый кластер.
Но тогда у нас операции создания уведомлений, изменяющие ресурс уведомлений окажутся в другом кластере.
При том какой из ресурсов этих операций является для них первичным - коллекция уведомлений или пуш сервис - вопрос дискуссионый.
В общем и тут мы снова упираемся в границы механистического подхода и надо переходить к гуманистической части.</p><p>Гуманестическую часть я предлагаю начать, с того, чтобы вернуться к основному графу и решить что делать с оставшейся не кластеризованной операцией "Получить токен из отп".
И тут у нас есть целая россыпь вариантов, как поступить с ней:</p><div class="olist arabic"><ol class=arabic><li>Внести в четвёртый кластер.</li><li>Внести в первый кластер.</li><li>Расцепить через очередь сообщений</li><li>Объединить первый и четвёртый кластер и внести туда.</li><li>Операции получения токенов занести в четвёртый и второй кластеры и сделать новый кластер вокруг ресурса "Токены".</li></ol></div><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-main-4-variants.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-main-4-variants.drawio.svg alt="camp effects orig main 4 variants.drawio" height=500></a></div><p>В целом, все эти варианты имеют право на жизнь.
Но давайте рассмотрим их с точки зрения "тяжести" графа - пусть связь между кластерами синей стрелкой будет стоить одну единицу, а красной - две.
В этом случае вес вариантов выше будет следующий:</p><div class="olist arabic"><ol class=arabic><li>4</li><li>3</li><li>1</li><li>1</li><li>5</li></ol></div><p>Вполне предсказуемо, выигрывают варианты 3 и 4, которые исключают эффект записи между кластерами.
Какой вариант выбрать из них?
Я выбираю 4.
Потому что на данном этапе и OTP и сервис отправки смс являются деталями реализации модуля аутентификации:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-main-4.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-main-4.drawio.svg alt="camp effects orig main 4.drawio"></a></div><p>Тут у опытного разработчика может включиться "чуйка" и он подумает о том, что если вытащить аутентификационные данные из пользователя в отдельный ресурс и поместить в первый кластер, то сцепленность системы можно ещё уменьшить.
Но выполнение этого я оставлю в качестве упражнения и вернусь к подграфу нотификаций.</p><p>Из этой ситуации можно выйти несколькими разными способами:</p><div class="olist arabic"><ol class=arabic><li>Поместить операцию в первый кластер и сказать, что это нормально.</li><li>Объединить первый и второй кластеры и поместить её туда.
Заодно туда же можно поместить и третий кластер и оставить один большой кластер для уведомлений.</li></ol></div><p>Однако, зная контекст, в этот момент можно обнаружить ошибку в изначальной диаграмме эффектов.</p><p>А именно - новостные уведомления, формируются модераторами и отправляются всем пользователям.
А персональные - формируются системой (в ответ на действия модераторв) и отправляются одному пользователю.
Кроме того, хотя система позволяет удалять любые уведомления, фактически удаляются только новостные уведомления.</p><p>И если мы эти две штуки расцепим, то улучшим характеристики сцепленности и связанности системы.
Более того, это позволит нам перенести флаг прочитанности персонального уведомления в сам ресурс уведомлений и упростить реализацию:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-notifications-2.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-notifications-2.drawio.svg alt="camp effects orig notifications 2.drawio"></a></div><p>Наконец мы получили полную кластерезацию:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-clusterization.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-clusterization.drawio.svg alt="camp effects orig clusterization.drawio"></a></div><p>Теперь можно переходить к следующему этапу гуманистической части - именованию кластеров.
На мой взгляд эта задача не представляет труда и название кластеров очевидно:</p><div class="olist arabic"><ol class=arabic><li>Аутентификация.</li><li>Пользователи.</li><li>Машины.</li><li>Точки.</li><li>Новостные уведомления.</li><li>Персональные уведомления.</li></ol></div><p>Переходим к следующему этапу - отрисовка графа кластеров:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/camp/camp-effects-orig-clusters-graph.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/camp/camp-effects-orig-clusters-graph.drawio.svg alt="camp effects orig clusters graph.drawio"></a></div></section></section><section class="doc-section level-1"><h2 id=_ограничения_подхода_к_декомпозиции_на_базе_эффектов><a class=link href=#_ограничения_подхода_к_декомпозиции_на_базе_эффектов>Ограничения подхода к декомпозиции на базе эффектов</a></h2><p>Основное ограничение подхода заключается в том, что он всё ещё находится на стадии опытной эксплуатации и максимальный размер проекта, который я по нему декомпозировал составляет один человеко-год.</p><p>С точки зрения типа и характера задач, подход на базе эффектов хорошо подходит для декомпозиции систем с богатым состоянием и правилами его изменения.
Если же в системе состояния как такого не много - компилятры, например, или системы потоковой обработки информации, ток декомпозировать такую систему на основе эффектов не получится.</p></section><section class="doc-section level-1"><h2 id=_характеристики_подхода_к_декомпозиции_на_базе_эффектов><a class=link href=#_характеристики_подхода_к_декомпозиции_на_базе_эффектов>Характеристики подхода к декомпозиции на базе эффектов</a></h2><p>Итак, для того чтобы максимизировать количество дофамина и минимизировать количество кортизола в команде, на нужен подход к декомпозиции, который обладает следующими характеристиками:</p><div class="olist arabic"><ol class=arabic><li>Вообще есть;</li><li>Прост в изучении;</li><li>Прост в исполнении;</li><li>Даёт хорошие результаты вне зависимости от исполнителя;</li></ol></div><p>Обладет ли подход к декомпозиции на базе эффектов этими характеристиками?</p><p>Он безусловно есть.
Возможно пока что описан не идиально, но я продолжу работы в этом направлении.</p><p>Для меня он существенно проще в изучении и исполнеии чем DDD.
Является ли он таковым для вас - судить вам.
Вы можете попробовать его применить в своём проекте или его небольшой части - это займёт не много времени, и вне зависимости от результатов поможет вам лучше понять свою систему.
По моему опыту трудозатраты на декомпозицию на базе эффектов идут в соотношении 1-2 человеко/часа проектирования к 1 человеко-месяцу разработки.
Соответсвенно, со скидкой на отсутсвие опыта, на декомпозицию проекта на 2 человеко-месяца вам должно хватить одного человеко-дня.</p><p>Наконец, результаты декомпозиции на базе эффектов всё-таки зависят от исполнителя, но в меньшей степени, чем интуитивная декомпозиция или декомпозиция на базе границ в языке предметной области.</p></section></article></section></div></main><script src=/js/app.js></script></body></html>