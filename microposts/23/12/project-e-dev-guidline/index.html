<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Гайдлайн разработчика Проекта Э - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/microposts/23/12/project-e-dev-guidline/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/microposts/23/12/project-e-dev-guidline/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/microposts/23/12/project-e-dev-guidline/><title>Гайдлайн разработчика Проекта Э - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/microposts/23/12/project-e-dev-guidline/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Гайдлайн разработчика Проекта Э</h1></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Этот материал является "микропостом" - текстом, написанным в режиме потока сознания без особой редактуры.</p><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><p><br></p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>После написания первоначальной версии в конце 2022 года я этот гайдлайн практически не актуализировал, хотя по ходу работы что-то просто не прижилось, а что-то оказалось плохой затеей.
Все такие места я постарался подсветить в тексте соответствующими предупреждениями.</p></aside><p>Этот микропост является практически полной копией (за исключением небольших правок во имя NDA) Confluence-страницы "Руководство разработчика Проекта Э".</p><section class="doc-section level-1"><h2 id=_общая_структура_системы><a class=link href=#_общая_структура_системы>Общая структура системы</a></h2><p>Систему следует разрабатывать в соответствии с принципами <a href=https://azhidkov.pro/ergo-approach/landing/>Эргономичного подхода</a>.</p><p>В частности необходимо придерживаться эргономичной структуры информационных систем:</p><div class=image-block><a class="image bare" href=/microposts/23/12/images/erogonomic-programs-structure-v2-overview.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/microposts/23/12/images/erogonomic-programs-structure-v2-overview.drawio.svg alt="erogonomic programs structure v2 overview.drawio"></a></div><p>Физически декомпозиция осуществляется по средствам пакетов.</p><p>Общее правило: рекомендуемый размер пакета составляет 3-6 элементов (файлов или подпакетов).
Для пакетов меньшего размера стоит рассмотреть возможность их включения в родительский пакет, для пакетов большего размера стоит рассмотреть возможность выделения подпакетов.
Пакеты с 10 и более элементами допустимы только в исключительных случаях.</p><p>Здесь мы начнём с третьего приближения - устройство Бэка.</p></section><section class="doc-section level-1"><h2 id=_устройство_бэка><a class=link href=#_устройство_бэка>Устройство Бэка</a></h2><div class=image-block><img src=/microposts/23/12/images/erogonomic-programs-structure-v2-backend.drawio.svg alt="erogonomic programs structure v2 backend.drawio"></div><p>На самом верхнем уровне код реализации бэка делится на три части:</p><div class="olist arabic"><ol class=arabic><li>Приложение</li><li>Ядро</li><li>Платформа</li></ol></div><section class="doc-section level-2"><h3 id=_приложение_и_платформа><a class=link href=#_приложение_и_платформа>Приложение и платформа</a></h3><p>Приложение и платформа содержат реализацию "cross-cutting concerns" - функциональности общей для всех/многих модулей ядра.
Разница между ними в том, что приложение содержит функциональность заточенную собственно под приложение, а платформа - функциональность, которую потенциально можно переиспользовать в других проектах.
Ещё один критерий разделения кода приложения и платформы - то, что вызывается фреймворком - попадает в приложение, то что вызывается ядром - в платформу.</p><p>Пример функциональности приложения: точка входа, авторизация, метрики для мониторинга.</p><p>Пример функциональности платформы: фреймворк обработки ошибок, реализация RPC через RabbitMQ, АПИ хранилища изображений.</p><p>Особых гайдлайнов разработки приложения и платформы пока нет - просто стараемся писать в соответствии с общепринятыми лучшими практиками.</p></section><section class="doc-section level-2"><h3 id=_ядро><a class=link href=#_ядро>Ядро</a></h3><p>Ядро приложения содержит код, реализующий функциональность приложения - то ради чего приложение написано.
В нашем случае это, в первую очередь, сбор и обработка данных с устройств.
Туда же входит вспомогательная функциональность - сбор событий других типов, хранение и обработка профилей, реализация функциональности наблюдения и т.п.</p><section class="doc-section level-3"><h4 id=_устройство_ядра><a class=link href=#_устройство_ядра>Устройство ядра</a></h4><div class=image-block><img src=/microposts/23/12/images/erogonomic-programs-structure-v2-core.drawio.svg alt="erogonomic programs structure v2 core.drawio"></div><p>В общем случае на этом уровне действует гайдлайн, что должно ядро быть декомпозировано на слабосвязанные модули на базе эффектов.
Однако на текущем этапе (на момент написания этого текста) модули даны нам "свыше" и в ядре мы повторим текущую структуру микросервисов.
После проведения реинженеринга, мы вернёмся к вопросу декомпозиции и перепроектируем модули на базе эффектов.</p><p>Модульная структура рекурсивна - каждый из модулей реализации ядра системы, в свою очередь так же может быть реализован несколькими модулями, каждый из которых снова может быть реализован несколькими модулями и т.п.</p><p>Модули одного уровня вложенности должны образовывать ацикличный направленный граф.</p><p>Так же важно отметить, что на этом уровне продолжает действовать общий гайдлайн на рекомендуемое количество элементов в пакете (количество верхнеуровневых модулей системы) равное 3-6 и не более 10 модулям.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Практика показала, что такой подход плохо масштабируется.
Поверхностно я писал об этой проблеме у себя в <a href=https://t.me/ergonomic_code/326>канале</a>, но планирую один из ближайших постов посвятить критике этого подхода на конкретных примерах из Проекта Э.</p></aside></section><section class="doc-section level-3"><h4 id=_дальнейшее_чтение><a class=link href=#_дальнейшее_чтение>Дальнейшее чтение</a></h4><p>Декомпозиция на базе эффектов:</p><div class="olist arabic"><ol class=arabic><li><a href=https://azhidkov.pro/posts/23/04/ergonomic-decomposition/>Пакетирование по объектам, ака объектно-ориентированная декомпозиция</a></li></ol></div><p>Похожие подходы к компонентной архитектуре:</p><div class="olist arabic"><ol class=arabic><li><a href="https://www.youtube.com/watch?v=-VmhytwBZVs&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=38">Let’s build components, not layers</a></li><li><a href=https://reflectoring.io/java-components-clean-boundaries/>Ранний пост с этой идеей того же автора</a></li><li><a href=https://polylith.gitbook.io/polylith/>Polylith</a></li></ol></div></section></section><section class="doc-section level-2"><h3 id=_устройство_подмодуля_ядра><a class=link href=#_устройство_подмодуля_ядра>Устройство (под)модуля ядра</a></h3><div class=image-block><img src=/microposts/23/12/images/erogonomic-programs-structure-v2-module.drawio.svg alt="erogonomic programs structure v2 module.drawio"></div><p>По определению, модуль логически делится как минимум на интерфейс и реализацию.</p><p>Помимо того, если функциональность модуля "выставлена" во внешний мир, модуль может включать в себя порты, принимающие сигналы от внешнего мира.</p><p>Наконец, если модуль "исполняемый" (должна быть возможность запустить его обособленно от остальной системы, в тестах, например), то он должен содержать класс Spring-конфигурации, для конструирования графа объектов модуля в рантайме.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Практика показала, что "исполняемость" модулей мы практически не используем.
Ни один модуль до сих пор не запускается обособленно ни где кроме тестов.
А писать тесты на отдельные модули перестали, потому что время запуска теста определяется в первую очередь временем подъёма инфраструктуры, которое одинаково и для запуска всей системы, и для запуска одного модуля.
Кроме того, тесты которые поднимаю всё приложение переиспльзуют контекст и запускают его один раз, а тесты модулей должны запустить по контексту на каждый модуль.</p><p>Тем не менее, я всё ещё рекомендую заводить по конфигу для модуля.
Во-первых, для того чтобы делать таким образом архитектуру более наглядной.
Во-вторых, чтобы было стандартное место для ручного определения бинов, специфичных для модуля.</p></aside><section class="doc-section level-3"><h4 id=_типовые_элементы_реализации_модулей><a class=link href=#_типовые_элементы_реализации_модулей>Типовые элементы реализации модулей</a></h4><p>В корневых подпакетах модуля,можно встретить следующие типовые элементы:</p><div class=ulist><ul><li>api<ul><li>dtos - классы DTO АПИ модуля</li><li>events - классы событий модуля</li><li>model - классы сущностей и объектов-значений из DDD, в случае если они "выставлены" в АПИ</li><li>*Exception - файл с иерархией исключений модуля</li><li>*Service - класс с интерфейсом модуля</li></ul></li><li>internal<ul><li>domain - классы репозитория и сущности модуля и, при наличии, DAO</li><li>submodule1 - код реализации подмодуля</li><li>Submodule2.kt - код реализации подмодуля</li><li>*ServiceImpl - класс реализации интерфейса модуля</li><li>*Props - класс конфигурационных параметров модуля</li></ul></li><li>ports<ul><li>*Controller - Spring MVC контроллер и обработчик ошибок</li><li>*Listener - Spring RabbitMQ слушател</li></ul></li><li>*Config - Spring-конфигурация модуля</li></ul></div><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>На деле оказалось:</p><div class="olist arabic"><ol class=arabic><li>domain - практически не встречается, так как в большинстве модулей модель ушла в api, а в internal остался только сервис и репозиторий</li><li>Submodule2.kt - такая штука у нас одна на весь проект.</li></ol></div></aside><p>Помимо типовых видов элементов (особенно в подпакете internal), вполне допускаются нетиповые элементы.</p><p>В пакет api допускается помещать декларативные интерфейсы с аннотациями специфичными для реализации, по которым в рантайме будут сгенерированы реализации, например интерфейсы Spring Data JDBC репозиториев, MyBatis мапперов, Spring 6 декларативных HTTP клиентов и т.п.</p><p>Физически модуль это всегда пакет.
Но содержимое этого пакета зависит от размера модуля и варьируется от одного класса, до набора подпакетов с разделением реализации на подмодули.</p></section><section class="doc-section level-3"><h4 id=_примеры_модулей><a class=link href=#_примеры_модулей>Примеры модулей</a></h4><section class="doc-section level-4"><h5 id=_модуль_в_одном_классе><a class=link href=#_модуль_в_одном_классе>Модуль в одном классе</a></h5><p>В случае если код модуля тривиальный и он либо "выставляется" через один порт, либо не "выставляется" вообще, то допустимо реализовать его в виде одного класса.
Пример - http-эндпоинт, который конвертирует xlsx в нетипизированный json:</p><div class=ulist><ul><li>xlsx<ul><li>XlsxService</li></ul></li></ul></div></section><section class="doc-section level-4"><h5 id=_модуль_в_одном_пакете><a class=link href=#_модуль_в_одном_пакете>Модуль в одном пакете</a></h5><p>Если весь код модуля умещается в 6 файлах, то все эти файлы можно оставить в корневом пакете модуля:</p><div class=ulist><ul><li>models<ul><li>DeviceModel</li><li>DeviceModelsController</li><li>DeviceModelsRepo</li><li>DeviceModelsService</li><li>UpdateDeviceModelsRequest</li></ul></li></ul></div></section><section class="doc-section level-4"><h5 id=_модуль_с_логическими_подпакетами><a class=link href=#_модуль_с_логическими_подпакетами>Модуль с логическими подпакетами</a></h5><p>В противном случае, на верхнем уровне остаются пакеты api, internal и ports и класс Spring-конфигурации (пакет ports и класс конфигурации - при наличи):</p><div class=ulist><ul><li>firmwares<ul><li>api<ul><li>Firmware</li><li>FirmwaresException</li><li>FirmwaresService</li><li>FirmwareState</li><li>GetFirmwaresRequest</li></ul></li><li>internal<ul><li>FirmwareFile</li><li>FirmwareInfo</li><li>FirmwareInfosRepo</li><li>FirmwareFilesRepo</li><li>FirmwaresRepo</li><li>FirmwaresServiceImpl</li></ul></li><li>ports<ul><li>FirmwaresController</li></ul></li><li>FirmwaresConf</li></ul></li></ul></div><p>При разделении пакета модуля на логические подпакеты, как правило требуется выделение заголовочного интерфейса сервиса, для разрыва циклических зависимостей.</p></section><section class="doc-section level-4"><h5 id=_группировка_функционально_связанных_модулей><a class=link href=#_группировка_функционально_связанных_модулей>Группировка функционально связанных модулей</a></h5><p>Если в пакете интерфейса модуля набирается более 6 файлов или в интерфейсе модуля набирается более 6 операций или здравый смысл (и Диаграмма Эффектов) указывает на то, что в модуле есть относительно изолированные части, то сам модуль необходимо/можно? разбить на два подмодуля на основе эффектов или "здравого смысла".
При этом корневой модуль должен иметь файл конфигурации, который импортирует файлы конфигураций подмодулей и, при необходимости, определяет общие Spring-бины.
Подмодули могут иметь собственные конфигурации, если их необходимо запускать по отдельности (в тестах, например).</p><p>Пример:</p><div class=ulist><ul><li>devices<ul><li>firmwares</li><li>models</li><li>DevicesConfig</li></ul></li></ul></div><p>Пример из <a href=https://azhidkov.pro/posts/22/06/220611-true-story-project/>TSP</a>:</p><div class=ulist><ul><li>feed_provider<ul><li>dgis</li><li>yandex</li></ul></li></ul></div><p>В этом случае два технически независимых модуля реализуют общую функциональность "предоставление фида".</p></section><section class="doc-section level-4"><h5 id=_подмодуль_реализации_в_пакете><a class=link href=#_подмодуль_реализации_в_пакете>Подмодуль реализации в пакете</a></h5><p>Если в пакете реализации модуля набирается более 6 файлов, то реализацию модуля надо декомпозировать на подмодули на основе эффектов или "здравого смысла":</p><div class=ulist><ul><li>email<ul><li>api<ul><li>EmailNotificationsService</li><li>EmailTemplate</li></ul></li><li>internal<ul><li>email_sender<ul><li>api<ul><li>Email</li><li>EmailSender</li></ul></li><li>impl_sendgrid<ul><li>SendGridEmailSender</li><li>SendGridProps</li></ul></li><li>EmailSenderConfig</li></ul></li><li>EmailNotificationsServiceImpl</li><li>EmailTemplates</li><li>SelfInfoProps</li><li>SupportContactsProps</li></ul></li><li>ports<ul><li>FeedbackController</li></ul></li><li>EmailNotificationsConfig</li></ul></li></ul></div></section></section><section class="doc-section level-3"><h4 id=_подмодуль_реализации_в_классе><a class=link href=#_подмодуль_реализации_в_классе>Подмодуль реализации в классе</a></h4><p>Если реализация подмодуля ограничивается 4 классами и 200 строками, его можно оформить в виде одного файла:</p><div class=ulist><ul><li>reports<ul><li>api<ul><li>ReportGenerator</li></ul></li><li>internal<ul><li>PdfGenerator.kt<ul><li>PdfGenerator</li><li>ReportBody</li></ul></li></ul></li><li>ports<ul><li>ReportsController</li></ul></li><li>ReportsConfig</li></ul></li></ul></div></section></section><section class="doc-section level-2"><h3 id=_устройство_реализации_подмодуля_ядра><a class=link href=#_устройство_реализации_подмодуля_ядра>Устройство реализации (под)модуля ядра</a></h3><div class=image-block><img src=/microposts/23/12/images/erogonomic-programs-structure-v2-module-impl.drawio.svg alt="erogonomic programs structure v2 module impl.drawio"></div><p>Модули ядра состоят из традиционных для DDD и чистой архитектуры блоков:</p><div class="olist arabic"><ol class=arabic><li>сущности и объекты-значения, объединённые в агрегаты - описывают модель данных модуля и содержат бизнес-логику ограниченную рамками одного агрегата</li><li>репозитории агрегатов - реализуют абстракцию изменяемой коллекции агрегатов</li><li>сервисы домена - реализуют бизнес-логику затрагивающую несколько агрегатов</li><li>сервисы приложения - отвечают за поток данных между репозиториями и агрегатами и сервисами домена</li><li>технические сервисы (клиенты) - абстрагируют внешние системы (старый бэк, SendGrid, Партнёр1, Партнёр2) внутри системы</li><li>контроллеры - отвечают за адаптацию HTTP-запросов в вызовы методов сервисов приложения</li></ol></div><p>На абстрактные блоки из иллюстрации, эти блоки мапятся следующим образом:</p><div class="olist arabic"><ol class=arabic><li>Оркестрация - сервисы приложения плюс контроллеры в качестве адаптеров сервисов к HTTP-интерфейсу</li><li>Ввод/вывод - репозитории и технические сервисы</li><li>Модель данных и чистые трансформации - агрегаты, сущности, объекты-значения, сервисы домена</li></ol></div><p>Однако относительно DDD и чистой архитектуры на эти блоки накладываются дополнительные ограничения функциональной архитектуры:</p><div class="olist arabic"><ol class=arabic><li>Сущности и агрегаты реализуются в виде неизменяемых структур данных</li><li>Вся бизнес-логика помещается в агрегаты и сервисы домена и реализуется в чистом функциональном стиле (без побочных эффектов)<ol class=loweralpha type=a><li>При этом чистая снаружи функция вполне может использовать мутабельное локальное состояние, при необходимости</li></ol></li><li><a href=https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C>Циколматическая сложность</a> методов сервисов приложения должна стремиться к 1 - не содержать условий и циклов.<ol class=loweralpha type=a><li>Методы сервисов приложения могут содержать защитные выражения, для прерывания потока данных в случае ошибок</li><li>Хорошей метафорой метода сервиса приложения является <a href=https://fsharpforfunandprofit.com/rop/>Railway-Oriented Programming</a> - хэппи-пас метод должен быть прямым как железная дорога из пункта А (запрос) в пункт Б (ответ и эффекты), со съездами на альтернативный путь в случае ошибок.</li></ol></li><li>Методы репозиториев и технических сервисов должны быть реализованы либо в декларативном стиле (Spring Data) либо так же быть прямыми, как железная дорога<ol class=loweralpha type=a><li>Если в методе технического сервиса, помимо ввода-вывода, требуется какая-то обработка, то это сервис надо выделить в отдельный (под)модуль и реализовать его в соответствии с той же базовой структурой - оркестрация, ввод/вывод, трансформации</li></ol></li><li>Идеальный метод контроллера должен быть просто плейсхолдером для аннотаций Spring MVC.
Соответственно его тело - просто проброс вызова в метод сервиса приложения.
При необходимости методы контроллера могут содержать логику по адаптации параметров или ответов под HTTP и код вторичного роутинга - выбор метода сервиса для вызова в зависимости от параметров запросы, который не получается реализовать средствами Spring MVC.</li></ol></div><section class="doc-section level-3"><h4 id=_дальнейшее_чтение_2><a class=link href=#_дальнейшее_чтение_2>Дальнейшее чтение</a></h4><p>Функциональная архитектура:</p><div class="olist arabic"><ol class=arabic><li><a href=https://www.piter.com/product/printsipy-yunit-testirovaniya>Принципы юнит-тестирования</a>, раздел "6.3. Функциональная архитектура</li><li><a href=https://www.amazon.com/Domain-Modeling-Made-Functional-Domain-Driven/dp/1680502549>Domain Modeling Made Functional</a>, глава "A Functional Architecture"</li><li><a href=https://enterprisecraftsmanship.com/posts/immutable-architecture/>Immutable architecture</a></li><li><a href="https://www.youtube.com/watch?v=yTkzNHF6rMs">Boundaries by Gary Bernhardt</a></li><li><a href=https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719>Structured Design</a>, глава "8. THE MORPHOLOGY OF SIMPLE SYSTEMS"</li><li><a href=http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey>Are we there yet</a></li></ol></div><p>DDD:</p><div class="olist arabic"><ol class=arabic><li><a href=https://azhidkov.pro/posts/22/04/220401-aggregates/>Агрегаты</a></li><li><a href=https://www.amazon.com/Domain-Modeling-Made-Functional-Domain-Driven/dp/1680502549>Domain Modeling Made Functional</a>, целиком</li><li><a href=https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215>Domain-Driven Design</a></li><li><a href=https://www.oreilly.com/library/view/patterns-principles-and/9781118714706/>Patterns, Principles, and Practices of Domain-Driven Design</a></li></ol></div><p>Чистая архитектура:</p><div class="olist arabic"><ol class=arabic><li><a href=https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164>Clean Architecture</a></li></ol></div></section></section><section class="doc-section level-2"><h3 id=_обработка_ошибок><a class=link href=#_обработка_ошибок>Обработка ошибок</a></h3><p>Стратегия работы с ошибками следующая:</p><div class="olist arabic"><ol class=arabic><li>Каждый модуль объявляет собственную sealed-иерархию исключений</li><li>Каждый модуль с помощью @ControllerAdvice (привязанный к пакету) объявляет собственный обработчик ошибок, который обязательно мапит все свои исключения на HTTP ответ.
Так же этот обработчик может мапить исключения других модулей.</li><li>Если при обработке запроса модуля вылетает ошибка не замапленная в его обработчике ошибок, то она уходит в GenericWebExceptionHandler и там превращается в 500ку</li></ol></div></section></section><section class="doc-section level-1"><h2 id=_тестирование><a class=link href=#_тестирование>Тестирование</a></h2><section class="doc-section level-2"><h3 id=_терминология><a class=link href=#_терминология>Терминология</a></h3><p><strong>Пользовательский тест</strong> - Это тест, который проверяет систему на соответствие определённому требованию. Источником "вдохновения" такого теста являются бизнес-требования и, соответственно, такой тест (его суть и корректность) можно свободно обсудить с конечным пользователем.</p><p><strong>Девелоперский тест</strong> - Это тест, который проверяет корректность работы отдельного элемента кода - группы классов, класса или функции. Источником "вдохновения" такого теста является разработчик и, соответственно такие тесты не получится обсудить с конечным пользователем.</p><p><strong>Внешний тест</strong> - Тест, который взаимодействует с системой через её внешний интерфейс (HTTP в нашем случае). Внешние тесты запускают всё приложение целиком в режиме, максимально приближенном к боевому.</p><p><strong>Внутренний тест</strong> - Тест, который взаимодействует с системой через прямой вызов методов объектов системы. Внутренние тесты запускают только необходимые части приложения (Spring-конфиги отдельных модулей) и инфраструктуры. Внутренние девелоперские тесты рекомендуется писать без использования Spring вообще.</p></section><section class="doc-section level-2"><h3 id=_принципы><a class=link href=#_принципы>Принципы</a></h3><p>см. <a href=http://xunitpatterns.com/>xUnit Test Patterns</a>, глава 5 "Principles of Test Automation"</p><div class="olist arabic"><ol class=arabic><li>Пишите сначала тесты (Write the Tests First)</li><li>Предпочитайте тестирование через публичный интерфейс (Use the Front Door First)</li><li>Передавайте намерение (Communicate Intent)</li><li>Не меняйте систему для тестов (Don’t Modify the SUT)</li><li>Делайте тесты независимыми друг от друга (Keep Tests Independent)</li><li>Минимизируйте пересечение тестов (Minimize Test Overlap)</li><li>Не вносите тестовую логику в продовый код (Keep Test Logic Out of Production Code)</li></ol></div></section><section class="doc-section level-2"><h3 id=_стратегия><a class=link href=#_стратегия>Стратегия</a></h3><p>Глобально стратегия тестирования следующая:</p><div class="olist arabic"><ol class=arabic><li>При реализации нового эндпоинта, разработчик должен написать новый или дополнить существующий внешний пользовательский тест<ol class=loweralpha type=a><li>На усмотрение разработчика или ревьюевра, функциональность может быть покрыта дополнительными тестами. При этом предпочтение отдаётся внутренним пользовательским тестам, с переходом к девелоперским тестам только в том случае, если "достать" нужный кусок тестируемого кода через пользовательский тест "слишком сложно"</li></ol></li><li>При фиксе бага, разработчик начинает с теста, демонстрирующего отклонение фактического результата от ожидаемого. Рекомендуется делать этот тест внутренним пользовательским, переходя к внешним или девелоперским только в случае необходимости.</li><li>Не надо стесняться удалять девелоперские тесты, если они мешают рефакторингу.</li></ol></div></section><section class="doc-section level-2"><h3 id=_структура_директорий_с_тестами><a class=link href=#_структура_директорий_с_тестами>Структура директорий с тестами</a></h3><div class=ulist><ul><li>tests.cases - собственно тесты<ul><li>app - тесты, затрагивающие несколько модулей и "cross-cutting concerns", специфичные для приложения (авторизация, например)</li><li>core - тесты модулей приложения<ul><li>devices - тесты сфокусированные на коде модуля устройств<ul><li>infra - вспомогательный код, для тестов модуля устройств</li><li>external - внешние пользовательские тесты</li><li>internal - внутренние пользовательские тесты</li><li>unit - внутренние девелоперские тесты<ul><li><em>таких тестов у нас буквально 5 штук на весь проект сейчас</em></li></ul></li></ul></li><li>profile - тесты сфокусированные на коде модуля профиля</li><li>и т.д.</li></ul></li><li>platform - тесты модулей платформы</li></ul></li><li>tests.infra - общий вспомогательный код вспомогательный код</li></ul></div></section></section><section class="doc-section level-1"><h2 id=_связь_функциональной_архитектуры_с_типами_тестоввыбор_типа_теста><a class=link href=#_связь_функциональной_архитектуры_с_типами_тестоввыбор_типа_теста>Связь функциональной архитектуры с типами тестов/выбор типа теста</a></h2><div class=image-block><img src=/microposts/23/12/images/erogonomic-programs-structure-v2-tests.drawio.svg alt="erogonomic programs structure v2 tests.drawio"></div><p>В ключевая проблема в автоматизации тестирования заключается в том, чтобы найти баланс между устойчивостью к рефакторингу и показательностью тестов и скоростью их написания и выполнения.</p><p>Внешние тесты имеют максимальную устойчивость к рефактирнгу и показательность, но их сложно писать (в частности сетапать фикстуру) и они долго выполняются.</p><p>Юнит-тесты (чистых фукнций) писать тривиально и выполняются они мнгновенно, но даже 100% зелённых тестов не гарантирует, что система хотя бы запустится и они зачастую будут требовать доработки при рефакторинге.</p><p>Внутренние тесты, являются компромиссом по всем четырём аспектам - скорость запуска, сложность сетапа, показательность и устойчивость к рефакторингу.</p><p>У нас, зачастую, "бизнес-логика" выглядит так:</p><div class=listing-block><pre class="rouge highlight"><code data-lang=kotlin><span class=kd>val</span> <span class=py>profileId</span> <span class=p>=</span> <span class=nf>getProfileIdForTag</span><span class=p>(</span><span class=n>userId</span><span class=p>)</span>
<span class=kd>val</span> <span class=py>currentTags</span> <span class=p>=</span> <span class=n>tagsRepo</span><span class=p>.</span><span class=nf>getTagsByProfileIdFilteredByNewTagsIds</span><span class=p>(</span><span class=n>profileId</span><span class=p>,</span> <span class=n>ids</span><span class=p>)</span>
                    <span class=p>.</span><span class=nf>ifEmpty</span> <span class=p>{</span> <span class=k>throw</span> <span class=nc>NoChangeableTags</span><span class=p>()</span> <span class=p>}</span>

<span class=c1>// Внимание, бизнес-логика начинается!</span>
<span class=kd>val</span> <span class=py>tagsToDelete</span> <span class=p>=</span> <span class=n>currentTags</span><span class=p>.</span><span class=nf>filter</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>id</span> <span class=k>in</span> <span class=n>ids</span> <span class=p>}</span>
<span class=c1>// Внимание, бизнес-логика окончена!</span>
<span class=n>tagsRepo</span><span class=p>.</span><span class=nf>deleteAll</span><span class=p>(</span><span class=n>tagsToDelete</span><span class=p>)</span>

<span class=k>return</span> <span class=n>tagsToDelete</span></code></pre></div><p>Очевидно, что для хэппи-паса этой операции нам более чем достаточного одного внешнего теста.</p><p>С другой стороны, время от времени у нас бывает и так - &lt;ссылка на GitLab с классом бизнес-логики на 300+ строк, где функции - чистые>.</p><p>На этот класс, по хорошему, тесты писать не переписать.
И если эти тесты писать внешними или даже внутренними, то и их написание и их исполнение займёт вечность.
Возможность быстро покрывать код быстрыми тестами - это одна из основных (но не единственная, стей тюнед) причина, по которой мы применяем функциональную архитектуру.</p><p>Наконец, есть случаи, когда нам надо проверить дополнительные ветки кода интеграции с внешними системами.
Например, фильтрацию с мультивыбором хочется проверить и тестом на пустой список и на 2 элемента.
В этом случае, нам не надо проверять интеграцию с Tomcat и Spring MVC (она уже проверена внешним тестом) и мы считаем интерфейс сервиса практически таким же стабильным, как и REST API, поэтому такие тесты можно написать внутренними, чтобы немного сэкономить времени на их написании и запуске.</p><section class="doc-section level-2"><h3 id=_стратегия_сетапа_фикстуры_бд><a class=link href=#_стратегия_сетапа_фикстуры_бд>Стратегия сетапа фикстуры БД</a></h3><div class="olist arabic"><ol class=arabic><li>При инициализации контейнера, все БД пересоздаются целиком (файл db/db-init.sql, исполняется в Containers.kt)</li><li>Первый тест, который использует БД запускает Flyway, который создаёт схему и наполняет таблицы ссылочными данными (наши стандартные миграции в src/main/resources/db/migration)</li><li>Каждый тест запускает общие инит-скрипты баз, которые удаляют все нессылочные данные (те, что вставлены вне миграций)<ol class=loweralpha type=a><li>Внешние тесты делают это с помощью @CleanupDb</li><li>Внутренние тесты делают это с помощью DbInitializer.executeScripts</li><li>Разница в том, что внутренние тесты поднимают не все конфиги и там не будет всех датасорсов от которых зависит CleanupDb.
Теоретически, мы можем нагенерять пачку Cleanup\*Db, которые зависит только от датасорсов соответствующего модуля, но с &lt;один из разработчиков> почему-то договорились так.
Можем передоговориться.</li></ol></li><li>Каждый тест запускает собственные скрипты, которые вставляют нужные тесту данные с помощью DbInitializer.executeScripts</li></ol></div><p>Т.е. КАЖДЫЙ ТЕСТ должен ПОЛНОСТЬЮ почистить РАБОЧИЕ ДАННЫЕ и САМ вставить МИНИМАЛЬНЫЙ набор нужных ему данных.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>За эту стратегию, обусловленную обстоятельствами, мы <a href=https://azhidkov.pro/posts/23/10/project-e-part2/#_хрупкость_тестов>расплачиваемся до сих пор</a>.</p></aside></section><section class="doc-section level-2"><h3 id=_tdd><a class=link href=#_tdd>TDD</a></h3><p>Разработку рекомендуется вести в TDD-стиле на базе внешних пользовательских тестов.</p><p>Пример цикла реализация требования "Система должна позволять загружать новые прошивки":</p><div class="olist arabic"><ol class=arabic><li>Создаётся тест, который выполняет вызов метода создания прошивки</li><li>Тест запускается и падает</li><li>Создаётся контроллер, принимающий вызов</li><li>Тест запускается и проходит</li><li>В тест добавляется извлечение ИДа из ответа</li><li>Тест запускается и падает</li><li>Реализуется код сохранения прошивки</li><li>Тест запускается и проходит</li><li>В тест добавляется вызов метода получения прошивки по ИД</li><li>Тест запускается и падает</li><li>В контроллер добавляется метод, который принимает вызов и возвращает стаб-объект</li><li>Тест запускается и проходит</li><li>В тест добавляется проверка корректности полей прошивки</li><li>Тест запускается и падает</li><li>Реализуется код получения прошивки по ИД</li><li>Тест запускается и проходит</li><li>Требование реализовано</li></ol></div></section><section class="doc-section level-2"><h3 id=_именование_v0_0_1><a class=link href=#_именование_v0_0_1>Именование (v0.0.1)</a></h3><p>Тесты, проверяющие работоспособность юз кейса разумно называть так, же как и сам юз кейс и в комментариях давать ссылку на него.</p><p>Имена остальных тестов можно формулировать как требование к поведению или функциональности системы: System should provide users ability to login (Система должна предоставлять пользователям возможность входа в систему).</p><p>Ещё один допустимый вариант - констатация факта о системе: User can login into system (Пользователь может залогиниться в систему).</p><p>Практически никогда имя теста не должно содержать слово "test", пример <strong>плохого</strong> имени: Test login (Протестировать логин).</p></section><section class="doc-section level-2"><h3 id=_структура_методов_тестов><a class=link href=#_структура_методов_тестов>Структура методов тестов</a></h3><p>Тест должен состоять из трёх стандартных блоков - <a href=https://martinfowler.com/bliki/GivenWhenThen.html>Given, When, Then</a>.</p><p>В теле теста, эти блоки отмечаются соответствующими комментариями.</p><p>Во внешних тестах, рекомендуется использовать RestAssured-ные Given-When-Then только в блоке When, а доп. запросы, для сетапа фикстуры и врефикации оборачивать во вспомогательные методы.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>От этого правила я теперь отошёл и наборот, RestAssured инкапсулируется в отдельных классах-клиентах и его использование напрямую в классах-кейсов запрещено.</p></aside></section><section class="doc-section level-2"><h3 id=_дальнейшее_чтение_3><a class=link href=#_дальнейшее_чтение_3>Дальнейшее чтение</a></h3><div class="olist arabic"><ol class=arabic><li><a href=https://www.piter.com/product/printsipy-yunit-testirovaniya>Принципы юнит-тестирования</a>, целиком</li><li><a href=http://xunitpatterns.com/>XUnit Test Patterns</a></li><li><a href=https://www.tedinski.com/2019/03/19/testing-at-the-boundaries.html>Testing at the boundaries</a></li><li><a href="https://www.youtube.com/watch?v=vOO3hulIcsY">TDD Revisited</a></li><li><a href="https://www.youtube.com/watch?v=EZ05e7EMOLM">TDD, Where Did It All Go Wrong</a></li></ol></div></section></section><section class="doc-section level-1"><h2 id=_общие_руководящие_принципы_разработки><a class=link href=#_общие_руководящие_принципы_разработки>Общие руководящие принципы разработки</a></h2><div class="olist arabic"><ol class=arabic><li>Код должен обладать высокой функциональной связанностью и низкой сцепленностью</li><li>KISS</li><li>YAGNI</li><li>DRY</li><li>В коде должны отсутствовать циклы в зависимостях</li><li>Объекты и модули должны скрывать детали своей реализации, а клиентский код не должен полагаться на детали реализации</li><li>Модули следует рассматривать как объекты</li><li>В кодировании следует отдавать предпочтение функциональному стилю - неизменяемые структуры данных и чистые функции<ol class=loweralpha type=a><li>Но без фанатизма</li></ol></li><li>В кодировании следует придерживаться практик чистого кода, если это не приведёт к нарушению остальных принципов</li></ol></div><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p><a href=https://t.me/ergonomic_code/385>Недавно</a> я разочаровался в принципах №№1, 6 и 7.</p></aside><section class="doc-section level-2"><h3 id=_дальнейшее_чтение_4><a class=link href=#_дальнейшее_чтение_4>Дальнейшее чтение</a></h3><div class="olist arabic"><ol class=arabic><li><a href="https://www.youtube.com/watch?v=SxdOUGdseq4">Simple Made Easey</a> (есть русские человечьи субтитры)</li><li><a href=https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf>On the criteria to be used in decomposing systems into modules</a></li><li><a href=https://cseweb.ucsd.edu/~wgg/CSE218/Parnas-IFIP71-information-distribution.PDF>Information Distribution Aspects of Design Methodology</a></li><li><a href=https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719>Structured Design</a>, главы "6. COUPLING" и "7. COHESION"</li><li><a href=https://www.amazon.com/Practical-Guide-Structured-Systems-Design/dp/0136907695>Practical Guide to Structured Systems Design</a>, главы "6: Coupling" и "7: Cohesion"</li><li><a href=https://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062)>Applying UML and Patterns</a>, главы, разделы "Information Expert" (применяется на уровне модуля), "Low Coupling", "High Cohesion", "Information Hiding"</li><li><a href=https://www.ozon.ru/category/struktura-i-interpretatsiya-kompyuternyh-programm/>Структура И Интерпретация Компьютерных Программ</a>, глава "3. Модульность, объекты и состояние"</li><li><a href=https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882>Clean Code</a></li><li><a href=https://pragprog.com/titles/vmclojeco/clojure-applied/>Clojure Applied</a>, глава "6. Creating Components"</li><li><a href=https://www.amazon.com/Implementation-Patterns-Kent-Beck/dp/0321413091>Implementation Patterns</a></li><li><a href=https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164>Clean Architecture</a>, Часть 4 "COMPONENT PRINCIPLES"</li><li><a href=https://www.tedinski.com/book/>Ted Kaminski</a></li><li><a href=https://enterprisecraftsmanship.com/posts>Enterprise Craftsmanship</a></li></ol></div></section></section><section class="doc-section level-1"><h2 id=_работа_с_git><a class=link href=#_работа_с_git>Работа с Git</a></h2><section class="doc-section level-2"><h3 id=_именование_веток><a class=link href=#_именование_веток>Именование веток</a></h3><p>Имена веток формируются по шаблону &lt;jira-issue-code>/&lt;short-descr> - например EWS-584/add-spring-profiles.
Можно заводить по несколько веток на одну задачу.</p></section><section class="doc-section level-2"><h3 id=_сообщения_коммитов><a class=link href=#_сообщения_коммитов>Сообщения коммитов</a></h3><p>Используется соглашение, вдохновлённое <a href=https://www.conventionalcommits.org/en/v1.0.0/>Conventional Commits</a></p><p>Используемые типы коммитов:</p><div class=ulist><ul><li><code>build</code>: Изменения сборки (в том числе зависимостей) проекта</li><li><code>chore</code>: Мелкие непонятные изменения (исравление проблем после мёржа/ребейза, забытые изменения и т.п.)</li><li><code>ci</code>: Изменения в скриптах CI</li><li><code>docs</code>: Изменения только в документации</li><li><code>env</code>: Изменения в дев-окружении проекта (добавление/исправление ран-конфигов, скриптов, конфигов тулов, локальный докер-файлов и т.п.)</li><li><code>feat</code>: Изменения добавляющие новую функциональность</li><li><code>fix</code>: Изменения исправляющие баг</li><li><code>ops</code>: Изменения связанные с эксплуатацией проекта (дополнительные параметры конфигурации, логи, метрики, мониторинг и т.п.)</li><li><code>perf</code>: Изменения улучшающие прозводительность</li><li><code>refactor</code>: Рефакторинг</li><li><code>review</code>: Изменения по требованию ревьювера</li><li><code>style</code>: Мелкие стилистические изменения (форматирование)</li><li><code>test</code>: Изменения затрагивающие только тесты</li></ul></div><p>Коммиты пишутся на грамотном русском языке.</p><p>В отличие от Conventional Commits, заголовок сообщение должен содержать после типа через "/" номер основной задачи в рамках которых он выполнен.</p><p>Пример сообщения без тела:</p><div class=listing-block><pre class="rouge highlight"><code>feat/EWS-115: Реализован метод POST /logout</code></pre></div><p>Тело опционально, но его стоит написать, если коммит содержит какие-то неочевидные/необычные решения или вызван какими-то неочевидными/необычными обстоятельствами или мотивами.</p></section></section></article></section></div></main><script src=/js/app.js></script></body></html>