<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Сравнение эффективности работы команд Проекта Э до и после реинжинирига - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/microposts/23/07/project-e-retro-v3/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/microposts/23/07/project-e-retro-v3/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/microposts/23/07/project-e-retro-v3/><title>Сравнение эффективности работы команд Проекта Э до и после реинжинирига - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/microposts/23/07/project-e-retro-v3/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Сравнение эффективности работы команд Проекта Э до и после реинжинирига</h1></header><section class="doc-section level-1"><h2 id=_введение><a class=link href=#_введение>Введение</a></h2><p><a href=https://t.me/ergonomic_code/231>В изначальных критериях успеха</a> этой реинжиниринга <a href=https://azhidkov.pro/ergo-approach/landing/#_проект_э>Проекта Э</a> я целился в то, чтобы как минимум удвоить скорость разработки.</p><p>Субъективные ощущения РП и заказчика противоречат друг другу - РП субъективно видит увеличение скорости разработки, а заказчик - нет.</p><p>Поэтому я перелопатил 517 задач в Jira, чтобы понять объективное состояние дел.
ТЛДР - по статистике количество трудозатрат и багов и правда удалось снизилось в 2 раза.
Подробности исследования - далее в посте.</p></section><section class="doc-section level-1"><h2 id=_методика_оценки_результатов_по_jira><a class=link href=#_методика_оценки_результатов_по_jira>Методика оценки результатов по Jira</a></h2><p>Оценка результатов затруднена целым спектром проблем:</p><div class="olist arabic"><ol class=arabic><li>О разработке оригинальной версии данных практически нет.
Есть только история гита, по которой можно понять размер команды (1 человек) и календарные сроки (9 месяцев - с 13 января - по 8 октября);</li><li>Над проектом работали три разные команды - оригинальная, .net-команда у нас и kotlin-команда у нас;</li><li>В Jira, откровенно говоря, у нас бардачок.
Есть закрытые (и сделанные) задачи без трека.
Есть "небольшие" задачи на десятки часов.</li></ol></div><p>Тем не менее, я постарался сделать максимум для того чтобы "сравнивать апельсины с апельсинами" и получить более-менее адекватный результат.</p><p>Для этого я навёл порядок в задачах и для каждой проставил/актуализировал:</p><div class="olist arabic"><ol class=arabic><li>Тип - задача или баг</li><li>Компонент - .net- или kotlin-back</li><li>метка группировки<ol class=loweralpha type=a><li>irrelevant - мусорные задачи вроде багов-не багов, которые решились в комментах</li><li>admin - все возможные дейлики и прочая активность, не связанная с разработкой</li><li>groups - реализация функциональности групп пациентов в старом и новом бэке</li><li>dumps - реализация функциональности выгрузок в старом и новом бэке</li><li>reengineering - реализация функциональности, которая была в проект на момент приёмки</li><li>misc - новые фичи в .net-беке, реинжиниринг этих фич в kotlin-беке, рефакторинг нового бэка (странных частей оригинального бэка, которые при реинжиниринге были сделаны как есть), новые фичи в kotlin-беке, всякая рабочая текучка</li><li>original-bug - баги оригинального бэка</li></ol></li></ol></div><p>Эту разбивку задач можно визуализировать так:</p><div class=image-block><a class="image bare" href=/posts/23/09/images/tasks-decomposition.jpg title="Open the image in full size" aria-label="Open the image in full size"><img src=/posts/23/09/images/tasks-decomposition.jpg alt="tasks decomposition"></a></div><p>Здесь цветами закодированы группы задач, которые я планирую сравнивать между собой, а серые группы - задачи которые я исключил из сравнения.</p><p>Далее я планирую сравнивать:</p><div class="olist arabic"><ol class=arabic><li>Реализацию групп в старом и новом бэке.
Это лучшая пара, которая у меня есть - полностью идентичная функциональность, относительно крупная фича и по ней относительный порядок в Jira;</li><li>Реализацию выгрузок.
Эта фича хороша тем, что она большая и функциональность полностью идентичная.
Однако операционные характеристики .net- и kotlin-решения сильно разные, поэтому сравнение не совсем адекватное;</li><li>Реализация новых фич и текучка.
Проблема этой пары заключается в том, что тут в задачах наибольший бардак с точки зрения трека (где-то его вообще нет - ушёл в соседнюю и т.п.).
Но это и самая большая пара по объёму выборки, поэтому надеюсь она более-менее адекватно отразит общий тренд;</li><li>Реализацию оригинальной версии и её реинжиниринг.
Проблема этой пары заключается в том, что по разработки оригинальной версии у меня нет подробных данных, а есть только история гита.
Однако по трудозатратам это самая большая пара, поэтому надеюсь что она тоже более-менее адекватно отразит общий тренд.</li></ol></div></section><section class="doc-section level-1"><h2 id=_данные><a class=link href=#_данные>Данные</a></h2><section class="doc-section level-2"><h3 id=_реализация_групп><a class=link href=#_реализация_групп>Реализация групп</a></h3><p>Это небольшая фича по управлению собственно группами пациентов, наблюдаемых одним или более врачем.
Не совсем тривиальная, из-за отношения many-to-many с относительно большой кардинальностью (до сотен строк).</p><div class="olist arabic"><ol class=arabic><li>Старый бэк<ol class=loweralpha type=a><li><strong>Общие трудозатраты</strong>: 104 часа</li><li><strong>Количество багов</strong>: 4</li></ol></li><li>Новый бэк<ol class=loweralpha type=a><li><strong>Общие трудозатраты</strong>: 58</li><li><strong>Количество багов</strong>: 2</li></ol></li></ol></div><p>Здесь мы видим сокращение трудозатрат в 1.8 раз и сокращение багов в 2 раза, хотя по багам объём выборки не репрезентативен.</p></section><section class="doc-section level-2"><h3 id=_реализация_выгрузок><a class=link href=#_реализация_выгрузок>Реализация выгрузок</a></h3><p>Это небольшая ридонли-админка пациентов и событий их дневников, в которой функционально всё стандартно - таблички на 10 столбцов, фильтрация по ним, сортировка, пагинация, выгрузка в xlsx.
Все сложности были заключены в том, что данные лежат в разных БД.
И в случае событий в перспективе ожидаются сотни миллионов строк.</p><div class="olist arabic"><ol class=arabic><li>Старый бэк<ol class=loweralpha type=a><li><strong>Общие трудозатраты</strong>: 247 часа<ol class=lowerroman type=i><li>Реализация: 179</li><li>Исправление багов: 68</li></ol></li><li><strong>Количество багов</strong>: 21</li></ol></li><li>Новый бэк<ol class=loweralpha type=a><li><strong>Общие трудозатраты</strong>: 175.75<ol class=lowerroman type=i><li>Реализация: 172</li><li>Исправление багов: 3.75</li></ol></li><li><strong>Количество багов</strong>: 4</li></ol></li></ol></div><p>Тут мы видим сокращение трудозатрат в 1.4 раза и сокращение количества багов в 5 раз.</p><p>Однако напрямую эти две реализации сравнивать нельзя, потому что здесь на новом бэке мы сделали выборки на <a href=https://azhidkov.pro/microposts/23/06/streaming-join/>потоковых join-ах</a>.
Благодаря чему новый бэк может обработать 1М строк (старый - 64К), а 64К строк сгенерировать за 11 секунд (старый - 165 секунд).</p><p>Кроме того, старый бэк полностью покрыт тестами.</p></section><section class="doc-section level-2"><h3 id=_реализация_новых_фич_и_текучка><a class=link href=#_реализация_новых_фич_и_текучка>Реализация новых фич и текучка</a></h3><div class="olist arabic"><ol class=arabic><li>Старый бэк<ol class=loweralpha type=a><li><strong>Общие трудозатраты</strong>: 526 часа<ol class=lowerroman type=i><li>Реализация: 353.5</li><li>Исправление багов: 172.5</li></ol></li><li><strong>Количество задач</strong>: 14</li><li><strong>Количество багов</strong>: 22</li><li><strong>Медианные трудозатраты на задачу</strong>: 16</li></ol></li><li>Новый бэк<ol class=loweralpha type=a><li><strong>Общие трудозатраты</strong>: 497 часа<ol class=lowerroman type=i><li>Реализация: 426</li><li>Исправление багов: 71</li></ol></li><li><strong>Количество задач</strong>: 52</li><li><strong>Количество багов</strong>: 24</li><li><strong>Медианные трудозатраты на задачу</strong>: 5</li></ol></li></ol></div><p>Сравнение этих метрик уже с большой натяжкой можно назвать объективным, потому что здесь у нас на входе по большей части разные задачи, выполненные разными людьми.</p><p>Тем не менее по всем метрикам наблюдается положительный тренд:</p><div class="olist arabic"><ol class=arabic><li>За сопоставимый объём часов было выполненло в 3 раза больше задач</li><li>Относительное количество багов (22/14 vs 24/52) так же уменьшилось в 3 раза</li><li>Наконец, медианные трудозатраты тоже снизились в три раза</li></ol></div><p>Можно сказать, что разница кроется в выборке и на новом беке в среднем делали в три раза более простые задачи.
И, положа руку на сердце, исключать этого нельзя, потому что непонятно как объективно оценивать сложность задач.</p><p>Тем не менее, я субъективно оцениваю, что в старом бэке была сделана только одна более-менее крупная задача (на 90 часов), а в остальном это были мелкие допилы и фиксы, которые занимали огромное количество времени.</p><p>Так же субъективно, я оцениваю что в kotlin-бэке было сделано четыре задачи, аналогичных по сложности самой большой задаче .net-бэка, плюс два крупных рефакторинга (100 и 13 часов).</p><p>Поэтому я склоняюсь к мнению, что этот блок можно считать подтверждением того, что разработка на новом бэке требует как минимум в два раза меньше трудозатрат и порождает как минимум в два раза меньше багов.</p></section><section class="doc-section level-2"><h3 id=_реализация_оригинальной_версии_и_её_реинжиниринг><a class=link href=#_реализация_оригинальной_версии_и_её_реинжиниринг>Реализация оригинальной версии и её реинжиниринг</a></h3><div class="olist arabic"><ol class=arabic><li>.net-бэк<ol class=loweralpha type=a><li><strong>Оценочные общие трудозатраты</strong>: 1512</li></ol></li><li>kotlin-бэк<ol class=loweralpha type=a><li><strong>Общие трудозатраты</strong>: 1162<ol class=lowerroman type=i><li>Реализация: 852</li><li>Исправление багов: 59</li><li>Административные задачи: 251</li></ol></li></ol></li></ol></div><p>Тут ускорение разработки составляет 1.3 раза.
Однако здесь мы сравниваем наименее однородные вещи:</p><div class="olist arabic"><ol class=arabic><li>У kotlin-команды было преимущество в фиксированном и проработанном "ТЗ".
Однако "ТЗ" - это исходный и местами запутанный код на незнакомом языке;</li><li>kotlin-бэк делали два юниора и стажёр, а .net-бек - один человек, и по этому полагаю, что как минимум формально это был мидл или сеньёр;</li><li>Оригинальному разработчику приходилось проектировать решение, а kotlin-команде приходилось подстраиваться под это решение, которое не всегда хорошо ложилось на наш стэк, а местами было очень странным;</li><li>Оригинальный разработчик тесты не писал, а у kotlin-команды было 100% покрытие тестами хэппи пасов и 90% покрыте строк кода;</li></ol></div></section><section class="doc-section level-2"><h3 id=_итоги><a class=link href=#_итоги>Итоги</a></h3><p>И так, у меня есть:</p><div class="olist arabic"><ol class=arabic><li>Данные по полностью идентичной реализации одной и той же функциональности объёмом в 1-2 недели - почти в два раза быстрее и в два раза меньше багов;</li><li>Данные по объективно более качественной реализации одной и той же функциональности объёмом в 1-1.5 месяца - в полтора раза быстрее и в пять раз меньше багов;</li><li>Данные по 3 месяцам работы над преимущественно разными задачами - за примерно одинаковое время и с примерно одинаковым количеством багов, kotlin-команда сделала в три раза больше задач.</li></ol></div><p>Исходя из этих данных я делаю следующий вывод - затратив 82% оригинальных трудозатрат команда юниоров смогла создать базу проекта, который по самой консервативной оценке в два раза быстрее разрабатывать и содержит как минимум в два раза меньше багов.</p><p>Я считаю, это очень хороший результат и цель "как минимум двойное сокращение трудозатрат и багов" можно с уверенностью считать достигнутой.
Но что позволило достичь этой цели?</p></section></section><section class="doc-section level-1"><h2 id=_гипотезы_причин_улучшений><a class=link href=#_гипотезы_причин_улучшений>Гипотезы причин улучшений</a></h2><p>На итоговые цифры повлияли как минимум следующие факторы:</p><div class="olist arabic"><ol class=arabic><li>Переход с микросервисов на монолит;</li><li>Разные люди;</li><li>Покрытие кода тестами;</li><li>Переход с вертикальной на функциональную архитектуру;</li><li>Разные стеки.</li></ol></div><p>Как их расцепить и точно определить вклад каждого фактора я не знаю.
Но попробую передать своё субъективное ощущение.
Спойлер - список выше отсортирован по убыванию вклада.</p><section class="doc-section level-2"><h3 id=_переход_с_микросервисов_на_монолит><a class=link href=#_переход_с_микросервисов_на_монолит>Переход с микросервисов на монолит</a></h3><p>На мой взгляд, наибольший вклад в увеличение скорости разработки внёс переход на монолит.
Пусть он будет ответственен за 32% улучшения.
Из цифр видно, что версию на монолите сделали на 20-30 процентов быстрее (смотря что на что делить).
И я думаю, что это консервативная оценка - если бы kotlin-версию делал так же один мидл, то он сделал бы в два раза/на 50% быстрее.
По крайней мере для себя я сделал вывод, что делать проекты до человеко/года на микросервисах как минимум в два раза дороже, чем на монолите.</p></section><section class="doc-section level-2"><h3 id=_разные_люди><a class=link href=#_разные_люди>Разные люди</a></h3><p>Далее, на мой взгляд идёт самый сложный фактор - люди.
По моей оценке вклад смены команды в увеличение скорости разработки составляет 31%.</p><p>Про оригинального разработчика я не знаю ничего, но с учётом довольно небольшой разницы между оригинальными трудозатртами и трудозатратами на разработку, могу предположить, что квалификация и мотивация оригинального разработчика примерно соответствовала kotlin-команде (я помню, что предположил, что это был как минимум мидл, но там была и оговорка: "как минимум формально").</p><p>А вот с .net-командой я зафакапился тотально.
У меня там были все - и юниор, и мидл, и сеньёр, и техлид.
Все, кроме юниора, имели свой грейд чисто формально.
Поэтому всех их (кроме юниора) я быстро уволил (от двух недель до двух месяцев) за то, что они нифига не работали.</p><p>Тут ещё можно поспекулировать на тему того, влияла ли сложность работы с микросервисами, без тестов и на вертикальной архитектуре на мотивацию или нет.
Наверняка сказать невозможно, но я уверен, что влияли.
И если бы мы просто поменяли команду, то за два-три месяца пришли бы примерно к тем же проблемам с мотивацией.</p></section><section class="doc-section level-2"><h3 id=_покрытие_кода_тестами><a class=link href=#_покрытие_кода_тестами>Покрытие кода тестами</a></h3><p>Теперь, наоборот, самый простой фактор - покрытие тестами.
Его вклад в сокращение багов - 100%, на мой взгляд.
Если бы kotlin-команада работала без тестов, то багов было бы столько же, сколько и у .net-команды.</p><p>Касательно увеличения скорости разработки, то по цифрам выходит, что вклад тестов составляет 15% - в .net-беке на исправление багов уходило 30%, а в kotlin - 15% (это в новых фичах и поддержке, а в выгрузках - вообще - 2%).
Но исходя из гипотезы, что тесты влияют на мотивацию, а так же из тех соображений, что баги несут очевидный и серьёзный репутационный (а иногда и материальный ущерб) - вклад покрытия тестами я оцениваю на том же уровне, что и переход на монолит и смену команды - 30%.</p></section><section class="doc-section level-2"><h3 id=_переход_с_вертикальной_на_функциональную_архитектуру><a class=link href=#_переход_с_вертикальной_на_функциональную_архитектуру>Переход с вертикальной на функциональную архитектуру</a></h3><p>Теперь к смене вертикальной архитектуры на функциональную.
Я думаю, что этот фактор именно с точки трудозатрат на кодирование имел не больше влияние - в лучшем случае 7%.
Зато вкупе с отсутствием тестов, он имел серьёзное влияние на количество багов - я не стал тут уже закапываться в статистику, но в .net-беке у нас не раз были баги из серии "Тут SQL-поправили, а в соседней директории - забыли".</p><p>Кроме того, уверен, необходимость писать кучу шаблонного и бессмысленного кода также имела существенное негативное влияние на мотивацию.</p></section><section class="doc-section level-2"><h3 id=_разные_стеки><a class=link href=#_разные_стеки>Разные стеки</a></h3><p>Если вы следите за цифрами, то уже знаете, что вклад смены стека я оцениваю в 0%.
На мой взгляд - Kotlin и C# - это одни и те же яйца в профиль и анфас.</p><p>И при прочих равных, что изначальная разработка на Kotlin, что реинжинриниг на C# дали бы те же самые результаты.</p></section><section class="doc-section level-2"><h3 id=_итоги_2><a class=link href=#_итоги_2>Итоги</a></h3><p>По моей оценке вклад факторов в результат следующий:</p><div class="olist arabic"><ol class=arabic><li>Переход с микросервисов на монолит - 32%;</li><li>Разные люди - 31%;</li><li>Покрытие кода тестами - 30%;</li><li>Переход с вертикальной на функциональную архитектуру - 7%;</li><li>Разные стеки - 0%.</li></ol></div></section></section><section class="doc-section level-1"><h2 id=_при_чём_здесь_эргономичный_подход><a class=link href=#_при_чём_здесь_эргономичный_подход>При чём здесь Эргономичный подход?</a></h2><p>Помимо вопроса "стоило ли оно того в целом", меня ещё интересует вопрос "стоило ли проводить реинжиниринг по Эргономичному подходу"?
Данных, чтобы дать обоснованный ответ, у меня нет, так как сравнивать не с чем, но пофантазировать всё-таки хочется.</p><p>Чтобы было бы, если бы мы делали реинжиниринг по мейнстримному подходу - с тестами на моках, Hibernate, пакетированием по техническим аспектам и в императивном стиле?</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Написав это, я засомневался, действительно ли мейнстрим всё ещё такой.</p><p>Решил проверить так - взять первую попавшуюся на Packtpub-е свежую книгу по Spring и посмотреть что там.
Там оказалось <a href=https://github.com/PacktPublishing/Spring-Boot-and-Angular>ровно всё то, что я перечислил</a>.</p><p>На всякий случай глянул <a href=https://github.com/PacktPublishing/Learning-Spring-Boot-3.0-Third-Edition>вторую книгу</a> - там пакетирования вообще никакого нет, зато Hibernate и моки - на месте.</p></aside><p>Сравнивать kotlin-бэк с гипотетический мейнстримным бэком я в том же формате, что и с .net-бэком.</p><section class="doc-section level-2"><h3 id=_реализация_групп_2><a class=link href=#_реализация_групп_2>Реализация групп</a></h3><p>Я думаю, что использование Hibernate и тестов на моках, позволило бы сократить трудозатраты на 10-30% и, возможно, несущественно бы увеличило количество багов.</p><div class="olist arabic"><ol class=arabic><li>Гипотетический мейнстримный бэк<ol class=loweralpha type=a><li><strong>Оценочные общие трудозатраты</strong>: 41-52 часа (&lt;58 часов факта ЭП-версии> - 10-30%)</li><li><strong>Оценочное количество багов</strong>: 2-3 штуки (&lt;2 бага факта ЭП-верисии> + 0-1 шт.)</li></ol></li></ol></div></section><section class="doc-section level-2"><h3 id=_реализация_выгрузок_2><a class=link href=#_реализация_выгрузок_2>Реализация выгрузок</a></h3><p>Реализация выгрузок миллионов строк на базе Hibernate наверняка привела бы к деградации потребления памяти и скорости работы.
Поэтому для сохранения качества реализации, выгрузки пришлось в любом случае делать на JdbcTemplate-е.
По крайней мере я даже в работе по мейнстримному подходу сделал бы выгрузку точно так же.</p><p>А в силу того, что в реализации много "юнитов" и у них много зависимостей, тесты на моках и сами стоили бы дороже, и багов больше бы пропустили.
И, как следствие, ещё больше увеличили бы общие трудозатраты.
В итоге, я думаю, получилось бы +10% к трудозатратам на тесты и 30% на фикс багов.</p><div class="olist arabic"><ol class=arabic><li>Гипотетический мейнстримный бэк<ol class=loweralpha type=a><li><strong>Оценочные общие трудозатраты</strong>: 245.9<ol class=lowerroman type=i><li>Реализация: 189.2 (&lt;172 часов факта ЭП-версии> + 10%)</li><li>Исправление багов: 56.7 (30% от 189.2)</li></ol></li><li><strong>Оценочное количество багов</strong>: 13 (с потолка)</li></ol></li></ol></div></section><section class="doc-section level-2"><h3 id=_реализация_новых_фич_и_текучка_2><a class=link href=#_реализация_новых_фич_и_текучка_2>Реализация новых фич и текучка</a></h3><p>В эту категорию попадают уже в основном доработки существующей функциональности и рефакторинг.
И тут (по идеи) должен начать проявляться эффект от применения ЭП.
С точки зрения сцепленности продового кода, негативные эффекты мейнстримного подхода ещё не успели бы проявиться.
А вот в тестах - уже бы проявились в полный рост.
В итоге, я полагаю, трудозатраты на реализацию бы выросли на 10-20% (на актуализацию моков), а трудозатраты на исправление багов, пропущенных тестами на моках, выросли бы до 20-25%.</p><div class="olist arabic"><ol class=arabic><li>Гипотетический мейнстримный бэк<ol class=loweralpha type=a><li><strong>Общие трудозатраты</strong>: 562.2-585.7 часа<ol class=lowerroman type=i><li>Реализация: 468.6 (&lt;426 часов факта ЭП-версии> + 10%)</li><li>Исправление багов: 93.7-117.1 (20-25% от 468.6)</li></ol></li><li><strong>Количество задач</strong>: - (не знаю, как хоть сколько-нибудь адекватно оценить и выровнять с общими трудозатратами)</li><li><strong>Количество багов</strong>: - (не знаю, как хоть сколько-нибудь адекватно оценить и выровнять с общими трудозатратами)</li><li><strong>Медианные трудозатраты на задачу</strong>: 5.5-6 (5 + 10-20%)</li></ol></li></ol></div></section><section class="doc-section level-2"><h3 id=_реализация_оригинальной_версии_и_её_реинжиниринг_2><a class=link href=#_реализация_оригинальной_версии_и_её_реинжиниринг_2>Реализация оригинальной версии и её реинжиниринг</a></h3><p>При выполнении реинжиниринга, за счёт использования Hibernate трудозатраты на реализацию сократились бы процентов на 20 и ещё процентов на 10 за счёт тестов на моках.
С другой стороны, трудозатраты на исправление багов удвоились бы за счёт багов, пропущенных тестами на моках.
Наконец, административные трудозатраты не изменились бы.</p><div class="olist arabic"><ol class=arabic><li>Гипотетический мейнстримный бэк<ol class=loweralpha type=a><li><strong>Общие трудозатраты</strong>: 965.4<ol class=lowerroman type=i><li>Реализация: 596.4 (70% от 852 часов факта ЭП-версии)</li><li>Исправление багов: 118 (59 часов факта ЭП-версии + 100%)</li><li>Административные задачи: 251</li></ol></li></ol></li></ol></div></section><section class="doc-section level-2"><h3 id=_итого><a class=link href=#_итого>Итого</a></h3><p>Итого общие трудозатраты на "первые две версии" (реинжиниринг и 3 месяца саппорта) по ЭП составили 2039 часов.
А оценочные общие трудозатраты на "первые две версии" по мейнстримному подходу составили бы 1814.5-1849.</p><p>То есть первый год разработки по ЭП будет примерно на 10% дороже.</p><p>Однако, как показывает моя практика, при разработке по мейнстримному подходу, трудо- и баго-ёмкость задач растёт очень быстро.</p><p>В случае же ЭП, предположительно, они будут расти намного медленнее.</p><p>Это я и собираюсь проверить - я надеюсь, Проект Э проживёт ещё хотя бы пару лет (все предпосылки к этому есть) и я смогу ещё хотя бы три-четыре раза с интервалом в 3-6 месяцев повторить это упражнение и оценить тренд роста трудозатрат и количества багов на задачу при работе с эргономичной кодовой базой.</p></section></section><section class="doc-section level-1"><h2 id=_выводы><a class=link href=#_выводы>Выводы</a></h2><p>Итак.
Стоило ли делать реинжиниринг?
Безусловно да, на основе данных из Jira можно с уверенностью утверждать, что мы смогли снизить трудозатраты и количество багов как минимум в два раза.
Это улучшение ещё "усугубляется" за счёт того, что для заказчика внешние рейты штатных kotlin-истов ниже внешних рейтов .net-чиков аутстафферов.</p><p>Стоило ли делать реинжинирнг по Эргономичному подходу?
Доподлино неизвестно.
Гипотетически, при условии, что работы продолжатся ещё хотя бы год, и если я прав, что показатели будут деградировать очень медленно, - да.
Но это всё теория.</p><p>Кроме того, результаты анализа данных дают дополнительное подтверждение общеизвестным утверждениям:</p><div class="olist arabic"><ol class=arabic><li>Первый год разработки на микросервисах дороже разработки на монолите. Минимум на 30%;</li><li>Автоматизация тестирования снижает количество багов и трудозатрат на их устранение. Минимум в два раза;</li><li>Мотивация команды имеет огромное влияние на трудозатарты.
От 30% дополнительных трудозатрат в случае низкой мотивации.</li></ol></div></section></article></section></div></main><script src=/js/app.js></script></body></html>