<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Дизайн интеграции с ЕМИАС - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/microposts/23/08/emias-integration/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/microposts/23/08/emias-integration/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/microposts/23/08/emias-integration/><title>Дизайн интеграции с ЕМИАС - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/microposts/23/08/emias-integration/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Дизайн интеграции с ЕМИАС</h1></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Этот материал является "микропостом" - текстом, написанным в режиме потока сознания без особой редактуры.</p><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><p>В Проекте Э появилась задача выполнить интеграцию с ЕМИАС города Москвы.
В какой-то момент показалось, что там будет <a href=https://azhidkov.pro/posts/23/04/ergonomic-decomposition/#_ручное_завершение_кластеризации>"сложный случай"</a> в кластеризации диаграммы эффектов.
В конечном итоге всё обошлось, но я решил собрать из этого микропост с демонстрацией того, что делать в сложных случаях.</p><p>Интеграция с ЕМИАС состоит из трёх частей:</p><div class="olist arabic"><ol class=arabic><li>При регистрации, пользователь может проставить галочку, ввести дополнительные данные (номер полиса ОМС и дату рождения) и в этом случае, система должна идентифицировать пользователя в ЕМИАС и дать отлуп, если не получилось.
Вот здесь в конечном итоге обошлось и привязку пользователя к ЕМИАС вынесли в отдельный шаг.</li><li>При подключении устройства пользователя к МП, его также надо привязывать и в ЕМИАС.
У нас сейчас на бэке устройств нет, но мы их давно хотим.</li><li>При сохранении замеров с устройства на бэке, их надо переслать в ЕМИАС.
Это у нас уже третья подобная интеграция, так что события об изменении дневников у нас уже публикуются в RabbitMQ и на них надо просто подписаться.</li></ol></div><p>Кроме того, второй очередью надо будет сделать привязку существующих пользователей к ЕМИАС.</p><p>Перед реализацией интеграции диаграмма эффектов релевантной части системы выглядит так:</p><div class=image-block><a class="image bare" href=/microposts/23/08/images/emias-integration-v0.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/microposts/23/08/images/emias-integration-v0.drawio.svg alt="emias integration v0.drawio"></a></div><p>Теперь добавим на диаграмму операции и ресурсы, необходимые для реализации интеграции:</p><div class="olist arabic"><ol class=arabic><li>Операция "Привязать пользователя к ЕМИАС";</li><li>Ресурс ЕМИАС;</li><li>Ресурс "Привязка пользователей к ЕМИАС", который по сути будет хранить пару ИДов;</li><li>Операция "Зарегистрировать пользователя с привязкой к ЕМИАС", которая должна обладать эффектами и регистрации пользователя и привязки к ЕМИАС;</li><li>Операция "Обновить список устройств пользователя";</li><li>Ресурс "Устройства пользователя";</li><li><p>Ресурс-топик "Устройства обновлены".</p><p><em>Я тут пользуясь форматом микропоста немного забежал вперёд: в "реальной жизни" этот ресурс может появиться не сразу, но я знаю, что хочу прийти к интеграции в отдельном сервисе, который полностью изолирован от ядра.</em></p></li><li>Операция "Зарегистрировать устройство в ЕМИАС";</li><li>Ресурс "Привязков устройств к ЕМИАС", который по сути будет хранить пару ИДов;</li><li>Операция "Отправить замер в ЕМИАС", которая будет вызываться по появлению события в уже существующем топике "Замер добавлен".</li></ol></div><p>Так же, так как у меня пока нет алгоритма рекластеризации, удалим существующие модули.
Наконец, у меня есть идея включить экторов в алгоритм декомпозиции, но пока она очень абстрактная, так что эктора тоже убираем.
Проделав всё это, получим следующую диаграмму:</p><div class=image-block><a class="image bare" href=/microposts/23/08/images/emias-integration-v1.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/microposts/23/08/images/emias-integration-v1.drawio.svg alt="emias integration v1.drawio"></a></div><p>Теперь давайте прогоним на этой диаграмме <a href=https://azhidkov.pro/posts/23/04/ergonomic-decomposition/#_алгоритм_первичной_кластеризации_диаграммы_эффектов>алгоритм первичной кластеризации</a>.
Не буду подробно разбирать прогон, так его ход вполне очевиден.
В результате прогона мы получим следующую первичную кластеризацию:</p><div class=image-block><a class="image bare" href=/microposts/23/08/images/emias-integration-v2.drawio.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/microposts/23/08/images/emias-integration-v2.drawio.svg alt="emias integration v2.drawio"></a></div><p>На этой диаграмме остался тот самый "сложный случай" - алгоритм не может решить, куда отнести операцию "Зарегистрировать пользователя с привязкой к ЕМИАС".
Давайте доставать свой мозолистый мозг.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>И тут у меня появилась мысль, что при работе с проблемными операциями первое что надо сделать - оценить их связанность.</p><p>Для того чтобы оценивать связанность операций (методов, функций) в <a href=https://www.amazon.com/Practical-Guide-Structured-Systems-Design/dp/0136907695>The practical guide to structured systems design</a> есть неплохая эвристика:</p><div class=image-block><a class="image bare" href=/microposts/23/08/images/emias-integration-e2aa8.png title="Open the image in full size" aria-label="Open the image in full size"><img src=/microposts/23/08/images/emias-integration-e2aa8.png alt="emias integration e2aa8"></a></div><p>и дерево принятия решений:</p><div class=image-block><a class="image bare" href=/microposts/23/08/images/emias-integration-fe382.png title="Open the image in full size" aria-label="Open the image in full size"><img src=/microposts/23/08/images/emias-integration-fe382.png alt="emias integration fe382"></a></div><p>И по этой эвристики выходит, что проблемная операция обладает вполне приличной последовательной связанностью - её можно назвать как "Зарегистрируй пользователя и выполни привязку [этого пользователя] к ЕМИАС".</p><p>Однако в целом для методики эта техника выглядит многообещающей.</p></aside><p>Методичка по кластеризации на базе диаграммы эффектов гласит, что при решении сложных случаев с сохранением исходной диаграммы у нас есть три базовых варианта действий:</p><div class="olist arabic"><ol class=arabic><li>Поместить проблемный элемент в один из существующих кластеров;</li><li>Выделить проблемный элемент в собственный кластер.</li><li>Объединить проблемный элемент и оба связанных с ним кластера в один мегакластер.</li></ol></div><p>При разборе этой задачи я понял что есть ещё один вариант, который в целом подпадает под условие "сохранение исходной диаграммы" - удалить проблемный элемент.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Собственно так у нас и вышло в реальной жизни, в конечном итоге.
Но тут мы посмотрим как мне пришлось выкручиваться в альтернативной ветке реальности, где удалить проблемную операцию не получилось:)</p></aside><p>Так же, для проблемных операций записи, методичка предлагает рассмотреть вариант расцепки этой операции через очередь сообщений.</p><p>Таким образом у нас получаются следующие возможные варианты дизайна:</p><div class="olist arabic"><ol class=arabic><li>Помещение операции в кластер "Аккаунты";</li><li>Помещение операции в кластер "ЕМИАС";</li><li>Помещение операции в собственный кластер "Регистрация пользователя с привязкой к ЕМИАС";</li><li>Объединить всё в кластер…​ "Аккаунты"?..;</li><li>Расцепить через очередь сообщений с пляской от "Аккаунты";</li><li>Расцепить через очередь сообщений с пляской от "ЕМИАС";</li></ol></div><p>Давайте сначала отметём варианты, которые нам не позволят обеспечить выполнение функциональных и нефункциональных требований.</p><p>Первым таким вариантом будет третий - помещение операции в собственный кластер "Регистрация пользователя с привязкой к ЕМИАС".
У него, на самом деле, есть два варианта развёртывания и оба они хороши с точки зрения дизайна, но сейчас не очень удобны с точки зрения реализации и развёртывания.</p><p>Первый вариант развёртывания - это отдельный сервис.
Так мы начнём движение в сторону Backend For Frontend, что мне в целом кажется любопытным направлением.
Однако пока что разворачивать отдельный сервис, ради одного эндпоинта практически без бизнес-логики не хочется.</p><p>Второй вариант развёртывания - положить этот код в МП.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>На удивление, через пару часов, как я подумал об этом варианте, я случайно наткнулся на пост где именно он и описан для решения этой проблемы - <a href=https://blog.ttulka.com/services-everywhere/>Services Everywhere</a>.</p></aside><p>Этот вариант плох тем, что у операции есть техно-логика - она должна обеспечивать согласованность/атомарность [в конечном итоге] регистрации и привязки пользователя.
И на устройстве пользователя в целом возрастает риск, что посреди "транзакции" что-то пойдёт не так, плюс МП - не место для этой логики.</p><p>Следующий вариант-невариант - объединить всё в кластер "Аккаунты".
Этот вариант не подходит потому что ядро (куда входит модуль Аккаунты) уже довольно сильно разрослось и не хочу тащить туда то, что можно не тащить.
Кроме того, вместе с собственным кодом, эта интеграция потащит ещё и зависимость на Кафку, которой в ядре пока нет.</p><p>Наконец, последняя пара невариантов - расцепка через очередь.
Она не подходит потому что сильно усложнит реализацию <em>[вымышленного на тот момент]</em> требования о синхронном сообщении пользователю об ошибке привязки к ЕМИАС.
В этом случае МП надо будет в один из модулей пулять запрос на начало регистрации с привязкой, а потом показывать спиннер и поллить результат.</p><p>Таким образом у меня остаются только варианты помещения операции в модуль "Аккаунты" или "ЕМИАС".
И оба мне не нравятся.
Первый - потому что он размазывает интеграцию по двум модулям.
Второй - потому что он размазывает юзкейс "Регистрация пользователя" по двум модулям.</p><p>В общем пришло время компромиссных решений.</p><p>Давайте теперь проверим оба варианта по всем известным мне принципам дизайна - возможно в процессе получим какой-нибудь железобетонный аргумент в пользу одного из вариантов.
А если нет - выберем тот, что набрал больше баллов.
Лишь бы не было ничьей:)</p><p>Итак, принципы по которым будем оценивать варианты:</p><div class="olist arabic"><ol class=arabic><li>Мудрость древних<ol class=loweralpha type=a><li>Сокрытие информации</li><li>Сцепленность</li><li>Связанность</li></ol></li><li>SOLID</li><li>Принципы дизайна пакетов Мартина<ol class=loweralpha type=a><li>The Reuse/Release Equivalence Principle</li><li>The Common Closure Principle</li><li>The Common Reuse Principle</li><li>The Acyclic Dependencies Principle</li><li>The Stable Dependencies Principle</li><li>The Stable Abstractions Principle</li></ol></li><li>GRASP<ol class=loweralpha type=a><li>Information Expert</li><li>Creator</li><li>Controller</li><li>Low Coupling</li><li>High Cohesion</li><li>Polymorphism</li><li>Pure Fabrication</li><li>Indirection</li><li>Protected Variants</li><li>Package Organization Guidelines</li></ol></li></ol></div><section class="doc-section level-1"><h2 id=_сокрытие_информации><a class=link href=#_сокрытие_информации>Сокрытие информации</a></h2><p>У нас оба модуля хорошо скрывают свои секреты - структуры данных, протоколы взаимодействия с внешним миром и т.п.
А в любом из вариантов они будут обмениваться буквальной парой строк - ОМС и дата рождения или почта и пароль соответственно.
Поэтому тут у нас 1:1.</p></section><section class="doc-section level-1"><h2 id=_сцепленность><a class=link href=#_сцепленность>Сцепленность</a></h2><p>Тут надо раскрыть ещё одно небольшое упрощение - на самом деле операция регистрации в модуле аккаунтов трогает намного больше ресурсов - отправляет письмо, сразу же создаёт сессию пользователю (досталось в наследство), обновляет дату последней активности (сами уже накосячили).</p><p>Поэтому если просто посчитать оригинальные стрелки, то получится, что сцепленность при помещении операции в модуль Аккаунтов будет ниже.
Однако при реализации, естественно проблемная операция будет не напрямую в ресурсы лазить, а через соответствующие операции и я в целом в фоновом режиме думаю как мне добавить в диаграмму эффектов включение (переиспользование) эффектов одной операции в другую.</p><p>Поэтому давайте считать что в обоих вариантах будет одна стрелка.
Тоже ничья?
Не совсем.</p><p>У меня в загашнике уже года полтора лежит недописанный черновик о том, что не все зависимости одинаковые и "стоимость владения" зависимостью зависит от значения десяти атрибутов.
Тут все десять разбирать не буду, разберу два - хрупкость и стабильность зависимости.</p><p>Хрупкость - это вероятность того что целевой код взорвётся в рантайме.
И в этом случае операция "Привязать пользователя в ЕМИАС", которая ходит во внешнюю систему - намного более хрупкая, чем операция "Зарегистрировать пользователя", которая ходит только в БД внутри кластера (фейл отправки почты не влияет на результат операции).</p><p>Стабильность - это вероятность изменения АПИ целевого кода.
И тут, опять, же операция привязки выглядит менее стабильной, так как код свежий и у нас и у ЕМИАС-а, а АПИ регистрации не менялось ни разу за всю свою жизнь.
Пока что.</p><p>Отсюда следует, что "стоимость владения" зависимостью "Аккаунты" → "ЕМИАС" выше стоимости владения обратной зависимостью.
Поэтому у нас появляется лидер - 1:2.</p></section><section class="doc-section level-1"><h2 id=_связанность><a class=link href=#_связанность>Связанность</a></h2><p>Моя методичка предлагает оценивать связанность модуля посредством оценки простоты именования этого модуля.
И в целом помещение проблемной операции в любой из модулей выглядит в равной степени разумным.</p><p>Так же существуют методы оценки связанности классов/объектов, все из которых базируются на степени использования полей класса в методах класса (в идеале - все поля во всех метода должны использоваться).</p><p>И в нашем случае добавленная операция будет связана со всеми ресурсами в любом из модулей.
Поэтому по этому критерию снова ничья - 2:3</p></section><section class="doc-section level-1"><h2 id=_solid><a class=link href=#_solid>SOLID</a></h2><p>Я продолжаю утверждать, что декомпозиция на базе эффектов порождает <em>[труъ]</em> объекты, поэтому давайте попробуем рассмотреть варианты с точки зрения SOLID-а.</p><section class="doc-section level-2"><h3 id=_srp><a class=link href=#_srp>SRP</a></h3><p>Как я уже <a href=https://azhidkov.pro/posts/21/06/210626-srp-interpretations/>писал</a>, у SRP есть три определения:</p><div class="olist arabic"><ol class=arabic><li>The Single Responsibility Principle (SRP) states that a class or module should have one, and only one, reason to change;</li><li>Gather together the things that change for the same reasons.
Separate those things that change for different reasons;</li><li>A module should be responsible to one, and only one, actor;</li></ol></div><p>Давайте рассмотрим варианты с точки зрения каждого.</p><p>По первому определению, у нас оба варианта нарушают SRP.
В первом случае у модуля аккаунтов появляется дополнительная причина для изменений - изменение в интеграции с ЕМИАС.
А во втором модуль ЕМИАС может потребовать изменений в случае изменений в юз кейсе регистрации пользователя.</p><p>То же самое и со второй формулировкой.
В первом случае, у нас изменения в ЕМИАС расползутся по двум модулям.
А во втором - изменения в регистрации расползутся по двум модулям.</p><p>Наконец, третья формулировка.
Благодаря ЕМИАС у нас появляется специализированный эктор - "Пользователь из Москвы".
И тогда, в первом варианте модуль аккаунтов становится ответственным за юзкейсы двух экторов - "Пользователь" и "Пользователь из Москвы".
Во втором же - за все юзкейсы пользователя из Москвы будет отвечать модуль ЕМИАС-а.</p><p>2:4</p></section><section class="doc-section level-2"><h3 id=_ocp><a class=link href=#_ocp>OCP</a></h3><div class=quote-block><blockquote><p>A software artifact should be open for extension but closed for modification.</p></blockquote></div><p>Не в полной мере понимаю как его применять в данном контексте и в рамках микропоста не буду закапываться.
Однако, если экстраполировать (а у нас с вероятностью 75% будет интеграция с ЕМИАС московской области, и вполне возможны интеграции с другими регионами) эту интеграцию, то первый вариант снова проигрывает.
Так в этом случае у модуля аккаунтов (и сервиса ядра) количество зависимостей будет рости условно бесконечно.</p><p>2:5</p></section><section class="doc-section level-2"><h3 id=_lsp_isp_dip><a class=link href=#_lsp_isp_dip>LSP, ISP, DIP</a></h3><p>Не применимы для диаграммы эффектов</p></section></section><section class="doc-section level-1"><h2 id=_принципы_дизайна_пакетов><a class=link href=#_принципы_дизайна_пакетов>Принципы дизайна пакетов</a></h2><section class="doc-section level-2"><h3 id=_the_reuserelease_equivalence_principle><a class=link href=#_the_reuserelease_equivalence_principle>The Reuse/Release Equivalence Principle</a></h3><div class=quote-block><blockquote><p>The granule of reuse is the granule of release.</p></blockquote></div><p>Мартин пишет:</p><div class=quote-block><blockquote><p>From a software design and architecture point of view, this principle means that the
classes and modules that are formed into a component must belong to a cohesive
group.</p><p>This is weak advice: Saying that something should “make sense” is just a way of
waving your hands in the air and trying to sound authoritative.</p><footer>— <cite>Роберт Мартин, Clean Architecture</cite></footer></blockquote></div><p>И так как я уже проверил, "мейкает ли сенс" каждый из вариантов в разделе "Связанность" - тут не буду повторяться.</p></section><section class="doc-section level-2"><h3 id=_the_common_closure_principle><a class=link href=#_the_common_closure_principle>The Common Closure Principle</a></h3><div class=quote-block><blockquote><p>Gather into components those classes that change for the same reasons and at the same
times.
Separate into different components those classes that change at different times and
for different reasons.</p></blockquote></div><p>Далее Мартин пишет:</p><div class=quote-block><blockquote><p>This is the Single Responsibility Principle restated for components</p></blockquote></div><p>SRP я уже рассмотрел - тоже не буду повторяться.</p></section><section class="doc-section level-2"><h3 id=_the_common_reuse_principle><a class=link href=#_the_common_reuse_principle>The Common Reuse Principle</a></h3><div class=quote-block><blockquote><p>Don’t force users of a component to depend on things they don’t need.</p></blockquote></div><p>Продолжая уже добрую традицию - далее Мартин пишет:</p><div class=quote-block><blockquote><p>Put another way, we want to make sure that the classes that we put into a component are inseparable — that it is impossible to depend on some and not on the others.</p></blockquote></div><p>Тут уже интересней - такого мы ещё не рассматривали.
Рассмотрим.</p><p>Хотя лучше не надо было бы - оба варианта нарушают этот принцип.
В первом - модуль аккаунтов зависит только от операции привязки из всего модуля ЕМИАСа.
Во втором - модуль ЕМИАСа зависит только от операции регистрации из всего модуля Аккаунтов.</p><p>Оставляю счёт как есть - 2:5.</p></section><section class="doc-section level-2"><h3 id=_the_acyclic_dependencies_principle><a class=link href=#_the_acyclic_dependencies_principle>The Acyclic Dependencies Principle</a></h3><div class=quote-block><blockquote><p>Allow no cycles in the component dependency graph.</p></blockquote></div><p>Сервис ЕМИАСа, помимо регистрации, через очередь сообщений зависит ещё и от модулей устройств и дневника, которые все вместе деплоятся в сервис ядра.</p><p>Соотвественно, первый вариант создаст цикл в зависимостях.
2:6.
Идём дальше.</p></section><section class="doc-section level-2"><h3 id=_the_stable_dependencies_principle><a class=link href=#_the_stable_dependencies_principle>The Stable Dependencies Principle</a></h3><div class=quote-block><blockquote><p>Depend in the direction of stability.</p></blockquote></div><p>Стабильность компонента Мартин предлагает определять как трудоёмкость его изменения.
В том числе из-за количества зависимых от него компонент.</p><p>И у модуля аккаунтов куча входящих зависимостей, а у ЕМИАСа - ни одной (на бэке).</p><p>Соотвественно, плюсик варианту два - 2:7.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Мысль в бок.
Кажется этот принцип создаёт систему с подкреплением - модуль который когда-то по ошибке стал более стабильным (получил большее количество зависимостей), с течением времени будет только увеличивать свою стабильность.</p><p>Не уверен, что с этим надо что-то делать и не знаю что делать, но кажется проблека имеется.</p></aside></section><section class="doc-section level-2"><h3 id=_the_stable_abstractions_principle><a class=link href=#_the_stable_abstractions_principle>The Stable Abstractions Principle</a></h3><div class=quote-block><blockquote><p>A component should be as abstract as it is stable</p></blockquote></div><p>Не применим к диаграмме эффектов.</p></section></section><section class="doc-section level-1"><h2 id=_grasp><a class=link href=#_grasp>GRASP</a></h2><p>Принципы GRASP описаны в <a href=https://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062>Applying UML and Patterns</a>, и так же как и SOLID относятся в первую очередь к дизайну классов, но я их приму во внимание, по тем же причинам, по которым принял во внимание SOLID.</p><section class="doc-section level-2"><h3 id=_information_expert><a class=link href=#_information_expert>Information Expert</a></h3><div class=quote-block><blockquote><p>Assign a responsibility to the information expert — the class that has the information necessary to fulfill the responsibility.</p></blockquote></div><p>В данном случае, оба модуля являются "экспертами" для операции, поэтому любой из вариантов одинаково хорош/плох.</p><p>3:8</p></section><section class="doc-section level-2"><h3 id=_creator><a class=link href=#_creator>Creator</a></h3><p>Не применим в данной ситуации</p></section><section class="doc-section level-2"><h3 id=_low_coupling_high_cohesion><a class=link href=#_low_coupling_high_cohesion>Low Coupling, High Cohesion</a></h3><div class=quote-block><blockquote><p>Assign a responsibility so that coupling remains low.</p></blockquote></div><div class=quote-block><blockquote><p>Assign a responsibility so that cohesion remains high.</p></blockquote></div><p>В этих принципах Ларман не привносит ничего нового, поэтому пропускаем их.</p></section><section class="doc-section level-2"><h3 id=_controller_polymorphism_purе_fabrication_indirection_protected_variants><a class=link href=#_controller_polymorphism_purе_fabrication_indirection_protected_variants>Controller, Polymorphism, Purе Fabrication, Indirection, Protected Variants</a></h3><p>Вся эта пачка принципов ведёт к выделению в отдельный модуль всего юз кейса "Регистрация пользователей" со всеми вариациями.
Этот модуль будет "чистой выдумкой", которая будет содержать "контроллер", который будет принимать запросы, служить слоем "косвенности" между модулем аккаунтов и интеграций, выполнять "полиморфную" диспетчеризацию, на основе типа запроса и "защищать варианты" регистрации.</p><p>Однако, однако этот вариант мы пока что отмели и счёт остаётся неизменным - 3:8.</p></section><section class="doc-section level-2"><h3 id=_package_organization_guidelines><a class=link href=#_package_organization_guidelines>Package Organization Guidelines</a></h3><p>В Applaying UML and Patterns есть раздел по принципам организации пакетов со следующими гайдлайнами:</p><div class="olist arabic"><ol class=arabic><li>Package Functionally Cohesive Vertical and Horizontal Slices;</li><li>Package a Family of Interfaces;</li><li>Package by Work and by Clusters of Unstable Classes;</li><li>Most Responsible Are Most Stable</li><li>Factor out Independent Types</li><li>Use Factories to Reduce Dependency on Concrete Packages</li><li>No Cycles in Packages</li></ol></div><p>Однако они либо не применимы в нашем случае (Factor out Independent Types, Use Factories to Reduce Dependency on Concrete Packages), либо (все остальные) пересекаются с тем, что мы уже рассмотрели.</p><p>Таким образом, итоговый счёт остаётся 3:8.</p><hr><p>Этот счёт показывает, что выбор варианта действительно не однозначный - оба варианта имеют свои плюсы и минусы.
Однако, количество плюсов второго варианта перевешивает.
Его я и выбрал в альтернативной ветки реальности, где мне пришлось этот выбор делать.</p><p>Так же стоит отметить, что помимо чисто дизайнерских критериев при окончательном выборе стоит учесть ещё кучу аспектов - насколько удобно будет работать над каждым из модулей в каждом из вариантов, как обеспечить безопасность, как тестировать, как деплоить.
Но так как этот пост уже довольно большой я не буду на них подробно останавливаться - там либо так же ничья, либо второй вариант предпочтительнее.</p></section></section><section class="doc-section level-1"><h2 id=_заключение><a class=link href=#_заключение>Заключение</a></h2><p>Итак, алгоритм принятия решения по "сложному случаю" операции в декомпозиции по диаграмме эффектов состоит из следующих шагов:</p><div class="olist arabic"><ol class=arabic><li>Оценить связанность проблемной операции;</li><li><p>Рассмотреть возможность исключения этой операции.</p><p>При том чем ниже связанность операции, тем больше усилий стоит предпринять для её исключения, вплоть до переговоров с заказчиком фичи.</p><p>Однако, в этих переговорах не стоит рассказывать про связанность и сложности реализации - как правило низкую связанность можно приземлить на "нелогичность/странность/сложность" в терминах бизнеса.
В данном случае я бы упирал на усложнение UX формы регистрации, при том чем большее вариаций интеграций у нас будет, тем более будет сложный UX.</p></li><li>Сформировать список всех возможных вариантов декомпозиции;</li><li>Отфильтровать те варианты, которые не позволят (или сильно усложнят) обеспечить выполнение функциональных или нефункциональных требований;</li><li>Для оставшихся вариантов определить набор критериев, которые вы считаете важными;</li><li>Оценить каждый из вариантов по всем критериям;</li><li>Выбрать тот вариант, который набрал больше баллов при оценке.
Лишь бы не было ничьей:)
Если столкнусь с этим - обязательно напишу пост о том, как я выкручивался.</li></ol></div></section></article></section></div></main><script src=/js/app.js></script></body></html>