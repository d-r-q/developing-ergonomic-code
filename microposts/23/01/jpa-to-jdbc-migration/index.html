<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Обзор доклада &#34;Меняем Spring Data JPA на Spring Data JDBC!&#34; - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/microposts/23/01/jpa-to-jdbc-migration/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/microposts/23/01/jpa-to-jdbc-migration/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/microposts/23/01/jpa-to-jdbc-migration/><title>Обзор доклада "Меняем Spring Data JPA на Spring Data JDBC!" - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/microposts/23/01/jpa-to-jdbc-migration/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Обзор доклада "Меняем Spring Data JPA на Spring Data JDBC!"</h1></header><p>Привет!</p><p>Посмотрел <a href="https://www.youtube.com/watch?v=WB8S_miQNvM">Меняем Spring Data JPA на Spring Data JDBC!</a> и хотя докладчик в начале <a href="https://youtu.be/WB8S_miQNvM?t=342">сказал</a>, что не призывает использовать JPA, мне что-то захотелось написать микропост в защиту Spring Data JDBC (далее - просто JDBC).</p><p>Я сначала кратко напишу своё отношение к JDBC и почему я всё ещё его использую, а потом пройдусь по тезисам из доклада, которые хочу оспорить/прокомментировать.</p><p>Так вот JDBC - это, конечно же, не магическая пуля, где всё получается легко и просто.
Но у меня большинство проблем не совпадает с теми, что подсвечены в докладе.
Потому что мой подход к разработке совпадает с DDD и, как следствие, с JDBC.
Поэтому у меня проблемы там где и DDD и JDBC традиционные работают плохо - выборка данных для UI и, в особенности, для админок.</p><p>Для того, чтобы решить проблемы с выборкой для UI я стараюсь собирать агрегаты в одну таблицу/или представление.
Где-то я денормализую базовую схему данных и использую составные колонки для сущностей (массивы и jsonb), где-то создаю денормализованные представления.</p><p>А вот сделать выборку данных для админки с динамической фильтрацией, сортировкой и пагинацией в JDBC 2 было просто невозможно.
В недавно вышедшем JDBC 3 завезли SpEL в @Query и Query by example и стало чуть получше, но всё равно это очень ограниченные инструменты и по ночам мне иногда снятся хорошие сны с JPA-шными Specifications.</p><p>И тем не менее, когда я просыпаюсь - я иду делать проекты на JDBC.
Потому что я утверждаю, что поддерживать модульные проекты с функциональной архитектурой на порядок проще/дешевле/приятнее, чем большие комья грязи с бесконтрольным изменением состояния.
А такие ключевые особенности/требования/лучшие практики JPA, как:</p><div class=ulist><ul><li>связный граф сущностей, отражающий структуру БД;</li><li>ленивая загрузка;</li><li>обязательное наличие сеттеров у сущностей;</li><li>дёрти-чекинг.</li></ul></div><p>исключает и возможность разбить системы на модули и использовать функциональную архитектуру.</p><p>Тем самым обрекая JPA-based приложения на превращение в большие комья грязи, так как они убирают какие бы то ни было барьеры, ограждающие программиста о того, чтобы проскакать по ссылкам из одного конца графа в другой, там через сеттер проставить какое угодно состояние и потом незаметно его закоммитать.</p><p>Надеюсь, в 23-ем году я осилю развернуть эти тезисы и написать полноценные посты о том, почему модульные программы с функциональной архитектурой существенно проще поддерживать, и о том почему бессмысленно пытаться писать модульные программы с ФА на базе JPA.</p><p>Теперь поехали к докладу.
Наверное, стоит его сначала целиком посмотреть и только потом уже возвращаться к моим заметкам.</p><p><a href="https://www.youtube.com/watch?v=WB8S_miQNvM">Мы говорим именно про переезд ["хорошего" энтерпрайзного приложения</a>].
Не надо этого делать.
Чтобы не говорил анкл Боб, базы данных и фреймворки - это не незначительные детали.
И у JPA и JDBC существенно разные философии из-за различия которых и будут все дальнейшие WTF-ы.</p><p><a href=https://youtu.be/WB8S_miQNvM>И если в случае JPA мы делали репозитории для каждой сущности</a>.
<a href=https://stackoverflow.com/a/38542469>То мы были не правы</a>.</p><p><a href="https://youtu.be/WB8S_miQNvM?t=862">За состоянием наших объектов БД никто следить не будет</a>.
Наброс: изменяемое состояние зло и его количество в системе надо минимизировать.
И JDBC <a href=https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#mapping.general-recommendations>рекомендует</a> использовать неизменяемые классы для сущностей.</p><p><a href="https://www.youtube.com/watch?v=WB8S_miQNvM">Тип не входит в наш агрегат</a>.
Справочники в JDBC - да это боль.
Я её сейчас решаю за счёт денормализации с помощью вью.
То есть здесь бы я завёл представление, куда бы заджинил тип сущность замапил на это представление, а вставку и удаление делал через <a href=https://www.postgresql.org/docs/current/rules-update.html>правила</a> Postgres.</p><p><a href="https://youtu.be/WB8S_miQNvM?t=1553">К сожалению many-to-many у нас тоже нет</a>.
Между сущностями many-to-many на самом деле встречается не так уж и часто.
Покрайней мере реже, чем между сущностями и справочниками.
А такие связи вполне можно денормализовать в представление и сильно упростить работу с ними.</p><p><a href="https://youtu.be/WB8S_miQNvM?t=1585">И N+1 запрос это естественное состояние JDBC</a>.
Это не совсем так.
Когда вы выбираете 1 агрегат, то запросов будет 1+K, где K - это кол-во связей (а не связанных элементов, как в случае JPA).
Но вот если выбрать N агрегатов, то да вы получите 1+N*K запросов.</p><p><a href=https://youtu.be/WB8S_miQNvM>Если у вас раньше идшник назначался через сиквенс, вам придётся написать немножко кода</a>.
Для меня странное утверждение.
Я, честно говоря, никогда не генерял ИДы сиквенсами (я сейчас это делаю через <a href=https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-identity-column/>IDENTITY</a>, а раньше через <a href=https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL>SERIAL</a>), но если уж очень хочется погенерять руками - что мешает сделать <code>id bigint default nextval('sequence')</code>?</p><p><a href="https://youtu.be/WB8S_miQNvM?t=2064">Поэтому либо явный инсёрт, либо колбэк</a>.
<a href=https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#is-new-state-detection>Либо @Version</a> - работает как часы.
Либо реализовать Persistable.
Либо запилить что-то кастомное через EntityInformation.</p><p><a href="https://youtu.be/WB8S_miQNvM?t=2355">Генерируем Q-типы при помощи QueryDSL</a>.
Во-первых, <a href=https://github.com/infobip/infobip-spring-data-querydsl>QueryDSL с JDBC дружит</a> какая-то третья контора.
Во-вторых, она немного отстаёт.
У меня был забавный случай - давал разработчику задание потыкать QueryDSL.
Возвращается, говорит - 1-к-Н не работает.
Я говорю - "Да как не работает-то? Вон в доках написано что работает!".
Смотрю когда написали - на тот момент (начало сентября 2022 года) написали 8 дней как.
И это была последняя фича, которую они запилили - после этого только JDBC 3 поддержали.
В общем будьте осторожны с этой либой.</p><p><a href="https://youtu.be/WB8S_miQNvM?t=2453">Наши запросы свалятся в рантайме</a>.
Тесты - очень рекомендую.
У меня ни разу не было такого, чтобы это мне доставляло проблемы.
Зато проекты у меня стартуют за 2-3 секунды, а не минуты.</p><p><a href=https://youtu.be/WB8S_miQNvM>А вот последний оператор вызывает некоторые вопросы</a>.
У меня - вообще не вызывает.
Для меня репозиторий - это аналог изменяемой мапы неизменяемых деревьев объектов.
И если я туда складываю дерево в одном состоянии (без визитов), то я ожидаю, что загружу я его в том же состоянии (без визитов).
О том как с такой картиной мира вообще жить и почему так жить на самом деле проще можно посмотреть в двух очень крутых докладах: <a href=https://donnywinston.com/posts/the-materials-paradigm-and-epochal-time/>Are We There Yet</a> и <a href="https://www.youtube.com/watch?v=28OdemxhfbU">Immutable Relation Data</a>.
Сюда же можно подойти и со стороны DDD: агрегат должен быть всегда консистентен.
Если вы удалили визиты - значит таково теперь состояние агрегата.
Вобщем не надо переезжать с JPA на JDBC, до тех пор, пока у вас картина мира не переключилась на DDD-шную и/или функциональную.</p><p><a href="https://youtu.be/WB8S_miQNvM?t=2696">Ровно потому что Batch операции не поддерживаются</a>.
В JDBC 3 их завезли.</p><p><a href="https://youtu.be/WB8S_miQNvM?t=2827">Мы должны ЯВНО сохранять эти сущности</a>.
И это прекрасно.
Потому что неявное сохранение - это побочный эффект.
А каждый Чистый программист знает, что побочные эффекты это ложь и их надо избегать (<a href=https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882>Clean Code</a>, Chapter 3, раздел Have No Side Effects).</p><p><a href="https://youtu.be/WB8S_miQNvM?t=2860">Может привести к неприятным последствиям в слое бизнес-логики</a>.
Если слой бизнес-логики следует функциональной архитектуре - не может.
Опять же - не надо переезжать с JPA на JDBC.
Надо выполнять полноценный реинжиниринг всей системы.
После того, как JPA уже парализовало разработку, естественно.
Если <em>[ещё]</em> нет - лучше ничего не трогать:)
Ну и вообще там код <s>процедурный</s> странный - зачем лезть в сервис с ИД-ом?
Эта логика должна быть внутри сущности/агрегата.</p><p><a href="https://youtu.be/WB8S_miQNvM?t=3212">В JPA объектная модель первична</a>.
По моему опыту - вообще не так.
В тех проектах с JPA, что я видел на практике объектная модель полностью отражала схему БД ещё и с дублированием (двунаправленные связи).
И я полагаю, если от этого попытаться отказаться, то потеряется вся простота и удобство JPA.</p><p><a href="https://www.youtube.com/watch?v=WB8S_miQNvM">Как поделить модель на агрегаты</a>?
Построить <a href=https://azhidkov.pro/effects-diagram/landing/>диаграмму эффектов</a>, объединить сущности в агрегаты так, чтобы кол-во операций, затрагивающих два и более агрегата было минимальным.</p><p>Ещё мысль про агрегаты - я в последнее время сильно упростил для себя понятие агрегата.
Агрегат - это набор сущностей, чей жизненный цикл ограничен жизненным циклом одной общей сущности.
Если логический агрегат включает в себя больше пары десятков сущностей и/или занимает в памяти больше 10 килобайт, то его можно разбить на несколько технических JDBC-агрегатов.
В качестве JDBC-агрегатов в петклинике у меня бы были хозяин-животные, ветеринар, приёмы
Приёмы я бы сделал отдельным агрегатом потому что их количество в рамках агрегата хозяина ни чем не ограничено.
А ещё потому что их точно рано или поздно захочется привязать к ветеринару и в таком случае они будут иметь смысл даже если удалить хозяев и питомцев.</p></article></section></div></main><script src=/js/app.js></script></body></html>