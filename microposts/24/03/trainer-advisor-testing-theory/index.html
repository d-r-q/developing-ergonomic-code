<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Тестирование Trainer Advisor: теория - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/microposts/24/03/trainer-advisor-testing-theory/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/microposts/24/03/trainer-advisor-testing-theory/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/microposts/24/03/trainer-advisor-testing-theory/><title>Тестирование Trainer Advisor: теория - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/microposts/24/03/trainer-advisor-testing-theory/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/ergo-approach/landing>Эргономичный подход</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Тестирование Trainer Advisor: теория</h1></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Этот материал является "микропостом" - текстом, написанным в режиме потока сознания без особой редактуры.</p><p>Следить за обновлениями блога можно в Telegram-канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a>.</p></aside><section class="doc-section level-1"><h2 id=_введение><a class=link href=#_введение>Введение</a></h2><p>Это первый пост об устройстве тестирования <a href=https://azhidkov.pro/microposts/23/11/qyoga/>Trainer Advisor</a>.
В этом посте я расскажу какие принципы и модели лежат в основе тестирования TA, а в последующих постах подробно разберу все ключевые виды тестового кода в проекте.</p><p>Но начать надо с того, чтобы решить куда мы хотим прийти - какими должны быть тесты?</p></section><section class="doc-section level-1"><h2 id=_что_такое_хороший_тест><a class=link href=#_что_такое_хороший_тест>Что такое хороший тест?</a></h2><p>На мой взгляд, хороший тест, это показательный тест.
Если все тесты на фичу прошли, не должно быть такого, что пользователь при первом же взаимодействии с этой фичей находит баги.
И наоборот, если был выполнен аккуратный рефакторинг (изменение структуры кода, без изменения его поведения), который не внёс регрессий (и пользователь это подтвердит) - тесты не должны сломаться.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>На самом деле, хороший тест - этот тот, который ещё и быстро писать и сам он выполняется быстро.
Но пользуясь форматом микропоста я сейчас не буду эту тему разворачивать, а техники, которые помогают быстро писать быстрые показательные техники рассмотрю в следующих постах.</p></aside><p>Для того чтобы тесты были показательными, я считаю, что надо <em>[стремится]</em> придерживаться трёх основных правил:</p><div class="olist arabic"><ol class=arabic><li>Тестировать систему в конфигурации максимально приближенной к боевой.
То есть минимизировать использование тестовых дублей (моков, стабов, фейков, спаев).</li><li>Взаимодействовать с системой через публичное АПИ.
То есть минимизировать взаимодействие с системой через код её реализации и, в особенности, напрямую с базой данных системы, а так же через тестовые дубли;</li><li>Тестировать систему так, как её будет тестировать пользователь.
То есть кодировать в тест кейсах, те действия и проверки, которые вы сами или ваши QA выполняют в рамках тестирования.
Например, в тесте операции регистрации, проверить не только то, что в ответ на запрос вернулся 200-ый статус (его можно и захардкодить), но и то, что после этого можно залогиниться с теми же логином и паролем.</li></ol></div><p>Все эти правила, не являются догмами и в реальной практике их приходится нарушать:</p><div class="olist arabic"><ol class=arabic><li>Зачастую тесты на обработку ошибок инфраструктуры намного проще написать с помощью моков, чем ломать реальную инфраструктуру из тестов;</li><li>Иногда спровоцировать то или иное поведение глубоко запрятанного кода или верифицировать результат его выполнения намного проще прямым вызовом, чем через публичное АПИ.</li><li>Как правило писать тесты на API ядра/домена/бизнес-логики намного проще, чем писать тесты на любой вид UI.
В Trainer Advisor это значит, что вызывать в тестах методы контроллеров напрямую и верифицировать модельные объекты (даже, если они заточены под определённую страницу) намного проще, чем отправлять HTTP-запросы и парсить и верифицировать HTML.</li></ol></div><p>Поэтому у меня есть только одно жёсткое правило, контролируемое автоматически - код методов HTTP эндпоинтов должен быть покрыт на 100% тестами, работающим через HTTP API с приложением без моков.</p><p>Так же, так как у меня нет отдельной команды QA, я бы хотел ещё одно жёсткое автоматически контролируемое правило - все ключевые элементы вёрстки (самое главные - поля ввода, формы и ссылки, а так же - динамические строки, включая сообщения об ошибках) должны быть покрыты тестами на 100% .
Но я не вижу способа как это можно сделать, поэтому к следованию этого правила я просто стремлюсь.</p><p>Практика Trainer Advisor, <a href=https://azhidkov.pro/posts/23/09/project-e-part1/>Проекта Э</a> и <a href=https://azhidkov.pro/ergo-approach/landing/#_кейсы>других проектов сделанных по Эргономичному подходу</a> такова, что одни только такие тесты (покрывающие 100% эндпоинтов и ключевых элементов вёрстки) обеспечивают примерно 90% покрытия кода, и необходимость в тестах на более низких уровнях абстракции возникает довольно редко.</p><p>Это хорошо видно по цифрам распределения видов тестов в Trainer Advisor:</p><div class="olist arabic"><ol class=arabic><li>Общее кол-во тестов (тест кейсов, тестовых методов): 151</li><li>Кол-во e2e (Selenium) тестов: 2</li><li>Кол-во внешних (выполняющих HTTP-запросы и парсящих HTML) тестов: 122</li><li>Кол-во внутренних (вызывающих методы контроллеров напрямую) тестов: 15</li><li>Кол-во интеграционных тестов сервисов/компонентов: 6</li><li>Кол-во юнит тестов: 3</li><li>Кол-во тестов с моками: 2</li><li>Кол-во архитектурных (ArchUnit) тестов: 1</li></ol></div><p>При том 149 не-e2e тестов на моей машине (i7-8700, 32GB Ram, SSD) проходят за 9.5 секунд, в среднем - ~64мс на тест, если вас беспокоит время выполнения внешних тестов.
Для сравнения, два теста с моками занимают порядка 600-700 на первый и 150-200 на второй тест.</p></section><section class="doc-section level-1"><h2 id=_виды_тестового_кода_и_их_общая_структура><a class=link href=#_виды_тестового_кода_и_их_общая_структура>Виды тестового кода и их общая структура</a></h2><p>Для того, чтобы придерживаться трёх основных правил, мне приходится писать достаточно много фикстурного кода - кода, который упрощает написание тест кейсов, удовлетворяющих этим правилам.</p><p>В цифрах это:</p><div class="olist arabic"><ol class=arabic><li>Кол-во строк тест кейсов: 3654</li><li>Кол-во строк фикстурного кода: 5299</li><li>Кол-во строк продового кода: 5627</li></ol></div><p>Как видно, тестового кода у меня больше чем продового и к его организации надо подходить не менее тщательно.</p><p>Я выделяю одиннадцать (🤦‍♂️) видов тестового кода:</p><div class=ulist><ul><li>Generic random data generators - универсальные утилиты генерации рандомных данных - строк, дат и т.п<sup>*</sup>;
Раньше я их писал руками, но недавно наткнулся на любопытную библиотеку - <a href=https://www.datafaker.net/>Datafaker</a> - и, думаю, теперь перееду на неё;</li><li>Domain-specific random data generators - утилиты генерации рандомных значений специфичных для домена домену - длительность упражнения, дата и время приёма и т.п.</li><li>Object mothers - объекты генерации экземпляров продовых классов данных (сущностей, DTO, запросов и т.п.).
В этих классах инкапсулируется структура продовых классов данных.</li><li>Backgrounds<sup>**</sup> - коллекции функций для сетапа сложной фикстуры (например, создать приём со всеми ссылками - клиент, тип, задача) и "подкожного" (в обход HTTP) считывания состояния системы для верификации</li><li>Apis - клиенты бэка, заводится как минимум по одному методу на каждый эндпоинт.
В этих классах инкапсулируется HTTP API бэка.</li><li>Role clients - просто сборники Api, доступных для существующих ролей пользователей.
Сейчас в TA только анонимы и терапевты.
Но в перспективе там могут появится клиенты, админы, ДевОпсы и т.д.</li><li>Page objects - описание ожидаемой структуры HTTP-страниц.
В контексте разработки бэкэндов актуально только в случае серверного рендеринга;</li><li>Assertions - функции верификации, специфичные для нашего домена.
В этих функциях инкапсулируется структура продовых классов данных и правила собственно верификации.</li><li>Platform - утилиты для расширения тестовых библиотек;</li><li>Infra - код создания и и настройки инфраструктуры.</li><li>Cases - собственно кейсы;</li></ul></div><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p><sup>*</sup> - сейчас все элементы данных, которые не имеют значения для конкретного теста генерируются случайными.
Это спорная техника, однако:</p><div class="olist arabic"><ol class=arabic><li>Я написал в таком ключе уже больше двух сотен тестов (помимо Trainer Advisor - ещё и в Проекте Э) - и проблем, требующих на решение более 5 минут, пока не было;</li><li>Это позволяет лучше раскрыть назначение теста - что для него релевантно, а что нет;</li><li>Это позволяет снизить сцепленность тестов между собой;</li><li>Это упрощает генерацию десятков объектов для тестирования всяких пагинаций, фильтраций, сортировок и т.п.</li></ol></div><p><sup>**</sup> - название не очень удачное и по большому счёту случайное - где-то на хабре попалось на глаза и утащил.
Но лучшего варианта пока не придумал - поэтому остаётся как есть.</p></aside><p>Все эти виды кода и зависимости между ними можно визуализировать так:</p><div class=image-block><img src=/microposts/24/03/images/tests-structure.drawio.svg alt="tests structure.drawio"></div><p>На этой картинке в первую очередь надо обратить внимание на то, что кейсы зависят от продового кода только косвенно - они могут объявлять переменные классов продового кода, но всё взаимодействие с ними - создание и обращение к полям и методам идёт через фикстурный код.
Это позволяет ограничить "площадь поражения" рефакторинга продового кода несколькими методами фикстурного кода, а не десятками и потенциально сотнями методами кейсов.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Очевидно, что от продового кода можно изолировать только внешние тест-кейсы.
Все остальные виды тестов по определению будут вызывать методы продового кода напрямую.
Однако они всё ещё могут использовать слой тестовых абстракций для генерации тестовых данных, сетапа фикстуры и верификации.</p></aside></section><section class="doc-section level-1"><h2 id=_структура_директорий_тестов><a class=link href=#_структура_директорий_тестов>Структура директорий тестов</a></h2><p>Сейчас структура директорий строго не регламентирована, но общий план такой:</p><div class="olist arabic"><ol class=arabic><li>На верхнем уровне, так же как и в продовом коде есть разделение на универсальный код и код приложения (pro.azhidkov и pro.qyoga<sup>*</sup>);</li><li>В этих подпакетах есть по дополнительному подпакету tests;</li><li>В подпакетах tests есть по подпакету на каждый (релевантный) вид тестового кода - assertions, cases, clients, fixtures, infra, pages, platform;</li><li>Все эти подпакеты в целом повторяют структуру соответствующий части продового кода.</li></ol></div><p>В Trainer Advisor это выглядит так:</p><div class=table-block><table class="frame-all grid-all stretch"><col style=width:50%><col style=width:50%><tbody><tr><td class="halign-left valign-top">Тестовый код</td><td class="halign-left valign-top">Продовый код</td></tr><tr><td class="halign-left valign-top"><div class=image-block><img src=/microposts/24/03/images/2024-02-19-11-03-45.png alt="2024 02 19 11 03 45"></div></td><td class="halign-left valign-top"><div class=image-block><img src=/microposts/24/03/images/2024-02-19-11-07-44.png alt="2024 02 19 11 07 44"></div></td></tr></tbody></table></div><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p><sup>*</sup> Изначально проект назывался QYoga и на уровне исходников практически везде всё ещё используется это название.</p></aside></section><section class="doc-section level-1"><h2 id=_именование_тестов><a class=link href=#_именование_тестов>Именование тестов</a></h2><section class="doc-section level-2"><h3 id=_декомпозиция_кейсов_на_классы_и_именование_классов><a class=link href=#_декомпозиция_кейсов_на_классы_и_именование_классов>Декомпозиция кейсов на классы и именование классов</a></h3><p>Тут я ничего особо нового не придумал - кейсы я группирую по system under test, а сами классы называю по имени sut + суффикс Test.</p><p>sut я определяю по объекту, который выполнит тестируемое действие (забегая немного вперёд - код, который будет вызван в блоке When).</p><p>Но есть нюанс - объекты контроллеров могут быть sut-ом и внешнего теста (работающего через HTTP) и внутреннего (непосредственно вызывающего метод контроллера).
Я решил это так: из внешних тестов убираю суффикс Controller, а из внутренних нет.</p><p>В итоге имена классов выглядят так:</p><div class=ulist><ul><li>Внешний тест - CreateExercisePageTest, SchedulePageTest, AppointmentTypesComboBoxTest;</li><li>Внутренний тест - CreateAppointmentPageControllerTest, CreateExercisePageControllerTest;</li><li>Интеграционный тест - ExercisesServiceTest, UserSettingsRepoTest, MinioFilesStorageTest, HydrationTest;</li><li>Юнит тест - TimeZonesTest, CalendarPageModelTest, ProgramDocxGeneratorTest;</li></ul></div></section><section class="doc-section level-2"><h3 id=_именование_методов><a class=link href=#_именование_методов>Именование методов</a></h3><p>Сейчас в Trainer Advisor я придерживаюсь правила, что имя теста должно быть сформулировано как требование к поведению системы:</p><div class=ulist><ul><li>Примеры названий внешних тестов:<ul><li><code>After login with valid credentials user should be redirected to index page</code> - после логина с корректными учётными данными, пользователь должен быть перенаправлен стартовую страницу;</li><li><code>Registration page should be rendered correctly</code> - страница регистрации должна рендерится корректно;</li><li><code>Spring should respect X-Forwarded-For header</code> - Spring должен учитывать заголовок X-Forwarded-For;</li><li><code>After creation of a client, he should appear in the clients table</code> - после создания клиента, он должен появиться в списке клиентов;</li></ul></li><li>Тест на моках:<ul><li><code>Exercise deletion should fail in case of exercise deletion in db failure</code> - удаление упражнения должно завершаться ошибкой в случае сбоя удаления упражнения в БД;</li><li><code>Exercise deletion should complete successfully even in case of steps images deletion failure</code> - удаление упражнения должно завершаться успешно даже в случае сбоя удаления изображений шагов [упражнения];</li></ul></li><li>Юнит тест:<ul><li><code>Calendar should end after last appointment end time</code> - календарь должен заканчиваться после времени конца последнего приёма;</li><li><code>Search result should not contain duplicates when a time zone matches both id and title</code> - результат поиска не должен содержать дубли в случае, когда часовой пояс совпадает и с идентификатором и с названием</li></ul></li><li>Интеграционные тесты :<ul><li><code>When entity is hydrated with recursive fetch spec, then nested entity should be hydrated too</code> - в случае, когда сущность гидрируется с рекурсивной спецификацией выборки, вложенная сущность должна быть так же гидрирована;</li><li><code>Delete by id should delete only specified files</code> - удаление по идентификатору должно удалять только указанные файлы.</li></ul></li></ul></div><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Моё общее правило касательно именования тестов - имя теста практически никогда не должно содержать слово "test", потому как в моей практике, такие тесты ничего не говорят о пригодности приложения для использования.
Пример плохого имени: <code>Test login</code> (Протестировать логин).</p></aside></section></section><section class="doc-section level-1"><h2 id=_общая_структура_тест_кейса_givenwhenthen><a class=link href=#_общая_структура_тест_кейса_givenwhenthen>Общая структура тест кейса - Given/When/Then</a></h2><p>Методы тест кейсов я структурирую "по классике" - через <a href=https://en.wikipedia.org/wiki/Given-When-Then>Given (Дано, при условии что), When (Когда), Then (Тогда)</a> (aka <a href=https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/>Arrange, Act, Assert</a>).</p><figure class=listing-block><figcaption>Пример простого теста. <a href=https://github.com/d-r-q/QYoga/blob/48b80738904a957f6e7d4f96900ce20694ce5400/app/src/test/kotlin/pro/azhidkov/tests/cases/domain/timezones/TimeZonesTest.kt#L14>Смотреть на GitHub</a></figcaption><pre class="rouge highlight"><code data-lang=kotlin><span class=nd>@Test</span>
<span class=k>fun</span> <span class=nf>`Search</span> <span class=n>result</span> <span class=n>should</span> <span class=n>not</span> <span class=n>contain</span> <span class=n>duplicates</span> <span class=k>when</span> <span class=n>a</span> <span class=n>time</span> <span class=n>zone</span> <span class=n>matches</span> <span class=n>both</span> <span class=n>id</span> <span class=n>and</span> <span class=nf>title`</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// Given</span>
    <span class=kd>val</span> <span class=py>timeZoneId</span> <span class=p>=</span> <span class=s>&#34;Asia/Novosibirsk&#34;</span>
    <span class=kd>val</span> <span class=py>timeZoneTitle</span> <span class=p>=</span> <span class=s>&#34;Нововсибирск&#34;</span>

    <span class=c1>// When</span>
    <span class=kd>val</span> <span class=py>searchResult</span> <span class=p>=</span> <span class=n>russianTimeZones</span><span class=p>.</span><span class=nf>search</span><span class=p>(</span><span class=n>timeZoneId</span><span class=p>,</span> <span class=n>timeZoneTitle</span><span class=p>)</span>

    <span class=c1>// Then</span>
    <span class=n>searchResult</span><span class=p>.</span><span class=nf>shouldBeUnique</span><span class=p>()</span>
<span class=p>}</span></code></pre></figure><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Обращаю ваше внимание, что примеры кода в этом посте - это куски реального, по большому счёту боевого кода, а не небольшие вылизанные кусочки идеального кода для поста.
Поэтому не удивляйтесь, когда увидите дурнопахнущий код - в реальной жизни не бывает на 100% чистого кода.
Я постараюсь в комментариях подсветить все проблемные места, но могу что-то пропустить.</p></aside><figure class=listing-block><figcaption>Пример сложного теста. <a href=https://github.com/d-r-q/QYoga/blob/48b80738904a957f6e7d4f96900ce20694ce5400/app/src/test/kotlin/pro/qyoga/tests/cases/app/therapist/appointments/core/CreateAppointmentPageControllerTest.kt#L36>Смотреть на GitHub</a></figcaption><pre class="rouge highlight"><code data-lang=kotlin><span class=nd>@Test</span>
<span class=k>fun</span> <span class=nf>`Creation</span> <span class=n>of</span> <span class=n>appointment</span><span class=p>,</span> <span class=n>that</span> <span class=n>intersects</span> <span class=n>with</span> <span class=n>an</span> <span class=n>appointment</span> <span class=k>in</span> <span class=n>another</span> <span class=n>time</span> <span class=n>zone</span> <span class=n>should</span> <span class=nf>fail`</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// Given</span>
    <span class=kd>val</span> <span class=py>existingAppointmentTimeZone</span> <span class=p>=</span> <span class=n>asiaNovosibirsk</span>
    <span class=kd>val</span> <span class=py>newAppointmentTimeZone</span> <span class=p>=</span> <span class=n>europeMoscow</span>
    <span class=kd>val</span> <span class=py>existingAppointmentLocalDateTime</span> <span class=p>=</span> <span class=n>aDateTime</span>

    <span class=n>backgrounds</span><span class=p>.</span><span class=n>appointments</span><span class=p>.</span><span class=nf>create</span><span class=p>(</span>
        <span class=n>dateTime</span> <span class=p>=</span> <span class=n>existingAppointmentLocalDateTime</span><span class=p>,</span>
        <span class=n>timeZone</span> <span class=p>=</span> <span class=n>existingAppointmentTimeZone</span>
    <span class=p>)</span>

    <span class=kd>val</span> <span class=py>createNewAppointmentRequest</span> <span class=p>=</span> <span class=nf>randomEditAppointmentRequest</span><span class=p>(</span>
        <span class=n>client</span> <span class=p>=</span> <span class=nc>ClientsObjectMother</span><span class=p>.</span><span class=n>fakeClientRef</span><span class=p>,</span>
        <span class=c1>// Этой строчкой я хотел отразить, что астрономическое время нового приёма</span>
        <span class=c1>// совпадает со временем старого приёма, но сейчас кажется, что лучше это</span>
        <span class=c1>// было сделать через вывод двух LocalDateTime из одного Instant.</span>
        <span class=n>dateTime</span> <span class=p>=</span> <span class=n>aDate</span><span class=p>.</span><span class=nf>atTime</span><span class=p>(</span><span class=n>existingAppointmentLocalDateTime</span><span class=p>.</span><span class=k>get</span><span class=p>(</span><span class=nc>ChronoField</span><span class=p>.</span><span class=nc>HOUR_OF_DAY</span><span class=p>)</span> <span class=p>-</span> <span class=n>timeZonesDiff</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>
        <span class=n>timeZone</span> <span class=p>=</span> <span class=n>newAppointmentTimeZone</span>
    <span class=p>)</span>

    <span class=c1>// When</span>
    <span class=kd>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>controller</span><span class=p>.</span><span class=nf>createAppointment</span><span class=p>(</span>
        <span class=n>createNewAppointmentRequest</span><span class=p>,</span>
        <span class=n>theTherapistUserDetails</span>
    <span class=p>)</span>

    <span class=c1>// Then</span>
    <span class=n>result</span><span class=p>.</span><span class=nf>shouldBeIntersectionError</span><span class=p>()</span>
    <span class=n>backgrounds</span><span class=p>.</span><span class=n>appointments</span><span class=p>.</span><span class=nf>getDaySchedule</span><span class=p>(</span><span class=n>aDate</span><span class=p>)</span> <span class=n>shouldHaveSize</span> <span class=mi>1</span>
<span class=p>}</span></code></pre></figure><p>Не по классике у меня то, что я допускаю секции "And when" и "And then".
Хотя и стараюсь их избегать.</p><figure class=listing-block><figcaption>Пример многошагового теста. <a href=https://github.com/d-r-q/QYoga/blob/48b80738904a957f6e7d4f96900ce20694ce5400/app/src/test/kotlin/pro/qyoga/tests/cases/app/publc/RegistrationPageTest.kt#L42>Смотреть на GitHub</a></figcaption><pre class="rouge highlight"><code data-lang=kotlin><span class=nd>@Test</span>
<span class=k>fun</span> <span class=nf>`After</span> <span class=n>submit</span> <span class=n>of</span> <span class=n>registration</span> <span class=n>form</span> <span class=n>therapist</span> <span class=n>should</span> <span class=n>be</span> <span class=n>created</span> <span class=n>and</span> <span class=n>creds</span> <span class=n>should</span> <span class=n>be</span> <span class=n>sent</span> <span class=n>to</span> <span class=n>admin</span> <span class=n>and</span> <span class=n>success</span> <span class=n>response</span> <span class=n>should</span> <span class=n>be</span> <span class=nf>returned`</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// Given</span>
    <span class=kd>val</span> <span class=py>registerTherapistRequest</span> <span class=p>=</span> <span class=nf>registerTherapistRequest</span><span class=p>(</span>
        <span class=s>&#34;Сергей&#34;</span><span class=p>,</span>
        <span class=s>&#34;Сергеев&#34;</span><span class=p>,</span>
        <span class=s>&#34;new-therapist@qyoga.pro&#34;</span>
    <span class=p>)</span>

    <span class=c1>// When</span>
    <span class=kd>val</span> <span class=py>document</span> <span class=p>=</span> <span class=nc>PublicClient</span><span class=p>.</span><span class=n>authApi</span><span class=p>.</span><span class=nf>registerTherapist</span><span class=p>(</span><span class=n>registerTherapistRequest</span><span class=p>)</span>

    <span class=c1>// Then</span>
    <span class=n>document</span> <span class=n>shouldHaveComponent</span> <span class=nc>RegistrationSuccessFragment</span>

    <span class=c1>// And then</span>
    <span class=kd>val</span> <span class=py>receivedMessages</span> <span class=p>=</span> <span class=n>greenMail</span><span class=p>.</span><span class=nf>getReceivedMessagesForDomain</span><span class=p>(</span><span class=n>adminEmail</span><span class=p>)</span>
    <span class=n>receivedMessages</span> <span class=n>shouldHaveSize</span> <span class=mi>1</span>
    <span class=c1>// Здесь я нарушаю правило &#34;код должен делать одну вещь&#34;</span>
    <span class=c1>// shouldMatch - и верифицирует сообщение и извлекает из него данные.</span>
    <span class=c1>// Если бы я вылизывал этот код, чтобы сделать из него эталон - я бы, скорее всего</span>
    <span class=c1>// вытащил получение емейла и пароля в отдельный метод.</span>
    <span class=kd>val</span> <span class=p>(</span><span class=py>receivedTherapistEmail</span><span class=p>,</span> <span class=py>password</span><span class=p>)</span> <span class=p>=</span> <span class=n>receivedMessages</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=n>shouldMatch</span> <span class=n>registerTherapistRequest</span>

    <span class=c1>// And when</span>
    <span class=kd>val</span> <span class=py>therapist</span> <span class=p>=</span> <span class=nc>TherapistClient</span><span class=p>.</span><span class=nf>login</span><span class=p>(</span><span class=n>receivedTherapistEmail</span><span class=p>,</span> <span class=n>password</span><span class=p>)</span>
    <span class=kd>val</span> <span class=py>getClientsResponse</span> <span class=p>=</span> <span class=n>therapist</span><span class=p>.</span><span class=n>clients</span><span class=p>.</span><span class=nf>getClientsListPage</span><span class=p>()</span>

    <span class=c1>// Then</span>
    <span class=n>getClientsResponse</span> <span class=n>shouldBe</span> <span class=nc>ClientsListPage</span>
<span class=p>}</span></code></pre></figure></section><section class="doc-section level-1"><h2 id=_разработка_направляемая_тестами><a class=link href=#_разработка_направляемая_тестами>Разработка, направляемая тестами</a></h2><p>Ортогональным всем описанным выше принципам и практикам является вопрос "Когда писать тесты?" - до или после продового кода?
Я долгое время утверждал, что <a href=https://habr.com/ru/companies/jugru/articles/571126/>классическая школа ТДД</a> является одним из столпов Эргономичного подхода.
Однако при написании этого поста, я понял что в целом я хоть и сторонник "tests-first" разработки, назвать мой подход Tests-Driven Development (или даже Design) - нельзя.</p><p>У меня при словах "test-driven development" в памяти всплывают видео, на которых Мартин как сумасшедший мечется налево и направо и долбит в воздухе по воображаемой клавиатуре, изображая ежесекундное переключение между тестовым и продовым кодом; или как Куксенко или Кекс под лозунгом "самый простой код, который сделает тест зелёными" пишет какую-то полную дичь, которую очевидно придётся переписать на следующей же итерации.</p><p>Моя работа проходит не так.
Новые фичи я действительно обычно начинаю писать с внешнего теста (работающего через HTTP), но у меня намного более длинный цикл (надеюсь, я в этом году всё-таки созрею до того, чтобы записать видео моего процесса разработки), в отличие от Мартина и я не пишу код на выброс, в отличие от Куксенко.</p><p>Фиксы я тоже начинаю с теста, но тут уже наоборот в первую очередь пытаюсь сделать более простой внутренний тест (работающий через прямой вызов метода контроллера), переходя к внешнему, только если ошибка видима только на уровне вёрстки.</p><p>И так как я занимаюсь "ковровым тестированием" - после реализации фичи и прохождения теста, нередко остаются кейсы, которые уже реализованы, но не покрыты тестами - такие кейсы я покрываю тестами постфактум.
При том тут уже стараюсь перейти на внутренние тесты или, при необходимости, на юнит тесты или тесты на моках.</p></section><section class="doc-section level-1"><h2 id=_заключение><a class=link href=#_заключение>Заключение</a></h2><p>В этом посте я рассмотрел основополагающие принципы и модели, которых придерживаюсь при разработке тестов Trainer Advisor.
В следующем посте я подробно расскажу всю мякотку самой "волосатой" части тестового кода - сетапа фикстуры - как я управляюсь с БД и создаю тестовые объекты.</p></section></article></section></div></main><script src=/js/app.js></script></body></html>