<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Заметки по докладам со Spring IO 2022 - Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/microposts/22/10/spring-one-22/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/microposts/22/10/spring-one-22/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/microposts/22/10/spring-one-22/><title>Заметки по докладам со Spring IO 2022 - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/microposts/22/10/spring-one-22/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/effects-diagram/landing>Диаграмма Эффектов</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li><li class=multilingual-separator><p>|</p></li><li class="navigation-item align-left"><a href=https://azhidkov.pro/en/>En</a></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Заметки по докладам со Spring IO 2022</h1></header><p>На той неделе я был в полуотпуске и посмотрел 3 миллиона видео со <a href=https://2022.springio.net/>Spring IO 2022</a> и <a href=https://springone.io/2021/schedule>SpringOne 2021</a>.
На удивление, из докладов SpringOne (вроде как главной конфы по Spring) - меня вообще ничего не заинтересовало.
Большую часть я даже открывать не стал, а то что посмотрел - зря время потратил, хоть и на x1.5 и многое просто перематывая.</p><p>А вот на Spring IO было много прям крутых докладов и я собрал микропост (пост, написанный за один проход без редактуры) из своих заметок по этим видео.</p><section class="doc-section level-1"><h2 id=_серия_про_модульные_приложения><a class=link href=#_серия_про_модульные_приложения>Серия про модульные приложения</a></h2><section class="doc-section level-2"><h3 id=_modular_applications><a class=link href=#_modular_applications>Modular Applications</a></h3><p><a class=bare href="https://www.youtube.com/watch?v=DlQ6Ht9Cf5s&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=25">https://www.youtube.com/watch?v=DlQ6Ht9Cf5s&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=25</a></p><p>Тут мужики всё правильно говорят.
Но есть нюанс.
В качестве ответа на вопрос "как находить границы модулей" они предлагают DDD.
И если вы можете себе это позволить - круто, делайте так.
Если же вы (как и я) не можете себе этого позволить - попробуйте более простую методику на базе эффектов.
У меня есть <a href="https://azhidkov.pro/posts/22/08/ergonomic-decomposition/#<em>%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5</em>%D0%BF%D0%BE_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0%D0%BC_%D0%B0%D0%BA%D0%B0_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE_%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B4%D0%B5%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F">пост с подводкой</a> и кратким описанием этой методики, но полноценный пост я ещё не осилил.
Он у меня первый в очереди, но пока что у меня львиную долю сил и внимания отнимает Проект Э.</p><p>Молния!!!
Spring ведёт R&D проект "Modulith", по поддержке модульных монолитов!</p><p>Лет 5-6 назад я ненавидел Спринг и считал его корнем всех бед в архитектуре (пакетирование по слоям, инъекция на филдах, глобальный компонент скан, анемичная модель, связный двунаправленный граф JPA-сущностей).
А сейчас вижу, что у нас (теперь) общие ценности - начиная с рекомендации инъекции через конструктор, продолжая рекомендуемой структурой пакетов (<a href=https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.structuring-your-code.locating-the-main-class>Locating the Main Application Class</a>) и рекомендацией делать репозы на агрегаты, а не сущности (<a href=https://stackoverflow.com/questions/21265262/are-you-supposed-to-have-one-repository-per-table-in-jpa>Are you supposed to have one repository per table in JPA?</a>) вместе с Spring Data JDBC, который, кажется, они сейчас активно продвигают вместо JPA и вот заканчивая "Modulith-ом".</p></section><section class="doc-section level-2"><h3 id=_getting_modules_right_with_domain_driven_design><a class=link href=#_getting_modules_right_with_domain_driven_design>Getting modules right with Domain-driven Design</a></h3><p><a class=bare href="https://www.youtube.com/watch?v=Q_0XW46IlHY&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=49">https://www.youtube.com/watch?v=Q_0XW46IlHY&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=49</a></p><p>Тут мужик расказывает как искать границы по DDD.
И лишь подтверждает мой тезис, что это не для всех - сначала надо собрать всю команду включая доменных экспертов в большой комнате с длинной стеной и провести сессию "эвент шторминга" (не путать с "сорсингом") - я не представляю, как мне это проделывать на моих проектах.</p><p>Ещё интересная мысль - ООАД фокусируется на существительных, а ДДД - на глаголах. А ЭП/ОД, судя по всему (раньше не думал в этом ключе), на их связях</p></section><section class="doc-section level-2"><h3 id=_spring_for_the_architecturally_curious_developer><a class=link href=#_spring_for_the_architecturally_curious_developer>Spring for the architecturally curious developer</a></h3><p><a class=bare href="https://www.youtube.com/watch?v=zrqupmaIsto&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=31">https://www.youtube.com/watch?v=zrqupmaIsto&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=31</a>).</p><p>В этом докладе один из содокладчиков первого показывает Modulith в действии.
И это очень круто - в тестах я сейчас примерно тош самое пытаюсь делать на коленке с переменным успехом.</p><p>А генерация доков - это вообще бомба.</p></section></section><section class="doc-section level-1"><h2 id=_lets_build_components_not_layers><a class=link href=#_lets_build_components_not_layers>Let’s build components, not layers</a></h2><p><a class=bare href="https://www.youtube.com/watch?v=-VmhytwBZVs&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=38">https://www.youtube.com/watch?v=-VmhytwBZVs&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=38</a></p><p>Увидев докладчика, я начал относиться к докладу со скепсисом, т.к. недавно читал его книгу, где он топил за чистую архитектуру.
Но в то же время, я вполне успешно использую его идеи по созданию модулей в Spring-приложениях, поэтому всё-таки продолжил смотреть.
И не зря.</p><p>Как и я, сейчас он пришёл к выводу, что ЧА не должна быть выбором по умолчанию.
А выбором по умолчанию должна быть компонентная архитектура.</p><p>Однако, как и все прочие подобные доклады, он не говорит как компоненты находить - в своём примере он их просто дал свыше.
А я - говорю:)</p><p>Смотрите этот доклад, берите на вооружение декомпозицию на базе эффектов для поиска компонентов и вы получите добрую половину Эргономичного подхода.
Читайте и применяйте PPP of Unit Testing (включая функциональную архитектуру) и вы получите ЭП целиком:)</p><p>Плюс я прямо сейчас как раз думаю вести в гайдлайн Проекта Э пакеты api (с сервисами и тем, что у них в публичном интерфейсе светится) и impl (со всем остальным), но пока только думаю.</p><p>Ну и он там топит за заголовочные интерфейсы.
Но у него есть хороший аргумент за них - у него на этом базируется ArchUnit-чек, который следит, за тем чтобы никто не лазил в кишки модуля.
Я сам до ArchUnit ещё не добрался, но если доберусь и пойму, что подругому никак - тоже соглашусь на заголовочные интерфейсы.</p></section><section class="doc-section level-1"><h2 id=_thoughts_about_layered_architecture_mapping_efficiently_with_sql><a class=link href=#_thoughts_about_layered_architecture_mapping_efficiently_with_sql>Thoughts about layered architecture – Mapping efficiently with SQL</a></h2><p><a class=bare href="https://www.youtube.com/watch?v=glxS4Ffxtdw&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=23">https://www.youtube.com/watch?v=glxS4Ffxtdw&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=23</a></p><p>Как можно догадаться из названия, тут мужик топит за то, чтобы в случае простого чтения выкинуть нафиг сервисы и весь маппинг и стримить данные из БД напрямую в браузер.
Хорошая идея, я об этом давно думаю и даже писал пару раз, но пока так и не решился.
Он там говорит, что добавление поля в стандартной схеме потребует кучи изменений в куче разных файлов.
Но если стримить напрямую из базы, то это всё равно будет куча изменений, хоть и в одном файле.
Плюс мы потеряем красивое описание модели данных, по которому можно чудесным образом сваггер сгенерять.</p><p>Но что меня больше всего пугает: там где такой подход даст больше всего пользы - запросы где надо вытащить кучу данных из кучи таблиц - этот подход нанесёт больше всего вреда с точки зрения инкапсуляции.
В моём мире за каждую таблицу отвечает один модуль, и если какой-то модуль начинает напрямую лазить в чужие таблицы, то это вопиющее нарушение инкапсуляции.
Именно из-за этого я пока держусь в стороне от этого подхода.</p><p>Ну приводит один из моих любимых аргументов против JPA - показывает код маппера и спрашивает есть ли там побочные эффекты (обращения к БД).
Ответ - it depends (c).
Невозможно ответить на этот вопрос, т.к. ответ зависит от маппинга сущностей и что творилось в коде выше по стеку.
Это и есть "нелокальность" рассуждений ака сложность кода, которую всегда тащит ленивая загрузка.</p></section><section class="doc-section level-1"><h2 id=_how_fixing_a_broken_window_cut_down_our_build_time_by_50><a class=link href=#_how_fixing_a_broken_window_cut_down_our_build_time_by_50>How fixing a broken window cut down our build time by 50%</a></h2><p><a class=bare href="https://www.youtube.com/watch?v=c-GV2PxymoY&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=12">https://www.youtube.com/watch?v=c-GV2PxymoY&list=PLe6FX2SlkJdTVSt4D3bBCOkVeXB0qGdEY&index=12</a></p><p>Хороший доклад, показывающий как правильно писать тесты на Spring, чтобы они работали настолько быстро, насколько это возможно.
Спойлер - надо не использовать фичи, которые ломают кэш контекстов (DynamicPropertySource, MockBean, Spy и т.д.).</p><p>От себя добавлю ещё пару советов:</p><div class="olist arabic"><ol class=arabic><li>Используйте переиспользуемые тест-контейнеры (<a class=bare href=https://rieckpil.de/reuse-containers-with-testcontainers-for-fast-integration-tests/>https://rieckpil.de/reuse-containers-with-testcontainers-for-fast-integration-tests/</a>)</li><li>Базы храните на RAM-диске (<code>.withTmpFs(mapOf("/var" to "rw")).withEnv("PGDATA", "/var/lib/postgresql/data-no-mounted")</code>)</li></ol></div></section><section class="doc-section level-1"><h2 id=_modern_frontends_using_spring_boot_and_thymeleaf_with_htmx><a class=link href=#_modern_frontends_using_spring_boot_and_thymeleaf_with_htmx>Modern frontends using Spring Boot and Thymeleaf with htmx</a></h2><p><a class=bare href="https://www.youtube.com/watch?v=okCdaBTQsik">https://www.youtube.com/watch?v=okCdaBTQsik</a></p><p>Возможно вам не нужны фронтэндеры, React, Redux, nodejs, npm, webpack, javascript, jsx, REST API, боль и страдания.
Возможно ваш фронт вполне можно сделать на Thymelead + HTML + htmx + Bootstrap + чуть-чуть <a href=https://alpinejs.dev/>Alpine.js</a>.</p><p>Я сам за последние лет 7 ни разу так не делал, но в последнее время мне эта идея всё больше и больше нравится.
Один внутренний проект с серверным рендерингом мы уже сделали очень успешно (в плане трудозатрат) и при первом удобном случае я попробую пропихнуть такой подход в коммерческий проект.</p><p>И ещё доклады про htmx:</p><div class="olist arabic"><ol class=arabic><li><a class=bare href="https://www.youtube.com/watch?v=38WAVRfxPxI">https://www.youtube.com/watch?v=38WAVRfxPxI</a></li><li><a class=bare href="https://www.youtube.com/watch?v=u2rjnLJ1M98">https://www.youtube.com/watch?v=u2rjnLJ1M98</a></li></ol></div></section></article></section></div></main><script src=/js/app.js></script></body></html>